# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

"""
Minimal type stubs for PyTorch Tensor with shape inference.

This provides just the Tensor class with:
- Shape type parameter for static shape tracking
- .shape property returning tuple of dimensions
- Arithmetic operations that preserve shape (return Self)

No tensor constructors or shape-transforming methods are included.
Those require meta-shape inference which is added in a subsequent commit.
"""

from typing import Any, Self

__all__ = ["Tensor"]

class Tensor[*Shape]:
    """
    PyTorch Tensor with shape type parameter.

    The shape is tracked at the type level, allowing static verification
    of tensor operations.
    """

    # ==== Tensor Properties ====
    shape: tuple[int, ...]  # Tensor shape as a tuple
    requires_grad: bool  # Whether gradient tracking is enabled
    device: Any  # Device where tensor is stored (cpu, cuda, etc.)
    dtype: Any  # Data type of tensor elements (float32, int64, etc.)

    # ==== Arithmetic Operations ====
    # These return Self, preserving the tensor's shape

    def __add__(self, other: Tensor | float | int) -> Self: ...
    def __sub__(self, other: Tensor | float | int) -> Self: ...
    def __mul__(self, other: Tensor | float | int) -> Self: ...
    def __truediv__(self, other: Tensor | float | int) -> Self: ...
    def __floordiv__(self, other: Tensor | float | int) -> Self: ...
    def __pow__(self, other: Tensor | float | int) -> Self: ...
    def __mod__(self, other: Tensor | float | int) -> Self: ...

    # Reverse operations for scalars
    def __radd__(self, other: float | int) -> Self: ...
    def __rsub__(self, other: float | int) -> Self: ...
    def __rmul__(self, other: float | int) -> Self: ...
    def __rtruediv__(self, other: float | int) -> Self: ...
    def __rfloordiv__(self, other: float | int) -> Self: ...
    def __rpow__(self, other: float | int) -> Self: ...
    def __rmod__(self, other: float | int) -> Self: ...

    # Unary operations
    def __neg__(self) -> Self: ...
    def __pos__(self) -> Self: ...
    def __abs__(self) -> Self: ...

    # ==== Comparison Operations ====
    # Return boolean tensors with the same shape

    def __eq__(self, other: Tensor | float | int) -> Self: ...  # type: ignore[override]
    def __ne__(self, other: Tensor | float | int) -> Self: ...  # type: ignore[override]
    def __lt__(self, other: Tensor | float | int) -> Self: ...
    def __le__(self, other: Tensor | float | int) -> Self: ...
    def __gt__(self, other: Tensor | float | int) -> Self: ...
    def __ge__(self, other: Tensor | float | int) -> Self: ...

    # ==== In-place Operations ====
    # These mutate the tensor and return Self

    def __iadd__(self, other: Tensor | float | int) -> Self: ...
    def __isub__(self, other: Tensor | float | int) -> Self: ...
    def __imul__(self, other: Tensor | float | int) -> Self: ...
    def __itruediv__(self, other: Tensor | float | int) -> Self: ...
