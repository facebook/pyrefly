[{"title":"Give your Python IDE a Glow-Up with Pyrefly","type":0,"sectionRef":"#","url":"/blog/2025/09/15/ide-extension/","content":"","keywords":"","version":null},{"title":"Background - What is a Language Server and Why Does It Matter?‚Äã","type":1,"pageTitle":"Give your Python IDE a Glow-Up with Pyrefly","url":"/blog/2025/09/15/ide-extension/#background---what-is-a-language-server-and-why-does-it-matter","content":" The Language Server Protocol (LSP) is a standardized way for code editors to communicate with language-specific servers that provide features like autocomplete, go-to-definition, and symbol renaming. Instead of each editor implementing these features separately, LSP allows a single language server to support multiple editors. Pyrefly‚Äôs language server capabilities are based on the Language Server Protocol Specification and are designed to still be blazing fast even on code bases with over 20 million lines of code.  A key capability of many language servers, including Pyrefly, is typechecking, which enhances IDE features by providing type diagnostics. Pyrefly‚Äôs language server not only reports type errors like basic type checkers, such as Mypy, but also replaces core IDE functionalities including ‚Äúfind definition,‚Äù hover (displaying types and docstrings), and completions. By consolidating these features, Pyrefly ensures that the types it checks and the types displayed in your IDE will always match.  ","version":null,"tagName":"h2"},{"title":"Instagram - A Case Study on the Pain of Slow Code Navigation‚Äã","type":1,"pageTitle":"Give your Python IDE a Glow-Up with Pyrefly","url":"/blog/2025/09/15/ide-extension/#instagram---a-case-study-on-the-pain-of-slow-code-navigation","content":" Meta operates an incredibly large Python codebase - a massive monorepo containing almost 1.5 million Python files maintained by thousands of developers. Instagram is one of those projects, with over 20 million lines of Python code. At this scale, even simple navigation tasks like jumping to a function definition, searching for references, or loading syntax highlights could take almost a minute in the worst cases. That may not sound like a lot on its own, but experiencing it every few minutes quickly becomes frustrating and has a tangible impact on developer productivity, especially when multiplied across a large company like Meta.  Pyrefly emerged in part to address this exact challenge (you can read more about our origin story in our intro blog). In real world use cases, developers who switched from Pyright (the default LSP for VSCode) to Pyrefly spent 98% less time waiting on hover results and go-to definition was ~10x faster. On the slowest files (p99), these IDE responses grew from an order of minutes to seconds (30x improvement). If those numbers are hard to visualise, the TL;DR is that this upgrade took instagram developers from questioning ‚Äúis my editor frozen?‚Äù to not giving their IDE a second thought.    Pyrefly (left) vs Pyright (right) autocomplete speed comparison  These early results are certainly promising indications of a smoother developer experience for Meta engineers, and we're excited to share more insights as developers continue using Pyrefly. But Pyrefly isn‚Äôt just for Meta developers, it‚Äôs open source and ready for everyone to explore! If you‚Äôre curious about Pyrefly‚Äôs language server features and want to see how to get it up and running in your IDE, keep reading!  ","version":null,"tagName":"h2"},{"title":"Pyrefly LSP at a Glance‚Äã","type":1,"pageTitle":"Give your Python IDE a Glow-Up with Pyrefly","url":"/blog/2025/09/15/ide-extension/#pyrefly-lsp-at-a-glance","content":" While Pyrefly is still in Alpha as of the time of posting, it already supports most of the essential IDE capabilities that Python developers rely on daily, such as:  Autocomplete: predicts what you‚Äôre likely to type next, reducing the need to remember exact names of variables, functions, and others, even importing them automatically for youGo to Definition: allows you to jump directly to the source of a function, class, or variable with a single click.Hover: when you hover over a symbol, Pyrefly displays useful information such as type annotations, documentation, and inferred types.Rename symbols: right click to rename variables, functions, or classes across the entire codebase.Typechecking: Pyrefly will also show type errors and infer types, which you can toggle on or off in your Pyrefly settings (more info in the next section)And many more! explore the full list and details in the Pyrefly IDE docs.  The Pyrefly team and our open-source community are continuously working on improvements and new features so stay tuned for updates! We also want to hear from you - what features do you need to make your IDE experience better? Open a GitHub issue or join our discord to share your thoughts.  ","version":null,"tagName":"h2"},{"title":"How to add Pyrefly to your IDE‚Äã","type":1,"pageTitle":"Give your Python IDE a Glow-Up with Pyrefly","url":"/blog/2025/09/15/ide-extension/#how-to-add-pyrefly-to-your-ide","content":" Pyrefly can be used in a range of IDEs, including standard GUI editors like VSCode or Pycharm, terminal editors like Neovim or Emacs, and AI editors like Cursor or Windsurf. You can check out the full list of supported IDEs in the Pyrefly IDE docs.  For GUI editors, setup is pretty straightforward and generally follows the same steps:  Search for ‚Äúpyrefly‚Äù in the appropriate extension marketplace for your IDE and install itOpen any Python file and the extension will activate automaticallyNote: if using an editor other than VSCode you may need to uninstall the default Python LSP in your editor. You can do this by opening your extension settings and setting &quot;Language Server: None&quot;Optional: we recommend all developers use a typechecker as part of their regular software development process, however we know that type errors in your IDE can be noisy, so the type errors feature is not turned on by default if you don't have a pyrefly.toml (from pyrefly init). If you DO want type errors to show up in your editor everywhere (as red squiggles), you should update your extension settings to include &quot;python.pyrefly.displayTypeErrors&quot;: &quot;force-on&quot;    For terminal editors the setup process can vary depending on which editor you use so check out the installation documentation for specific instructions.  ","version":null,"tagName":"h2"},{"title":"Conclusion‚Äã","type":1,"pageTitle":"Give your Python IDE a Glow-Up with Pyrefly","url":"/blog/2025/09/15/ide-extension/#conclusion","content":" As Python projects continue to grow in size and complexity, having a fast, reliable, and scalable language server is essential for maintaining developer productivity (and our sanity to be honest). So if you‚Äôre working on a large codebase and want an LSP designed with scalability in mind we invite you to give Pyrefly a try!  While the project is still in Alpha we‚Äôre especially eager to hear from more users like you about how the IDE extension performs on real world codebases. If you have any feedback, bug reports or feature requests please feel free to open a GitHub issue, and if you have any questions or need support please come chat with us on Discord!  Happy coding, fellow pyreflies! üî•ü™∞ ","version":null,"tagName":"h2"},{"title":"Making Pyrefly Diagnostics 18x Faster","type":0,"sectionRef":"#","url":"/blog/2026/02/06/performance-improvements/","content":"","keywords":"","version":null},{"title":"The Problem‚Äã","type":1,"pageTitle":"Making Pyrefly Diagnostics 18x Faster","url":"/blog/2026/02/06/performance-improvements/#the-problem","content":" Say you‚Äôre working in a very large codebase and have two files open in your editor, A and B.  A is a ‚Äúload-bearing‚Äù file that has many reverse dependencies - that is to say, many files directly or transitively import A.B is one of the files that imports A.  Incremental type checking should be snappy - when you edit A and save the file, any effects on the type errors in B should be reflected almost instantly. However, in a small number of cases, we found that updates could take multiple seconds.  ","version":null,"tagName":"h2"},{"title":"How Incremental Updates Work in Pyrefly‚Äã","type":1,"pageTitle":"Making Pyrefly Diagnostics 18x Faster","url":"/blog/2026/02/06/performance-improvements/#how-incremental-updates-work-in-pyrefly","content":" To understand how this problem arises, we need to look at how incremental updates currently work. Pyrefly‚Äôs analysis operates at the module level, meaning it keeps track of the types exported from each module, as well as the dependencies between modules. Let‚Äôs illustrate with a simple example.    The above image demonstrates a file A that has 4 reverse-dependencies. B1-B4 all rely on the types exported from A.  When file A is edited &amp; saved, we recheck A to see if any of its exported types also change. If so, we recheck every file that imports A (and if any of those files‚Äô exports changed, we recheck their dependencies, and so on until the change to A has been successfully propagated everywhere). After all of that finishes, we display updated errors in the IDE.  There are two key observations here:  Our dependency tracking rechecks a module when any export changes, even if the module does not depend on the export that changed. This can lead to modules being rechecked unnecessarily.We are waiting until the update has completely propagated to every affected file before sending any updated diagnostics, when in practice we mostly care about the files the user has open.  ","version":null,"tagName":"h3"},{"title":"Solution 1: Fine-grained dependency tracking‚Äã","type":1,"pageTitle":"Making Pyrefly Diagnostics 18x Faster","url":"/blog/2026/02/06/performance-improvements/#solution-1-fine-grained-dependency-tracking","content":" Instead of just tracking whether or not a module depends on another module for invalidation, we can specifically track what‚Äôs used.  Looking again at the example above, instead of rechecking everything that imports A, with smarter dependency tracking we could only recheck a subset of relevant files:    But the types a module depends on are not only from imports. Imagine a program like this with a chained method call:  from module import Class Class().returns_type().operation_on_type()   Even though we only import Class, this module still depends on the type returned in returns_type().  Similarly, returns_type() could be implemented in a base of Class, so we really might be depending on a class hierarchy instead of just Class from module.  And should a change to an unrelated part of numpy invalidate this program (i.e. recheck the module)? Probably not.  import numpy as np array = np.ones(1)   As you can see, a program‚Äôs type dependency structure is much more complicated and expansive than it might originally appear.  Since Pyrefly v0.51.1, we no longer invalidate a module any time a dependency changes. We now track exactly which types the module depends on at lookup to prune the modules that must be recomputed. In load-bearing files like the example in the introduction, this change turns what could be a 2000+ module invalidation into an invalidation of just over 100 modules.  ","version":null,"tagName":"h2"},{"title":"Solution 2: Streaming diagnostics‚Äã","type":1,"pageTitle":"Making Pyrefly Diagnostics 18x Faster","url":"/blog/2026/02/06/performance-improvements/#solution-2-streaming-diagnostics","content":" The other key insight from earlier is that we‚Äôre waiting for the update to finish completely before refreshing the errors in the IDE. To improve this, we could stream updated diagnostics to the IDE as soon as an open file has been rechecked, without waiting for other modules to be rechecked.  Let‚Äôs imagine a project with a dependency structure that looks like this. A is the file that we are editing, and B is another file that we have open, which is affected by edits to the types in A. As a user, what we want is for changes we make in A to be reflected in B with minimal delay.    Highlighted in red are the reverse dependencies of A, which may need to be rechecked if A is updated. Previously, we would recheck all the red modules before updating the diagnostics for B.    Highlighted in blue are the transitive dependencies of B. Only changes to those modules affect the types and diagnostics for B.    The image below shows the intersection of A‚Äôs reverse dependencies and B‚Äôs dependencies in purple. Once those modules are checked, we can show updated diagnostics for open files to the user, while continuing to check the remaining modules (red) in the background.    In order to provide a smooth IDE experience, Pyrefly runs language server operations (e.g. hover, autocomplete, go-to-def) on one thread and rechecks on another thread, that way users can still use language server features while a recheck is happening in the background. Previously, the main language server thread would send updated diagnostics to the IDE, and only did so once it received a signal from the recheck thread that a recheck had finished. Now with streaming diagnostics in Pyrefly v0.52.0, the recheck thread can emit the diagnostics to the frontend directly.  This change means that diagnostics can now be emitted from both the main thread and the recheck thread. To prevent conflicts between diagnostics sent from different threads, we add a restriction so that only one thread may send diagnostics for a given file at a given time. When a recheck is ongoing, the main thread cannot send diagnostics for any files eligible for streaming diagnostics.  ","version":null,"tagName":"h2"},{"title":"Results‚Äã","type":1,"pageTitle":"Making Pyrefly Diagnostics 18x Faster","url":"/blog/2026/02/06/performance-improvements/#results","content":" Combined, these two optimizations enable Pyrefly to provide updated diagnostics 18x faster than before. Going back to the example from the introduction, these changes reduce the diagnostic update time from ~3.6 seconds to under 200ms on an M4 Macbook Pro. For users, this means type errors refresh instantly after saving a file, a dramatic improvement:    To see how we benchmarked this, you can check out testing instructions on GitHub here  ","version":null,"tagName":"h2"},{"title":"What‚Äôs Next?‚Äã","type":1,"pageTitle":"Making Pyrefly Diagnostics 18x Faster","url":"/blog/2026/02/06/performance-improvements/#whats-next","content":" This was a tricky case to fix and we‚Äôve made significant progress, but how fast is fast enough?  Speed continues to be a top priority for us on the Pyrefly team. While we‚Äôve addressed the core problem, we‚Äôre always on the lookout for opportunities to further optimize performance, so stay tuned for further updates and make sure to regularly update your Pyrefly version. As we move toward v1, we‚Äôre carefully weighing additional speed improvements alongside other critical priorities like memory efficiency, bug fixes, and enhanced inference capabilities. Our goal is to deliver the fastest experience possible without compromising on overall functionality.  As always, if you‚Äôve found a problem, please let us know by opening a GitHub issue.  And if you‚Äôve made it this far, thanks for journeying down this rabbit hole with us! We hope you give Pyrefly a try if you haven‚Äôt already, see you for the next update! ","version":null,"tagName":"h2"},{"title":"Fly through data validation with Pyrefly‚Äôs new Pydantic integration","type":0,"sectionRef":"#","url":"/blog/pyrefly-pydantic/","content":"","keywords":"","version":null},{"title":"","type":1,"pageTitle":"Fly through data validation with Pyrefly‚Äôs new Pydantic integration","url":"/blog/pyrefly-pydantic/##","content":" ","version":null,"tagName":"h2"},{"title":"Background - Pydantic Basics‚Äã","type":1,"pageTitle":"Fly through data validation with Pyrefly‚Äôs new Pydantic integration","url":"/blog/pyrefly-pydantic/#background---pydantic-basics","content":" Pydantic leverages type annotations for data validation and parsing. Similar to Python‚Äôs built-in dataclasses, it helps you create structured data containers in your code. But Pydantic takes it a step further by providing extensive runtime data validation, ensuring that data matches the expected types and formats as soon as it‚Äôs instantiated.  For example:  from pydantic import BaseModel, Field class User(BaseModel): id: int name: str = Field(..., min_length=1) email: str # Example usage user = User(id=123, name=&quot;Alice&quot;, email=&quot;alice@example.com&quot;) print(user)   Using the code above, if you were to create a User instance, Pydantic would automatically validate the types and constraints. So if you pass invalid data (e.g., name=&quot;&quot; or id=&quot;not an int&quot;), Pydantic will raise a ValidationError at runtime.  ","version":null,"tagName":"h2"},{"title":"Pyrefly & Pydantic - How it works‚Äã","type":1,"pageTitle":"Fly through data validation with Pyrefly‚Äôs new Pydantic integration","url":"/blog/pyrefly-pydantic/#pyrefly--pydantic---how-it-works","content":" So how does Pyrefly work with Pydantic? For this initial experimental support we focused on delivering the following experiences:  Understands models and constructs: Pyrefly supports core Pydantic features, including BaseModel, Field, ConfigDict, as well as model-level configuration. No import errors or pesky red squiggles because your typechecker/language server doesn‚Äôt understand what Pydantic is.Automatic Recognition: Pyrefly detects Pydantic models and constructs out-of-the-box. There‚Äôs no need to install plugins, add configuration files, or tweak settings. You can just write your Pydantic code and Pyrefly will handle the rest.Static Analysis That Reflects Runtime Logic: One of the biggest challenges with Pydantic is that much of its validation and type coercion happens at runtime. Pyrefly‚Äôs static analysis engine is built to reflect Pydantic‚Äôs runtime logic as much as possible, ensuring that what you get in your IDE matches what will happen when your code runs.Immediate Feedback: As you write and edit your models, Pyrefly provides instant type errors and warnings. This helps you catch mistakes early, reducing debugging time and improving code quality.  For the full list of supported Pydantic features check out the documentation here.  ","version":null,"tagName":"h2"},{"title":"Automatic Recognition - Write Pydantic-ally while Pyrefly gets out the way‚Äã","type":1,"pageTitle":"Fly through data validation with Pyrefly‚Äôs new Pydantic integration","url":"/blog/pyrefly-pydantic/#automatic-recognition---write-pydantic-ally-while-pyrefly-gets-out-the-way","content":" Let's take a closer look at how Pyrefly works differently to other type checkers, particularly in its unobtrusive approach. A key illustration of this difference is Pyrefly's interpretation of strictness.  Pydantic offers flexible validation modes to suit different use cases:  Lax (Default) Mode: In this mode, Pydantic will automatically coerce types where possible. For example, if you pass ‚Äù123‚Äù(a string) to a field expecting an int, Pydantic will convert (i.e. coerce) it to 123 (an int). This is convenient for handling loosely-typed input, such as data from APIs or user forms.Strict Mode: here Pydantic enforces exact types, no coercion is performed. If you pass a string to an integer field, you‚Äôll get a validation error. This is ideal for scenarios where data integrity is paramount.  The handy thing about Pyrefly is that it automatically respects your choices on this matter. It reads your model‚Äôs configuration (such as ConfigDict or model-level config) to determine which mode to apply. For example, in the following code we are explicitly setting the age field using strict mode. Pyrefly inspects this statement directly and adapts its analysis to match your intent (in this case by reporting an error if a string age is passed).  from pydantic import BaseModel, Field class User(BaseModel): name: str age: int = Field(strict=True) # strict mode # Pyrefly will report an error here. y = User(name=&quot;Alice&quot;, age=&quot;30&quot;)   Another useful example of this can be seen with the use of extra parameters. Sometimes when writing Pydantic models you want to allow extra unspecified parameters when creating a model, and other times you want to explicitly forbid it (e.g. by using extra=forbid). Whether you‚Äôre using either approach or a mix of both in your code, Pyrefly can pick it up automatically from how you‚Äôve written your Pydantic model:  # Lax mode: We can pass extra fields to our model by default class ModelAllow(BaseModel): x: int ModelAllow(x=1, y=2) # pyrefly won't report an error here # Strict mode: we can forbid extra fields class ModelForbid(BaseModel, extra=&quot;forbid&quot;): x: int ModelForbid(x=1, y=2) # pyrefly will report an error here   Ultimately the value here is that you don‚Äôt have to manage external configuration files or plugins to get your type checker to work with Pydantic. This is a different approach compared to say Mypy - which requires you to install a separate Pydantic plugin and configure it via your mypy.ini or pyproject.toml file.  ","version":null,"tagName":"h3"},{"title":"Getting Started‚Äã","type":1,"pageTitle":"Fly through data validation with Pyrefly‚Äôs new Pydantic integration","url":"/blog/pyrefly-pydantic/#getting-started","content":" There are no special configurations or plugins required to start using Pyrefly with Pydantic! The steps are as simple as:  Install Pydantic (preferably v2).Install Pyrefly (v0.33.0 or later)Write Pydantic models as usual.Run Pyrefly / use it in your IDE  Simple as that! If you‚Äôd like to have a go playing around with a few examples, we created a demo repo that you can clone and try out.  ","version":null,"tagName":"h2"},{"title":"Conclusion‚Äã","type":1,"pageTitle":"Fly through data validation with Pyrefly‚Äôs new Pydantic integration","url":"/blog/pyrefly-pydantic/#conclusion","content":" Pyrefly‚Äôs Pydantic support is experimental and evolving, so you may encounter edge cases or features that aren‚Äôt fully covered yet. We‚Äôd like to strongly encourage you to try out Pydantic support in your projects and let us know what works, what doesn‚Äôt, and what you‚Äôd like to see improved! Your insights and suggestions are invaluable in helping us refine this feature and prioritize enhancements. You can open an issue in our GitHub repo or connect with us on discord if you have feedback to share.  Looking ahead, we‚Äôre also working on expanding Pyrefly‚Äôs capabilities to support additional third-party Python packages that are widely used in the ecosystem. We‚Äôre currently focused on adding support for Django and SQLAlchemy, but if there‚Äôs a particular library or framework you rely on, please let us know! Your suggestions and feedback will directly influence our roadmap and help make Pyrefly even better for the Python community. ","version":null,"tagName":"h2"},{"title":"Introducing Pyrefly - A new type checker and IDE experience for Python","type":0,"sectionRef":"#","url":"/blog/introducing-pyrefly/","content":"","keywords":"","version":null},{"title":"Get started‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#get-started","content":" Ready to dive in? The official Pyrefly website has all the details, but to quickly get started:  Install Pyrefly on the command-line: pip install pyrefly.Migrate your existing type checker configuration to Pyrefly.Enhance Your IDE: Download the Pyrefly extension for VSCode and enjoy a lightning fast IDE experience from starter projects to monorepos.Leave feedback for us on GitHub.  ","version":null,"tagName":"h2"},{"title":"Why we built Pyrefly‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#why-we-built-pyrefly","content":" Back in 2017, we embarked on a mission to create a type checker that could handle Instagram‚Äôs massive codebas of typed Python. This mission led to the birth of the Pyre type checker, inspired by the robust designs of Hack and Flow, and written in OCaml to deliver scalable performance.  Over the years, Pyre served us well, but as the type system evolved and the need for typechecking to drive responsive IDE emerged, it was clear that we needed to take a new approach. We explored alternate solutions and leveraged community tools like Pyright for code navigation. But the need for an extensible type checker that can bring code navigation, checking at scale, and exporting types to other services drove us to start over, creating Pyrefly.  ","version":null,"tagName":"h2"},{"title":"The principles behind Pyrefly‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#the-principles-behind-pyrefly","content":" Today, we‚Äôre excited to unveil Pyrefly, a project we‚Äôve been developing openly on GitHub. We invite you to explore our work and try it out on your own project. While a project like Pyrefly is the sum of thousands of technical choices, a few notable principles we‚Äôve followed are:  ","version":null,"tagName":"h2"},{"title":"Performance‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#performance","content":" We want to shift checks that used to happen later on CI to happening on every single keystroke. That requires checking code at speed (on large codebases we can check 1.8 million lines of code per second!) and careful thought to incrementality and updates. Pyrefly is implemented in Rust and designed for high performance on codebases of all sizes.  ","version":null,"tagName":"h3"},{"title":"IDE first‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#ide-first","content":" We want the IDE and command line to share a consistent view of the world, which means crafting abstractions that capture the differences without incurring unnecessary costs. Designing these abstractions from the beginning is much easier than retrofitting them, which we tried with Pyre.  ","version":null,"tagName":"h3"},{"title":"Inference‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#inference","content":" Some Python programs are typed, but many aren‚Äôt. We want users to benefit from types even if they haven‚Äôt annotated their code ‚Äì so automatically infer types for returns and local variables and display them in the IDE. What‚Äôs more, in the IDE you can even double click to insert these inferred types if you think that would make the program better.  ","version":null,"tagName":"h3"},{"title":"Open source‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#open-source","content":" Python is open source, and hugely popular. The Python typing specification is open source, which made Pyrefly vastly easier to develop. Many of the libraries Meta contributes to are open source,( e.g., PyTorch).  Pyrefly is also open source, available on GitHub under the MIT license, and we encourage pull requests and issue reports. We also have a Discord channel for more free flowing discussions. We would love to build a community around Pyrefly.  ","version":null,"tagName":"h3"},{"title":"The future of Pyrefly‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#the-future-of-pyrefly","content":" We will work with the Python community to drive the language forward and improve the developer experience. Since the beginning of Pyre, we open sourced our code and contributed a number of PEPs alongside the community of type checker maintainers. We feel we can do more with Pyrefly to help Python developers leverage the benefits of types for developers, library authors, and folks just learning the language.  Meta has leveraged types in dynamic languages from the beginning and knows the significant benefits it brings to developer productivity and security. We plan to share more of our learnings and tooling with blogs, better types in the ecosystem and language enhancements.  Today we‚Äôre releasing Pyrefly as an alpha. At the same time, we‚Äôre busy burning down the long-tail of bugs and features aiming to remove the alpha label this Summer. Your feedback is invaluable to get there, so please give it a try and report your bugs or things you think can be improved. Even if Pyrefly isn‚Äôt right for your project, we would love to hear how you use types and what you would like to see improved in your editor.  Join us on the journey as we help illuminate your bugs with Pyrefly. Happy coding! üêç‚ú®  ","version":null,"tagName":"h2"},{"title":"Hear more about Pyrefly‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#hear-more-about-pyrefly","content":" Check out the episode of the Meta Tech Podcast where several team members share their experience developing Pyrefly and technical details for how it works. We also just talked at PyCon US about high-performance Python through faster type checking and free threaded execution.  To learn more about Meta Open Source, visit ouropen source site, subscribe to our YouTube channel, or follow us on Facebook, Threads, X, and LinkedIn.  ","version":null,"tagName":"h2"},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#acknowledgements","content":" Pyrefly was created By Meta‚Äôs Python Language Tooling Team: Jia Chen, Rebecca Chen, Sam Goldman, David Luo, Kyle Into, Zeina Migeed, Neil Mitchell, Maggie Moss, Conner Nilsen, Aaron Pollack, Teddy Sudol, Steven Troxler, Lucian Wischik, Danny Yang, and Sam Zhou. ","version":null,"tagName":"h3"},{"title":"Bringing NumPy's type-completeness score to nearly 90%","type":0,"sectionRef":"#","url":"/blog/numpy-type-completeness/","content":"","keywords":"","version":null},{"title":"Wait, what's type completeness?‚Äã","type":1,"pageTitle":"Bringing NumPy's type-completeness score to nearly 90%","url":"/blog/numpy-type-completeness/#wait-whats-type-completeness","content":" Modern IDEs use type annotations to help developers by showing them helpful suggestions and highlighting syntax. Pyright is a popular type-checker which, as well as checking for correctness and consistency, can also measure what percentage of a library's public API has type annotations. We call the percentage of fully-typed symbols exported by a library the type-completeness score.  For example, a module which exports functions foo and bar:  def foo(a: int): return None def bar() -&gt; int: return 1   would have a 50% type-completeness score, because:  foo is partially unknown, as it's missing a return annotation.bar is type-complete.  By changing the foo signature to be def foo(a: int) -&gt; None:, the type-completeness score would jump to 100%. The more type-complete a library is, the more helpful the suggestions an IDE can show to the user.  Note that type-completeness only measures how much of the public API (at least, the part known to Pyright) is covered by types. If you want to verify that those types are correct and self-consistent, you'll also need to run a type checker. The most used type checkers currently are mypy and Pyright, but Pyrefly and ty are also attracting a lot of attention due to their impressive performance characteristics (note however that neither yet describes itself as production-ready, so temper your expectations accordingly if you try them out!).  ","version":null,"tagName":"h2"},{"title":"How type-complete is NumPy?‚Äã","type":1,"pageTitle":"Bringing NumPy's type-completeness score to nearly 90%","url":"/blog/numpy-type-completeness/#how-type-complete-is-numpy","content":" When we started this effort (in March 2025), we first tried measuring NumPy's type-completeness by running:  pyright --verifytypes numpy   The output showed a completeness score of...18%. Wait, only 18%? This seemed very low, because by then typing efforts in NumPy had been ongoing for some time. Was something up with the metric? Upon closer inspection of the output, we noticed a few things:  Some objects, such as DTypeLike, were reported to be &quot;partially unknown&quot;, even though they had type annotations.The type-completeness report included test modules such as numpy.tests.test_matlib.  The first issue was caused by an import from the standard library decimal module, which itself is partially untyped. Given that this is outside of NumPy's direct control, we decided to exclude it from the coverage report by using --ignoreexternal, as suggested by Eric Traut.  For the second issue, Pyright gives us an option to export the coverage report to json (--outputjson). We could then parse the json and exclude numpy.tests. Given that NumPy users wouldn't ordinarily interact with NumPy's internal test suite but that Pyright considers it public, we decided that it made sense for us to exclude tests in order to focus our efforts on what would make the biggest user-facing impact.  Once we'd addressed the two steps above, the baseline type-completeness score became 33%. This was our starting point. We could then focus our efforts on the remaining 67%!  ","version":null,"tagName":"h2"},{"title":"The one-line change which doubled type-completeness‚Äã","type":1,"pageTitle":"Bringing NumPy's type-completeness score to nearly 90%","url":"/blog/numpy-type-completeness/#the-one-line-change-which-doubled-type-completeness","content":" Pyright's report includes classes, methods, functions, type aliases, and more. A lot of scientific Python code centres around some central classes such as numpy.ndarray. ndarray was reported as &quot;partially unknown&quot;, but eye-balling the exported symbols related to that class revealed something interesting:  &gt;&gt;&gt; np.mean([x['isTypeKnown'] for x in exported if x['name'].startswith('numpy.ndarray.')]) np.float64(0.9811320754716981)   So, ndarray was reported as &quot;partially unknown&quot;, but 98% of its methods had known types. It shouldn't be much effort to bring that number to 100%! In fact, all it took was a one-line change to fix a typo in a type annotation:  - def setfield(self, /, val: ArrayLike, dtype: DTypeLike, offset: CanIndex = 0) -&gt; None: ... + def setfield(self, /, val: ArrayLike, dtype: DTypeLike, offset: SupportsIndex = 0) -&gt; None: ...   That's it! CanIndex was an unknown symbol and was probably mistyped, and replacing it with the correct SupportsIndex one brought NumPy's overall type-completeness to over 80%! We then started examining other NumPy classes to see if there was anywhere else where we could make an impact, and hopefully a much larger one.  ","version":null,"tagName":"h2"},{"title":"Enter MaskedArray‚Äã","type":1,"pageTitle":"Bringing NumPy's type-completeness score to nearly 90%","url":"/blog/numpy-type-completeness/#enter-maskedarray","content":" When we looked at the percentage of typed symbols from the MaskedArray class, we noticed something interesting:  &gt;&gt;&gt; np.mean([x['isTypeKnown'] for x in exported if x['name'].startswith('numpy.ma.core.MaskedArray.')]) np.float64(0.2)   Only 20% of them were typed! That's quite a contrast with ndarray, which was already at 98% when we started. It's also a fairly widely used class, appearing in the codebases of pandas, scikit-learn, and xarray. Given how poorly typed it was, we decided it would be a good candidate to spend time on!  ","version":null,"tagName":"h2"},{"title":"Typing MaskedArray‚Äã","type":1,"pageTitle":"Bringing NumPy's type-completeness score to nearly 90%","url":"/blog/numpy-type-completeness/#typing-maskedarray","content":" The main difficulty in typing NumPy code isn't inferring the possible argument values (which is quite easy to do with automated tools), but rather dealing with the large number of overloads. This is because many of NumPy methods' return types depend on the exact combinations of the input types. For example, suppose we have a MaskedArray ma and want to count the number of non-null values:  ma.count() returns an integer.ma.count(axis=0) returns an array.ma.count(keepdims=True) also returns an array, of the same shape as the input array.  We can type this by having a different overload of each of these different cases. This is a relatively simple example, but there are others where the number of necessary overloads was as high as 9! This isn't something which is easy to automate, and requires careful reading of the documentation and of the source code. It's a non-trivial amount of work.  But...we pulled through it, and thanks to some very timely and constructive reviews from the amazing Joren Hammudoglu, MaskedArray is now reported as 100% type-complete! As for the overall type-completeness, that's now at 88%. So...what's left?  ","version":null,"tagName":"h2"},{"title":"What's missing from NumPy?‚Äã","type":1,"pageTitle":"Bringing NumPy's type-completeness score to nearly 90%","url":"/blog/numpy-type-completeness/#whats-missing-from-numpy","content":" In the MaskedArray module, there's still some untyped top-level functions, such as numpy.ma.count. Overloads could be made more precise and shape-preserving (e.g. if the input is 2D, then make sure to preserve this fact in the output where possible). There's some missing defaults in the stubs. There's no shortage of work here.  The biggest missing bit, however, is the elephant in the room: NumPy doesn't run a type-checker over its codebase in CI. It has some typing tests, sure, but that's different from running a type-checker. If any motivated reader is interested in making a significant open source contribution, then getting NumPy's typing into a state such that a type checker (and possibly even stubtest) can be run over it could be a great use of your time.  ","version":null,"tagName":"h2"},{"title":"Conclusion, acknowledgements‚Äã","type":1,"pageTitle":"Bringing NumPy's type-completeness score to nearly 90%","url":"/blog/numpy-type-completeness/#conclusion-acknowledgements","content":" We've looked at how we contributed towards increasing NumPy's type-completeness. Given how widespread NumPy's adoption is, we expect this effort to have been an impactful one. We look forward to seeing what else we can achieve in this space - thank you to Meta and Quansight Labs for having funded and facilitated this effort! ","version":null,"tagName":"h2"},{"title":"Pyrefly Beta is here!","type":0,"sectionRef":"#","url":"/blog/pyrefly-beta/","content":"","keywords":"","version":null},{"title":"üöÄ The IDE Experience: Battle-Tested at Meta Scale‚Äã","type":1,"pageTitle":"Pyrefly Beta is here!","url":"/blog/pyrefly-beta/#-the-ide-experience-battle-tested-at-meta-scale","content":" A major priority for Pyrefly development since the beginning has been to deliver a lightning-fast and scalable IDE experience. Pyrefly was born out of a real-world production problem: Meta's Instagram developers were struggling with painfully slow code navigation, autocomplete, and type checking on their massive codebase.  Over the past year we‚Äôve been rapidly adding new features and addressing bugs found by our passionate community of alpha testers (both internal and external). We're now proud to say Pyrefly is the default language server and type checker for all developers working on Instagram at Meta. By testing Pyrefly‚Äôs IDE extension on a codebase the size of Instagram we‚Äôve been able to deliver hotly requested features with confidence that they will be reliable for large production codebases.  A few examples of Pyrefly‚Äôs latest language server features include:  Automatic import refactoring‚Äã  Pyrefly will now automatically update your imports when you rename or move a file.    Jupyter Notebook support‚Äã  You can now use Pyrefly with Jupyter notebooks for diagnostics (red squiggles), inlay hints, go-to-definition, hover, semantic tokens, signature help, and completions.    Third-party stubs shipped with the extension‚Äã  Language server features like hover and autocomplete are now available for third party libraries with Typeshed stubs. This support is available by default, without the need for a config file (pyproject.toml / pyrefly.toml), to provide a better out-of-the-box experience.    For a full list of supported IDE features check out the Pyrefly IDE documentation.    ","version":null,"tagName":"h2"},{"title":"Better Type checking? Check ‚úÖ‚Äã","type":1,"pageTitle":"Pyrefly Beta is here!","url":"/blog/pyrefly-beta/#better-type-checking-check-","content":" We've also made steady progress in improving Pyrefly's core type-checking engine since the Alpha release. Our focus has been on achieving higher conformance with the Python Typing Specification while also reducing false positives and improving support for modern Python patterns and popular libraries. In this section we'll highlight a few examples of the key fixes, new features, and design decisions that have paved the way for a more reliable type-checking experience in this Beta release.  Type Inference‚Äã  We understand writing type annotations can be tedious, so from the start Pyrefly has had some capabilities for automatically inferring types for returns and local variables and displaying them in the IDE. Since the first alpha release we‚Äôve been steadily expanding inference capabilities, for example by improving our ability to infer the types of empty containers on first use:  from typing import reveal_type def f[T](x: T | None) -&gt; list[T]: return [x] if x else [] x = f(None) x.append(1) # Pyrefly is now able to infer that `x` has type `list[int]`. reveal_type(x)   Type Narrowing‚Äã  We‚Äôve added several new ways to narrow types and reworked type narrowing logic to prevent unwanted &quot;pollution&quot; of types after checks like isinstance:  from typing import Any, reveal_type def f(x: Any): if isinstance(x, int): print(x) # Reworked type narrowing means the revealed type is now correctly `Any`, # not `int | Any` as it was previously. reveal_type(x)   ","version":null,"tagName":"h2"},{"title":"Preliminary Support for Pydantic and Django‚Äã","type":1,"pageTitle":"Pyrefly Beta is here!","url":"/blog/pyrefly-beta/#preliminary-support-for-pydantic-and-django","content":" We‚Äôve added preliminary support for two of the most popular Python web/data libraries: Pydantic and Django. Pyrefly can now recognize key objects from these libraries and perform static analysis to catch potential errors before you ever run your code. This support works out-of-the-box with no configuration or plugins required, and includes IDE support.  Django Support‚Äã  As shown in this example, by default, Django automatically adds an id field to serve as the primary key (unless you define a custom primary key). Pyrefly is able to infer that the id exists and is of type int  from django.db import models class Reporter(models.Model): full_name = models.CharField(max_length=70) # Django auto-adds: id = models.AutoField(primary_key=True) reporter = Reporter() reveal_type(reporter.id) # Pyrefly infers: int   See more examples in the Pyrefly Django docs.  Pydantic Support‚Äã  In this example Pyrefly can read your Pydantic model‚Äôs configuration directly from your code to determine there is a type error where age should be an int not a string:  from pydantic import BaseModel, Field class User(BaseModel): name: str age: int = Field(strict=True) # strict mode # Pyrefly will report an error here. y = User(name=&quot;Alice&quot;, age=&quot;30&quot;)   See more examples in the Pyrefly Pydantic docs  Dataclass Transforms Support‚Äã  An important addition that laid the foundation for supporting libraries like attrs and Pydantic, was allowing Pyrefly to recognize custom dataclass-like class transformations:  from attrs import define # third-party `attrs` package @define class C: x: int # `attrs` uses a dataclass transform, and Pyrefly now recognizes the # auto-generated constructor based on the class attributes. C(x=0)     ","version":null,"tagName":"h3"},{"title":"üôå An improved user experience‚Äã","type":1,"pageTitle":"Pyrefly Beta is here!","url":"/blog/pyrefly-beta/#-an-improved-user-experience","content":" We understand writing type annotations, dealing with strict checks, and configuring tools can be a barrier to adopting typed Python for many people, so we are always looking for ways to make using Pyrefly as painless as possible, dare we say even delightful? This section highlights some of the incremental improvements we've been working on to improve the overall user experience:  Type Error Message Improvements‚Äã  We‚Äôve also cleaned up our error messages, making them clearer and providing embedded code snippets to pinpoint the exact location of the issue:  Before:  foo.py:1:5-15: `+` is not supported between `Literal[1]` and `Literal['oops']`   After (with snippet and detailed explanation):  ERROR `+` is not supported between `Literal[1]` and `Literal['oops']` [unsupported-operation] --&gt; foo.py:1:5 | 1 | x = 1 + &quot;oops&quot; | ^^^^^^^^^^ | Argument `Literal['oops']` is not assignable to parameter `value` with type `int` in function `int.__add__`   Smoother migration from MyPy or Pyright‚Äã  Different typecheckers display different behaviour, which can make it a challenge to switch from one to another. While it's not always possible to cleanly translate one config option to another, the pyrefly init command now does a better job of searching for an existing MyPy or Pyright configuration and transforming it into a pyrefly.toml (or [tool.pyrefly] section). You can find more details in the migration guides section of the Pyrefly docs.  A more configurable IDE experience‚Äã  Do you want type error diagnostics (i.e. the red squiggles) in your IDE or not? Do you want to use Pyrefly‚Äôs type errors but not other LSP features? Do you want to pick and choose specific language server features to enable? We know that how you set up your code editor is a personal choice, so we‚Äôve added more configuration options to enable you to ‚Äúchoose your own adventure‚Äù with your Pyrefly IDE experience.    ","version":null,"tagName":"h2"},{"title":"üî¨ Enhancing Performance, Squashing Bugs and Aligning with the Spec‚Äã","type":1,"pageTitle":"Pyrefly Beta is here!","url":"/blog/pyrefly-beta/#-enhancing-performance-squashing-bugs-and-aligning-with-the-spec","content":" We started developing Pyrefly with a clear goal in mind: make a tool that can statically analyze your code, catch type-related bugs, and do it much faster than existing tools like Mypy. While performance was good even in the early releases of Pyrefly, on the journey to Beta we‚Äôve been focused on improvements for increasingly complex codebases, reducing type checking time and addressing edge cases for projects of varying size with many dependencies.  In some cases we‚Äôve been able to reduce the time it takes to type check large projects with virtual envs, node-modules and other large dependencies by over 95% compared to earlier alpha versions of pyrefly. We've also closed over 350 bug issues opened by users and have been using the Python typing conformance test suite to benchmark our progress towards fully implementing the typing specification. So far we‚Äôve gone from 39% conformant at alpha launch to over 70% conformant today.    There‚Äôs a lot more that‚Äôs been happening than we can possibly be squeezed into one blog post, so if you‚Äôd like to take a look back in more detail you can check out the completed beta milestone or our previous release notes.    ","version":null,"tagName":"h2"},{"title":"What‚Äôs Next?‚Äã","type":1,"pageTitle":"Pyrefly Beta is here!","url":"/blog/pyrefly-beta/#whats-next","content":" This Beta release marks a significant milestone, but the journey isn't over! We‚Äôre now focusing on the further work that is needed to bring you a stable v1.0 release next year, including:  Adding further support for popular third-party libraries (especially Django and Pydantic integration).Implementing the remaining missing features from the Python type system to reach 100% conformance.Making Pyrefly work even faster and consume even less memoryFixing more bugs!  We‚Äôd also like to say a huge thank-you to everyone who has helped get Pyrefly to this release. Whether you‚Äôve contributed to the codebase, opened GitHub issues or just commented with your questions and feedback, your contributions have helped shape the direction of this project thus far. If you want to stay in the loop and continue being part of the conversation as we work towards Pyrefly v1.0 you can check out the GitHub repo or join our Discord community. ","version":null,"tagName":"h2"},{"title":"Third Party Stubs bundled with Pyrefly","type":0,"sectionRef":"#","url":"/blog/stubs/","content":"","keywords":"","version":null},{"title":"What are Python stubs?‚Äã","type":1,"pageTitle":"Third Party Stubs bundled with Pyrefly","url":"/blog/stubs/#what-are-python-stubs","content":" Stubs are Python files that provide type information about Python code. They can be found in files with the extension .pyi and define the signature of any functions, classes, etc, that are defined in the associated source file. Stubs can be very helpful for third party libraries or parts of the Python standard library that were not originally typed and allow us to use that type information to write safer code.  ","version":null,"tagName":"h2"},{"title":"Why is stub information important?‚Äã","type":1,"pageTitle":"Third Party Stubs bundled with Pyrefly","url":"/blog/stubs/#why-is-stub-information-important","content":" Being able to access this type information through stubs is very important during type checking. This is because it allows the type checker to verify that functions are being called with the correct argument types and that return values are being used appropriately, catching potential bugs before runtime. The inclusion of stubs also brings a lot of value to the IDE experience. The inclusion of these stubs greatly enhances certain code navigation functionality in the IDE when using these packages, as highlighted in the following examples  Pyrefly will now provide autocomplete suggestions for types in third party libraries.    Pyrefly will now also provide inlay hints for third party libraries with included stubs.  Hovering on types from packages with stubs will also now show the associated type rather than 'Unknown'.  before:    after:  ","version":null,"tagName":"h2"},{"title":"How do I ensure this is part of my IDE experience?‚Äã","type":1,"pageTitle":"Third Party Stubs bundled with Pyrefly","url":"/blog/stubs/#how-do-i-ensure-this-is-part-of-my-ide-experience","content":" If you are just using Pyrefly out of the box with no custom configuration then no action is needed! Just ensure that you are on the latest version of Pyrefly. These stubs will be bundled along with the Pyrefly installation and become active in your IDE experience.  If you are using Pyrefly with a configuration through pyrefly.toml or pyproject.toml file, we will instead prompt you to install stubs for the specified package. Due to potential version mismatches between installed packages and bundled stubs, we prefer to use stubs directly installed by the user.  ","version":null,"tagName":"h2"},{"title":"What Stubs are included?‚Äã","type":1,"pageTitle":"Third Party Stubs bundled with Pyrefly","url":"/blog/stubs/#what-stubs-are-included","content":" Currently all stubs found in the Typeshed repository are included.  The following stubs are also included starting with Pyrefly version 0.46  Boto3BotocoreConansMatplotlibPandasScikit-imageScikit-learnSympyVispy  ","version":null,"tagName":"h2"},{"title":"Further Work‚Äã","type":1,"pageTitle":"Third Party Stubs bundled with Pyrefly","url":"/blog/stubs/#further-work","content":" We have intentionally built out this support in such a way in order to very easily enable adding more stubs in the future. We invite you to share your feedback in discord, or by opening a GitHub issue. We‚Äôd love to know how these enhancements are improving your workflow or any issues you come across. Your input will help us shape future releases and ensure Pyrefly remains a robust tool for the Python community. ","version":null,"tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/en/docs/","content":"","keywords":"","version":"Next"},{"title":"Benefits of Type Checking‚Äã","type":1,"pageTitle":"Introduction","url":"/en/docs/#benefits-of-type-checking","content":" Adding type annotations to your Python code and using a type checker like Pyrefly provides several important benefits:  Catch bugs early - Identify type-related errors during development rather than at runtimeImprove code quality - Type annotations serve as living documentation, making your code more readable and self-documentingEnhance developer experience - Get better IDE support with accurate autocomplete, refactoring tools, and inline documentationSafer refactoring - Make large-scale changes with confidence, knowing the type checker will catch incompatible type usageBetter collaboration - Types create clear contracts between different parts of your codebase, making it easier for teams to work together  ","version":"Next","tagName":"h2"},{"title":"Try Pyrefly‚Äã","type":1,"pageTitle":"Introduction","url":"/en/docs/#try-pyrefly","content":" Here's a simple example showing how Pyrefly can catch type errors:  # Example: Basic Type Checking def greet(name: str) -&gt; str: return &quot;Hello, &quot; + name # This works fine since both &quot;World&quot; is a string and greet expects a string message = greet(&quot;World&quot;) # Pyrefly catches this error before runtime due to a type misatch between 42 and &quot;str&quot; # Error: Argument of type 'int' is not assignable to parameter of type 'str' error_message = greet(42)  In this example, Pyrefly flags the second call to greet() because we're passing an integer (42) where a string is expected, helping you catch this issue before your code runs. To learn more about Python typing and how to use it effectively:  If you're new to Python, check out our Python Typing for Beginners guide.If you're familiar with Python but new to typing, see our Typing for Python Developers guide. ","version":"Next","tagName":"h2"},{"title":"Pyrefly Infer","type":0,"sectionRef":"#","url":"/en/docs/autotype/","content":"","keywords":"","version":"Next"},{"title":"Usage‚Äã","type":1,"pageTitle":"Pyrefly Infer","url":"/en/docs/autotype/#usage","content":" To use the infer feature, run the following command in your project directory:  pyrefly infer path/to/file.py # or pyrefly infer path/to/directory/   We recommend running it in small batches to make reviewing and merging changes easier. Flags can be used to turn on / off adding annotations for parameters, return types, and containers.  It is common that new annotations will expose new type errors. See our error suppression guides to learn how to automate silencing these errors. ","version":"Next","tagName":"h2"},{"title":"4 Pyrefly Type Narrowing Patterns that make Type Checking more Intuitive","type":0,"sectionRef":"#","url":"/blog/type-narrowing/","content":"","keywords":"","version":null},{"title":"hasattr and getattr‚Äã","type":1,"pageTitle":"4 Pyrefly Type Narrowing Patterns that make Type Checking more Intuitive","url":"/blog/type-narrowing/#hasattr-and-getattr","content":" In a dynamic codebase where not every field is initialized in the constructor, you may encounter code that dynamically adds attributes to classes without declaring them in the class body.  Even if a field is not declared on the class, Pyrefly can understand a hasattr check indicates that the field exists.  def func(x: object) -&gt; None: if hasattr(x, &quot;value&quot;): val = x.value # Pyrefly knows that `x` has the `value` attribute and won‚Äôt error here   Some fields are declared on the class but not always initialized, so accesses have to be done with getattr. To support this pattern, any checks on getattr(x, ‚Äúfield‚Äù) will generally narrow the type the same way as the same check on x.field. This means that using getattr() in a guard will narrow the field to be truthy.  from typing import Literal, assert_type class C: flag: bool # the flag is not always set` def func(x: C) -&gt; None: if getattr(x, &quot;flag&quot;): # here Pyrefly knows that the flag is set to True assert_type(x.flag, Literal[True])   ","version":null,"tagName":"h2"},{"title":"Tagged Unions‚Äã","type":1,"pageTitle":"4 Pyrefly Type Narrowing Patterns that make Type Checking more Intuitive","url":"/blog/type-narrowing/#tagged-unions","content":" Tagged unions are a common feature in functional programming languages, but they are not a first-class language construct in Python. Although Python‚Äôs union types are untagged, Pyrefly can emulate a tagged union by creating a union where each member explicitly defines the same field to use as a tag. Pyrefly can then check the value of the field to narrow the union to the corresponding member.  This works for regular classes, as well as typed dicts.  from typing import TypedDict, Literal class Ok(TypedDict): result: Literal[&quot;ok&quot;] payload: bytes class Err(TypedDict): result: Literal[&quot;error&quot;] message: str type Response = Ok | Err def read(res: Response) -&gt; bytes: if res[&quot;result&quot;] == &quot;ok&quot;: return res[&quot;payload&quot;] else: raise Exception(res[&quot;message&quot;])   ","version":null,"tagName":"h2"},{"title":"Tuple length narrowing‚Äã","type":1,"pageTitle":"4 Pyrefly Type Narrowing Patterns that make Type Checking more Intuitive","url":"/blog/type-narrowing/#tuple-length-narrowing","content":" When you check the length of something against a literal integer, Pyrefly will narrow away any tuple types that definitely do not match that length:  from typing import assert_type type XY = tuple[float, float] # 2D point type RGB = tuple[int, int, int] # color type Vec = XY | RGB def describe(v: Vec) -&gt; None: if len(v) == 2: x, y = v # Pyrefly knows v only has 2 elements, so it cannot be RGB else: r, g, b = v # Pyrefly knows v has 3 elements, so it cannot be XY   ","version":null,"tagName":"h2"},{"title":"Conditions saved in variables‚Äã","type":1,"pageTitle":"4 Pyrefly Type Narrowing Patterns that make Type Checking more Intuitive","url":"/blog/type-narrowing/#conditions-saved-in-variables","content":" If you want to check some condition multiple times, you may want to save it to a local variable to avoid repeating yourself. Pyrefly understands this pattern, while also being smart enough to figure out when it should invalidate a saved condition:  def f(x: int | str, y: int, z: int | str): x_is_int = isinstance(x, int) if x_is_int: y += x # here Pyrefly knows x is an int and won't throw an error if x_is_int: y += x # x has not changed, so pyrefly still knows that x is an int x = z if x_is_int: y += x # this is now unsafe, the x_is_int condition is invalidated so pyrefly will throw an error here   ","version":null,"tagName":"h2"},{"title":"Conclusion‚Äã","type":1,"pageTitle":"4 Pyrefly Type Narrowing Patterns that make Type Checking more Intuitive","url":"/blog/type-narrowing/#conclusion","content":" These are just a few of the ways Pyrefly automatically narrows types, reducing the need for explicit casts in your programs. Not all of these features are unique to Pyrefly, but no other type checker as of writing supports the full set of narrowing patterns listed here. Given the lack of standardization of this feature, there‚Äôs a lot of room for innovation in the space. We‚Äôre currently working on expanding the narrowing patterns we support - so stay tuned for more updates!  Do you have a pattern for narrowing types that you wish type checkers could understand, or that you want us to support in Pyrefly? Please file an issue on our Github! ","version":null,"tagName":"h2"},{"title":"Why Today‚Äôs Python Developers Are Embracing Type Hints","type":0,"sectionRef":"#","url":"/blog/why-typed-python/","content":"","keywords":"","version":null},{"title":"What is Typed Python?‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#what-is-typed-python","content":" Before we dive into why you should be using typed Python in your daily development lives, first we need to understand some core concepts and how we got here.  ","version":null,"tagName":"h2"},{"title":"Dynamic vs static typing‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#dynamic-vs-static-typing","content":" The classic Python programming language that you know and love is dynamically typed. What does that mean exactly? It means that types are determined at runtime, not when you write your code. Variables can hold any type of value, and you don't need to declare what type they are.  Here‚Äôs an example of dynamic typing in action:  x = 5 # x is an integer x = &quot;hello&quot; # now x is a string x = [1,2,3] # now x is a list   This behaviour is one of the things that sets Python apart from languages that are statically typed, like Java or C++, which require you to declare types from the get go:  int x = 5; std::string x_str = &quot;hello&quot;; std::vector&lt;int&gt; x_vec = {1, 2, 3};   In the above example we can‚Äôt just reassign the variable x to a value of whatever type we want, it can only hold an integer because of the static typing nature of the C++ language.  The fact that Python is a dynamically typed language is one of the reasons it is so easy to use and popular amongst new and experienced programmers alike. It makes it easy to develop quick demos, experimental research and proof of concepts, without needing to spend precious development time declaring types. This flexibility has been instrumental in Python's adoption in AI, data science, and scientific computing, where researchers need to rapidly iterate and experiment with different approaches.  However‚Ä¶ (surely you knew there was a ‚Äúbut‚Äù coming?)  We are quickly moving past the ‚Äúproof-of-concept‚Äù phase for many of these industries. AI and machine learning efforts are actively being integrated into production applications, and with that comes production-level expectations of reliability and stability. Relying on dynamic typing opens these codebases up to a certain level of risk that may not be acceptable at the scale they are now expected to operate.  ","version":null,"tagName":"h3"},{"title":"Enter PEP 484: Static Typing Comes to Python‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#enter-pep-484-static-typing-comes-to-python","content":" Cast your mind back to September 2014: Germany has just won the world cup, skinny jeans are still in fashion and Taylor Swift‚Äôs ‚ÄúShake it Off‚Äù is number 1 on the charts. That same month PEP 484 was first created, proposing the addition of type hints to Python, and fundamentally changing how future developers would be able to write and maintain Python code.  With PEP 484‚Äôs acceptance and introduction in Python 3.5, developers could now use static type annotations to declare the expected data types of function arguments and return values, and subsequent PEPs have continually added more features to expand and refine Python's type system. Today you can write statically typed Python statements like this:  def my_func(x: int, y: str) -&gt; bool: z: str = str(x) return z == y   The key innovation of PEP 484 was introducing a gradual type system that allows developers to slowly add type annotations over time without breaking existing code. The system works by:  Only type-checking functions that have explicit return or parameter annotationsIntroducing the Any type as an escape hatch that has all possible attributesAssuming untyped functions implicitly return Any  This approach has meant developers can incrementally adopt typing, while still allowing them to take advantage of the default dynamic typing approach that makes Python so easy to work with and ideal for quick prototyping.  ","version":null,"tagName":"h3"},{"title":"Benefits of Python Type Hints: Write Better Code, Faster‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#benefits-of-python-type-hints-write-better-code-faster","content":" So why specifically should you start using type hints in your Python code? Python type hints offer a range of advantages that can significantly improve the quality, maintainability, and scalability of your codebase, at the same time making it easier for other developers to understand your code and collaborate with you.  ","version":null,"tagName":"h2"},{"title":"Types help you catch bugs early‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#types-help-you-catch-bugs-early","content":" Type hints assist static analysis tools in identifying mismatches and potential errors before the code is executed, allowing for early bug detection. Take the following example:  def add_numbers(a, b): return a + b ... add_numbers(3, &quot;4&quot;) # Potential error   The above error might be easy to spot when you‚Äôre calling the function so close to where you‚Äôre defining it, but imagine you‚Äôre working across multiple files and/or with many lines of code separating them - suddenly it‚Äôs not so easy!  In comparison, if you‚Äôre using type hints in conjunction with a typechecking tool (such as Pyrefly or MyPy), you can catch this error much earlier - when you‚Äôre actually writing the code, rather than when it fails at runtime:  def add_numbers(a: int, b: int) -&gt; int: return a + b ... add_numbers(3, &quot;4&quot;) # a typechecker will catch this error at time of writing   Using a typechecker to highlight these types of errors also ensures you can catch an error like this even if you‚Äôve missed this code path in your unit tests.  ","version":null,"tagName":"h3"},{"title":"Typed code is self-documenting‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#typed-code-is-self-documenting","content":" Another benefit of writing typed Python is that using function signatures and variable annotations provide clarity of intent for a given piece of code. In other words, it makes code easier to read and review. It makes refactoring safer and more predictable. It even helps new team members get up to speed quickly on what‚Äôs going on in your codebase without wasting their own time, or yours!  Take the following example, without type hints you have to carefully read the internal function code to understand what type of parameters will work and what will be returned:  def calculate_stats(data, weights): total = 0 weighted_sum = 0 for i, value in enumerate(data): if i &lt; len(weights): weighted_sum += value * weights[i] total += weights[i] avg = weighted_sum / total if total &gt; 0 else 0 return avg, len(data)   With this version, you can tell instantly what type of arguments you should be passing and what you should expect to get back - saving precious dev time and just generally making your life easier:  def calculate_stats(data: list[float], weights: list[float]) -&gt; tuple[float, int]: total = 0 weighted_sum = 0 for i, value in enumerate(data): if i &lt; len(weights): weighted_sum += value * weights[i] total += weights[i] avg = weighted_sum / total if total &gt; 0 else 0 return avg, len(data)   I know I know - ideally all developers should be adding clear docstrings with every function they write, but we know in reality it doesn‚Äôt always shape up that way! Adding type hints is quicker than writing a typical docstring, won‚Äôt go stale (if enforced using a typechecker) and is better than no documentation at all. Modern Python typecheckers also have IDE extensions that include autocomplete functionality to make life easier.  ","version":null,"tagName":"h3"},{"title":"Typed Python helps you scale from proof-of-concept to production-ready‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#typed-python-helps-you-scale-from-proof-of-concept-to-production-ready","content":" One of the most important benefits of using type annotations in your code is that it helps you scale your code faster and with less risk. For developers today, the pipeline from experimental code to production systems moves faster than ever, especially in AI and machine learning workflows where research prototypes must quickly evolve into robust, scalable applications.  For example, say there is a team of data scientists that has just published their findings and now needs to operationalize their models. If their published code already includes type hints it makes it much easier, quicker and safer for an engineering team to step in and integrate that research into production applications. In situations like these, type annotations act as a contract between different stages of development, making it clear how data flows through complex, multi-step processing pipelines. This is particularly valuable in AI workflows where a single type mismatch, like passing a NumPy array where a PyTorch tensor is expected, can cause silent failures or performance degradation that only surfaces under production load.  ","version":null,"tagName":"h3"},{"title":"Get Started with Typed Python today!‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#get-started-with-typed-python-today","content":" So now you know what typed python is and why you should be doing it, how can you actually get started adding types to your code?  ","version":null,"tagName":"h2"},{"title":"Step 0 - start early!‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#step-0---start-early","content":" As a general rule of thumb, the earlier in a project you start adding type annotations the better. Type hints are much easier to add as you go than to retrofit across an entire codebase later.  As we‚Äôve mentioned before, one of the great benefits of Python is that its dynamic typing default makes it very flexible and easy to get started with. So when you‚Äôre doing your initial experimentation and prototyping maybe you‚Äôre not thinking about making sure it‚Äôs type safe - and that‚Äôs ok! But as soon as you start to think your project might be going somewhere, if more than one person might be working on it, using it or just reading it, you should start adding type hints.  ","version":null,"tagName":"h3"},{"title":"Step 1 - install a type checker‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#step-1---install-a-type-checker","content":" Choose and install a type checker that fits your needs. Typecheckers leverage the code annotations you write to provide important errors and warnings to ensure your codebase is type safe.  At Meta, we recommend Pyrefly, our new open-source type checker built in Rust. Pyrefly is designed to scale from small projects to massive codebases incredibly fast, while providing excellent developer experience. Read the Pyrefly documentation to understand configuration options and best practices, then start adding simple type hints to new functions before gradually working your way up to more complex scenarios.  You should also consider working with a typechecker that supports IDE integration to get real-time feedback as you write code. Pyrefly provides extensions for editors like VS Code, PyCharm, and Vim which will highlight errors and provide autocomplete suggestions based on your type annotations.  Adding your typechecker to your CI processes is also valuable for maintaining code quality at scale. You can configure your CI/CD pipeline to run type checking on every pull request, treating type errors as build failures.  ","version":null,"tagName":"h3"},{"title":"Step 2 - make use of resources to get better at typing‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#step-2---make-use-of-resources-to-get-better-at-typing","content":" Typing is one of those skills that gets better the more you practice it in your code, but there are also great resources out there for getting to grips with the functionality and diving deeper into the concepts:  Official Python typing documentation - The typing module docs provide comprehensive coverage of all available typesPEP 484 and related PEPs - Understanding the foundational specifications helps you grasp the &quot;why&quot; behind typing decisionsDocumentation for your chosen typechecker, e.g. Pyrefly Docs on learning typingJoin community forums and get support, e.g. Pyrefly Discord, Typing Discourse  ","version":null,"tagName":"h3"},{"title":"Conclusion‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#conclusion","content":" So there you have it - a quick trip around the world of Python typing! By now you‚Äôve hopefully learnt that type hints aren't just another Python feature to add to the long list of things you‚Äôll definitely get round to implementing eventually - they're a practical investment in your code's future. The upfront effort of adding type hints pays dividends in reduced debugging sessions, smoother code reviews, and fewer production issues. Most importantly, they give you the confidence to refactor and scale your codebase without fear of breaking things in unexpected ways. Start small by adding type annotations to your next function, add a type checker to your workflow, and before you know it writing typed Python will be second nature. Your future self (and your users and teammates!) will thank you. ","version":null,"tagName":"h2"},{"title":"Experimental Django Support","type":0,"sectionRef":"#","url":"/en/docs/django/","content":"","keywords":"","version":"Next"},{"title":"Feedback‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#feedback","content":" We welcome your feedback and suggestions. Please share your thoughts and ideas by opening an issue on GitHub.    ","version":"Next","tagName":"h3"},{"title":"What is Django?‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#what-is-django","content":" Django is a high-level Python web framework. One of its core components is the Object-Relational Mapping (ORM) system, which allows developers to interact with databases using Python classes (models) instead of writing SQL queries directly.  Django models define the structure of your database tables, and Django automatically handles the creation and management of the underlying database schema.    ","version":"Next","tagName":"h2"},{"title":"Getting Started with Django and Pyrefly‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#getting-started-with-django-and-pyrefly","content":" To use Pyrefly with Django, follow these steps:  ","version":"Next","tagName":"h2"},{"title":"1. Install django-stubs and set up a virtual environment‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#1-install-django-stubs-and-set-up-a-virtual-environment","content":" # Install django-stubs pip install django-stubs # Create and activate a virtual environment python3 -m venv .venv source .venv/bin/activate   ","version":"Next","tagName":"h3"},{"title":"2. Install pyrefly (version 0.42.0 or later)‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#2-install-pyrefly-version-0420-or-later","content":" pip install pyrefly   That's it! Pyrefly will automatically recognize Django constructs and provide appropriate type checking.    ","version":"Next","tagName":"h3"},{"title":"How Pyrefly Supports Django‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#how-pyrefly-supports-django","content":" Pyrefly provides type inference for Django's ORM without requiring any plugins or manual configuration. It:  Recognizes Django model classes that inherit from models.ModelUnderstands Django field types (CharField, IntegerField, ForeignKey, etc.)Infers types for auto-generated fields (like id and pk)Handles relationships between models (ForeignKey, ManyToManyField)Provides special enum supportProvides immediate feedback when the code has type errorsDoes not require a plugin or manual config ‚Äî support is built-in and automatic    ","version":"Next","tagName":"h2"},{"title":"Supported Features with Examples‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#supported-features-with-examples","content":" The following examples showcase which Django features are currently supported by Pyrefly. This is a subset of Django's full feature set, but covers the most common use cases.  ","version":"Next","tagName":"h2"},{"title":"Auto-Generated Fields‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#auto-generated-fields","content":" Django automatically adds certain fields to every model, even if you don't define them explicitly.  Primary Key: id Field‚Äã  By default, Django automatically adds an id field to serve as the primary key (unless you define a custom primary key):  from django.db import models class Reporter(models.Model): full_name = models.CharField(max_length=70) # Django auto-adds: id = models.AutoField(primary_key=True) reporter = Reporter() reveal_type(reporter.id) # Pyrefly infers: int   Custom Primary Keys‚Äã  If you define a field with primary_key=True, Django will not add the id field. Pyrefly correctly infers the type of custom primary keys:  from django.db import models class Reporter(models.Model): uuid = models.UUIDField(primary_key=True) full_name = models.CharField(max_length=70) reporter = Reporter() reveal_type(reporter.uuid) # Pyrefly infers: UUID reveal_type(reporter.pk) # Pyrefly infers: UUID (pk aliases the custom primary key)   ForeignKey _id Suffix Fields‚Äã  For every ForeignKey field named X, Django automatically creates a field named X_id that stores the ID of the related object:  class Article(models.Model): reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE) # Django auto-adds: reporter_id: int article = Article() reveal_type(article.reporter_id) # Pyrefly infers: int   ","version":"Next","tagName":"h3"},{"title":"ForeignKey Relationships‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#foreignkey-relationships","content":" A ForeignKey creates a many-to-one relationship where each instance of one model relates to an instance of another model.  from django.db import models class Reporter(models.Model): full_name = models.CharField(max_length=70) class Article(models.Model): reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE)   Basic Forward Access‚Äã  Accessing a ForeignKey field returns an instance of the related model:  article = Article() reveal_type(article.reporter) # Pyrefly infers: Reporter   Chained Access‚Äã  You can access fields on the related model:  reveal_type(article.reporter.full_name) # Pyrefly infers: str   Nullable ForeignKeys‚Äã  If a ForeignKey has null=True, Pyrefly reflects this in the inferred type:  class Article(models.Model): reporter = models.ForeignKey(Reporter, null=True, on_delete=models.CASCADE) article = Article() reveal_type(article.reporter) # Pyrefly infers: Reporter | None   ","version":"Next","tagName":"h3"},{"title":"ManyToManyField Relationships‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#manytomanyfield-relationships","content":" A ManyToManyField creates a many-to-many relationship where instances of one model can be related to multiple instances of another model.  class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): title = models.CharField(max_length=200) authors = models.ManyToManyField(Author, related_name='books')   Forward Managers‚Äã  Accessing a ManyToManyField returns a manager object that provides methods to interact with the related objects:  book = Book() reveal_type(book.authors) # Pyrefly infers: ManyRelatedManager[Author, Model] reveal_type(book.authors.all()) # Pyrefly infers: QuerySet[Author, Author]   The manager provides methods like .add(), .remove(), .clear(), and .all() to manage the relationship.    ","version":"Next","tagName":"h3"},{"title":"Django Model Enums‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#django-model-enums","content":" Pyrefly supports Django's model choices using Choices, IntegerChoices, and TextChoices. These provide type-safe enumerations for model fields.  from django.db import models class Vehicle(models.IntegerChoices): CAR = 1, &quot;Car&quot; TRUCK = 2, &quot;Truck&quot; MOTORCYCLE = 3, &quot;Motorcycle&quot; class Product(models.Model): vehicle_type = models.IntegerField(choices=Vehicle.choices) # Pyrefly correctly infers enum types reveal_type(Vehicle.CAR.value) # Pyrefly infers: int reveal_type(Vehicle.CAR.label) # Pyrefly infers: str reveal_type(Vehicle.values) # Pyrefly infers: list[int] reveal_type(Vehicle.choices) # Pyrefly infers: list[tuple[int, str]]   Pyrefly also supports TextChoices and the base Choices class with various value types including enum.auto() for automatic value generation.    ","version":"Next","tagName":"h3"},{"title":"Differences from Mypy‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#differences-from-mypy","content":" Mypy uses a plugin (mypy-django-plugin) that provides very detailed type information by accessing runtime Django internals and performing multiple passes over the code. Pyrefly takes a different approach by following the type stubs directly without runtime introspection.  ","version":"Next","tagName":"h2"},{"title":"Type Representation Differences‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#type-representation-differences","content":" In some cases, such as ManyToManyField relationships, Mypy and Pyrefly infer different types:  Example:  from django.db import models class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): title = models.CharField(max_length=200) authors = models.ManyToManyField(Author, related_name=&quot;books&quot;) class Article(models.Model): headline = models.CharField(max_length=200) authors = models.ManyToManyField(Author, related_name=&quot;articles&quot;) # What types do the managers have? book = Book() article = Article()   Mypy (with django plugin):  book.authors has type: Author_ManyRelatedManager[Book_authors]article.authors has type: Author_ManyRelatedManager[Article_authors]These are different types (different class name, different type parameter)Mypy will reject assigning one to the other  Pyrefly (following stubs):  book.authors has type: ManyRelatedManager[Author, Model]article.authors has type: ManyRelatedManager[Author, Model]These are the same typePyrefly will accept assigning one to the other    ","version":"Next","tagName":"h3"},{"title":"Features Not Yet Supported‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#features-not-yet-supported","content":" These are some of the Django features are not yet supported in this experimental release:  ","version":"Next","tagName":"h2"},{"title":"Reverse Relationships‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#reverse-relationships","content":" Django automatically creates reverse relationships for ForeignKey and ManyToManyField. For example:  class Reporter(models.Model): full_name = models.CharField(max_length=70) class Article(models.Model): reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE) # Not yet supported: reporter = Reporter() reveal_type(reporter.article_set) # Expected: RelatedManager[Article]   ","version":"Next","tagName":"h3"},{"title":"Advanced QuerySet Operations‚Äã","type":1,"pageTitle":"Experimental Django Support","url":"/en/docs/django/#advanced-queryset-operations","content":" While basic .all() operations are supported, more complex QuerySet operations may not have complete type inference.  Those are not the only unsupported features, so if there are specific features you would like to see, please request them by opening a github issue and adding the Django label to it. ","version":"Next","tagName":"h3"},{"title":"Pyrefly Error Suppressions","type":0,"sectionRef":"#","url":"/en/docs/error-suppressions/","content":"","keywords":"","version":"Next"},{"title":"Error Suppression Comments‚Äã","type":1,"pageTitle":"Pyrefly Error Suppressions","url":"/en/docs/error-suppressions/#error-suppression-comments","content":" The Python type system allows you to suppress errors with a comment. This feature can be helpful in many scenarios. For example, after enabling a type checker, suppressions can allow you to get a clean type check signal without having to stop and fix every pre-existing error in your code.  There are multiple ways to do this in Pyrefly.  def foo() -&gt; int: # pyrefly: ignore return &quot;this is a type error&quot;   You can also put the comment on the same line as the error.  def foo() -&gt; int: return &quot;this is a type error&quot; # pyrefly: ignore   You can also target specific error types:  def foo() -&gt; int: return &quot;this is a type error&quot; # pyrefly: ignore[bad-return]   We respect the specification and allow type: ignore to be used:  def foo() -&gt; int: return &quot;this is a type error&quot; # type: ignore   We also have a special comment that will ignore all errors in a file.  # pyrefly: ignore-errors from typing import * def test(x: int): return f&quot;{x}&quot; def bar() -&gt; int: # this error won't be reported return &quot;&quot;   Pyrefly can automatically suppress all type errors in your project by running:  pyrefly suppress   This is equivalent to pyrefly check --suppress-errors.  ","version":"Next","tagName":"h2"},{"title":"Baseline Files (Experimental)‚Äã","type":1,"pageTitle":"Pyrefly Error Suppressions","url":"/en/docs/error-suppressions/#baseline-files-experimental","content":" Pyrefly also supports storing errors in a baseline file. Any errors matching the baseline will be ignored and only new errors will be reported. This is useful when introducing type checking to a project for the first time, or when rolling out changes that require many suppression comments. This feature is inspired by tools like basedpyright and Android Studio.  To generate (or re-generate) the baseline file:  pyrefly check --baseline=&quot;&lt;path to baseline file&gt;&quot; --update-baseline   To check your project using a baseline file and report only newly-introduced errors, you can either use the CLI flag:  pyrefly check --baseline=&quot;&lt;path to baseline file&gt;&quot;   Or specify the baseline in your configuration file (pyrefly.toml or pyproject.toml):  # pyrefly.toml baseline = &quot;baseline.json&quot;   # pyproject.toml [tool.pyrefly] baseline = &quot;baseline.json&quot;   When the baseline is specified in the configuration file, you don't need to pass the --baseline flag on every invocation. The CLI flag takes precedence if both are specified.  Note that baseline is a project-level setting and cannot be overridden in sub-config sections. If you need different baseline files for different parts of your codebase, consider using separate Pyrefly configuration files.  Errors are matched with the baseline by looking at file, error code, and column number. Note that errors suppressed by the baseline file are still shown in the IDE. This feature is experimental, so please submit any feedback or requests you have on our Github repo.  ","version":"Next","tagName":"h2"},{"title":"Upgrading Pyrefly (And other changes that introduce new type errors)‚Äã","type":1,"pageTitle":"Pyrefly Error Suppressions","url":"/en/docs/error-suppressions/#upgrading-pyrefly-and-other-changes-that-introduce-new-type-errors","content":" Upgrading the version of Pyrefly you're using, or a third party library you depend on can surface new type errors in your code. Fixing them all at once is often not realistic. We've written scripts to help you temporarily silence them.  # step 1 pyrefly suppress   # step 2 &lt;run your formatter of choice&gt;   # step 3 pyrefly suppress --remove-unused   Repeat the steps above until you get a clean formatting run and a clean type check.  This will add # pyrefly: ignore comments to your code that will enable you to silence errors, and come back and fix them at a later date. This can make the process of upgrading a large codebase much more manageable.  note pyrefly suppress is equivalent to pyrefly check --suppress-errors, and pyrefly suppress --remove-unused is equivalent to pyrefly check --remove-unused-ignores. ","version":"Next","tagName":"h2"},{"title":"IDE Supported Features","type":0,"sectionRef":"#","url":"/en/docs/IDE-features/","content":"","keywords":"","version":"Next"},{"title":"Go to definition‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#go-to-definition","content":" Jump to where a symbol was originally defined with a click or F12. If there is both a .pyi and .py file, we will jump to the .py.      ","version":"Next","tagName":"h3"},{"title":"Go to type definition‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#go-to-type-definition","content":" Navigate to the underlying type of any expression. If the expression is a type, we will navigate to the .pyi file if both a .py and .pyi exist.      ","version":"Next","tagName":"h3"},{"title":"Go to declaration‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#go-to-declaration","content":" Navigate to where the type was defined, but stop at imports.      ","version":"Next","tagName":"h3"},{"title":"Go to implementation‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#go-to-implementation","content":" On a method, navigate to all reimplementations.      ","version":"Next","tagName":"h3"},{"title":"Move/rename file‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#moverename-file","content":" When moving or renaming a file, Pyrefly will do it's best to rename all references to it.      ","version":"Next","tagName":"h3"},{"title":"Find references‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#find-references","content":" List all usages of a symbol across your codebase.      ","version":"Next","tagName":"h3"},{"title":"Document symbols‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#document-symbols","content":" See an outline of all top-level items in the current file.      ","version":"Next","tagName":"h3"},{"title":"Workspace symbols‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#workspace-symbols","content":" Search globally for functions, classes, and variables.      ","version":"Next","tagName":"h3"},{"title":"Hover‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#hover","content":" See type info and docstrings when hovering over code.      ","version":"Next","tagName":"h3"},{"title":"Document highlights‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#document-highlights","content":" Highlights all other instances of the symbol under your cursor.      ","version":"Next","tagName":"h3"},{"title":"Signature help‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#signature-help","content":" Live function signatures as you type, with parameter hints.      ","version":"Next","tagName":"h3"},{"title":"Completion‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#completion","content":" Autocomplete suggestions for project-specific symbols and imports.      ","version":"Next","tagName":"h3"},{"title":"Rename‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#rename","content":" Safely rename symbols project-wide.      ","version":"Next","tagName":"h3"},{"title":"Diagnostics‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#diagnostics","content":" Type errors and warnings from Pyrefly‚Äôs checker appear in the diagnostics pane (&quot;Problems&quot; pane in VSCode).      ","version":"Next","tagName":"h3"},{"title":"Semantic tokens‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#semantic-tokens","content":" Rich syntax highlighting based on token type and origin.      ","version":"Next","tagName":"h3"},{"title":"Inlay hints‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#inlay-hints","content":" Inline hints for types, parameter names, and return values.  info We reuse Pyright's python.analysis.inlayHints.&lt;&gt; settings for backwards compatibility. If you have or had Pyright, check these settings if inlay hints do not appear.  You can turn inlay hints on or off using the VSCode Setting editor.inlayHints.enabled.  Inlay hints can be double clicked to insert them as an annotation.    Go-to-definition can be used on a type in an inlay hint to jump its definition. This works even if the type isn't explicitly imported by the current file.      ","version":"Next","tagName":"h3"},{"title":"Notebook support‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#notebook-support","content":" Pyrefly provides language services for Jupyter notebooks directly in VS Code and also in Jupyter Lab.  In Jupyter Lab, once you install the jupyterlab-lsp extension, and Pyrefly will appear on the list of automatically-detected language servers.  Notebook support is experimental. Please report any bugs on our Github.    ","version":"Next","tagName":"h3"},{"title":"Call Hierarchy‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#call-hierarchy","content":" See all incoming functions calls to a particular function, as well as all outgoing function calls from a function. Call Hierarchy provides a full picture of how a particular function is used within a call stack.      ","version":"Next","tagName":"h3"},{"title":"Type Hierarchy‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#type-hierarchy","content":" See all subclasses and superclasses of a selected class.      ","version":"Next","tagName":"h3"},{"title":"Refactor: Pull Member Up and Push Member Down‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#refactor-pull-member-up-and-push-member-down","content":" Pull a method from a subclass to a superclass, or push a method from a superclass to a subclass.  Pull Member Up    Push Member Down      ","version":"Next","tagName":"h3"},{"title":"Refactor: Convert to Package and Convert to Module‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#refactor-convert-to-package-and-convert-to-module","content":" Convert to Package takes .py file and moves it to a package directory with all logic moved into an init.py file.    Convert to Module takes an existing package with all logic defined in its init.py and creates a named .py file from it.      ","version":"Next","tagName":"h3"},{"title":"Refactor: Move function to top level‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#refactor-move-function-to-top-level","content":" Takes a function nested within another function or statement and moves it to the top level of the module.      ","version":"Next","tagName":"h3"},{"title":"Refactor: Introduce Parameter‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#refactor-introduce-parameter","content":" Adds a new parameter to a function definition and update all call sites to pass the new parameter.      ","version":"Next","tagName":"h3"},{"title":"Refactor: Inline Variable‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#refactor-inline-variable","content":" Removes redundant variables by replacing them with their value.      ","version":"Next","tagName":"h3"},{"title":"Refactor: Extract to Field‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#refactor-extract-to-field","content":" Declare a new field on a class with the value of the selected expression.      ","version":"Next","tagName":"h3"},{"title":"Refactor: Extract to Variable‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#refactor-extract-to-variable","content":" Declare a new variable with the value of the selected expression.      ","version":"Next","tagName":"h3"},{"title":"Refactor: Invert Boolean‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#refactor-invert-boolean","content":" Flips the value of a boolean and updates all usages to work with new value.      ","version":"Next","tagName":"h3"},{"title":"Planned features‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#planned-features","content":" See planned features and request your own on GitHub. ","version":"Next","tagName":"h2"},{"title":"Pyrefly Configuration","type":0,"sectionRef":"#","url":"/en/docs/configuration/","content":"","keywords":"","version":"Next"},{"title":"Simple Configuration Example‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#simple-configuration-example","content":" Here's an example of a simple config. To see more complex examples, including in a pyproject.toml, look atExample Configurations, which show Pyrefly's default config, as well as other ways you can set your configuration.  # set the directory Pyrefly will search for files to type check project-includes = [ &quot;a&quot;, &quot;b/c/d&quot;, &quot;e&quot; ] # manually set the `sys.platform` Pyrefly will assume when type checking python-platform = &quot;linux&quot; # a table mapping error codes to an `is-enabled` boolean [errors] # disable `bad-assignment` errors bad-assignment = false # disable `bad-return` errors bad-return = false   ","version":"Next","tagName":"h2"},{"title":"Precedence in Options‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#precedence-in-options","content":" Configuration options are selected in the following order  CLI flags Examples: --project-excludes &lt;value&gt;, --python-version &lt;value&gt; Configuration options Examples: (in a pyrefly.toml) project-excludes = &lt;value&gt;, python-version = &lt;value&gt; Pyrefly defaults See Default pyrefly.toml for the default values used  ","version":"Next","tagName":"h2"},{"title":"Type Checking Modes‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#type-checking-modes","content":" Pyrefly has two different modes it can run in when type checking your project, which correspond to different but useful ways we expect most people to interact with Pyrefly:  Project mode: attempt to load a config, falling back to Pyrefly's default config when none can be found, and type check using that one config. This involves getting theproject-includes and project-excludes from the file, expanding the patterns, and type checking on those files. Project mode is used whenever no files are provided with the CLI invocation. Per-file or Single-file mode: when given FILES... (and optionally --project-excludes) during a CLI invocation, expand the patterns and find the relevant config file for each file listed. project-includes and project-excludes are ignored from the config file, but it is used for all remaining config options.  ","version":"Next","tagName":"h2"},{"title":"Configuration Finding‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-finding","content":" In both project checking mode and single-file checking mode (see Type Checking Modesfor more info), we attempt to find a project root from which to check each file, both for reading config options and for import resolution. The project root is typically the directory containing the configuration file. More precisely:  If a configuration file is provided with -c/--config, we use the directory the file is located in as the directory to check.If no configuration file is passed, we perform an upward file search from the 'start location' to the filesystem root, looking in each directory for any of the following files: pyrefly.toml, pyproject.toml,setup.py, mypy.ini, and pyrightconfig.json. If we find one, we use the directory it's found in as the containing directory.If no configuration file is found, we will still attempt to resolve imports by walking up the tree looking for a matching import. For example: when importing from a.b.c import q, if our project structure looks like /x/y/z/a/b/c, we can walk up the components of a.b.c to find a root at/x/y/z.  Note that only pyrefly.toml and pyproject.toml are parsed for config options, but we look for additional files that mark the root of a project to aid import resolution.  For project checking mode, the 'start location' is current working directory. For single-file checking mode, the start location is the directory containing each file to be type checked, and we find the config for each file matched by the pattern provided.  If a pyrefly.toml is found, it is parsed and used for type checking, and will return an error to the user on invalid types, syntax, values, or unknown config options.  If a pyproject.toml is found, Pyrefly will use the [tool.pyrefly]section if it exists, otherwise it will assume a default config. The same errors will be returned as when loading a pyrefly.toml if the config is invalid.  ","version":"Next","tagName":"h2"},{"title":"Providing a Config in Single-File Mode‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#providing-a-config-in-single-file-mode","content":" Providing -c/--config in single-file checking mode disables the upward file search for config files. All options are read from the provided config file except project-includes andproject-excludes, which are ignored.  ","version":"Next","tagName":"h3"},{"title":"Configuration Options‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-options","content":" The following section lists all recognized options that can be specified in a config file or pyproject.toml Pyrefly config section.  ","version":"Next","tagName":"h2"},{"title":"project-includes‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#project-includes","content":" The glob patterns used to describe which files to type check, typically understood as user-space files.  This does not specifyImport Resolution priority or the path an import should be resolved from. See search-path instead.  Type: list of filesystem glob patternsDefault: [&quot;**/*.py*&quot;]Flag equivalent: FILES... argumentEquivalent configs: include in Pyright, files/modules/packages in mypyNotes: When overridden by passing in FILES..., we do not consult the relevant config file for what to use for project-excludes. If project-excludes should not use the default value, override it with the flag as well. This is because if multiple configs are loaded that conflict with project-includes, determining how to resolve checkable files gets complicated, and might become confusing to anyone attempting a type check if they're unaware of all the configs that will be used in the type check. Also, we get into a chicken-and-egg problem, where we don't know which files to exclude until we load all the configs we'll need, which requires loading all files, and imposes a large performance burden.When a project-includes pattern does not match any files, we will return an error.If you get an error about no matches for a directory when passing a glob as a CLI argument, try wrapping the glob in quotes to prevent eager shell glob expansion.  ","version":"Next","tagName":"h3"},{"title":"project-excludes‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#project-excludes","content":" The glob patterns used to describe which files to avoid type checking as way to filter files that match project-includes, but we don't want to type check.  The default value is appended to your project-excludes unless disable-project-excludes-heuristicsis set. See disable-project-excludes-heuristics to fully replace or remove project-excludes.  Type: list of filesystem glob patternsDefault: [&quot;**/node_modules&quot;, &quot;**/__pycache__&quot;, &quot;**/venv/**&quot;, &quot;**/.[!/.]*/**&quot;] + anything in your site-package-path (even from the interpreter) unless it would exclude items in your search-path.Flag equivalent: --project-excludesEquivalent configs: exclude in Pyright and mypyNotes: While not explicitly part of project-excludes, there are several patterns that are filtered out of type checked files at our glob-implementation layer. Dotfiles (any files that begin with a dot (.&lt;stuff&gt;)Any files that don't end in .py or .pyiYour site-package-path (including paths queried from the interpreter) It is an error if no files are returned from any project-includes because they are filtered out by project-excludes entries. We differentiate between an error from a project-includes that doesn't match any files, and an error from all project-includes getting filtered by project-excludes.When overridden by passing in FILES..., we do not consult the relevant config file for what to use for project-excludes. If project-excludes should not use the default value, override it with the flag as well. See reasoning in project-includes notes.Your site-package-path is added to your project-excludesautomatically. If you are trying to perform type checking on a dependency in yoursite-package-path (i.e. cd &lt;site-package-path&gt;/some_dependency &amp;&amp; pyrefly check), we recommend you pull and set up your dependency from GitHub, but you can achieve this on files in your site-package-path by setting site-package-path = [] in your config.  ","version":"Next","tagName":"h3"},{"title":"disable-project-excludes-heuristics‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#disable-project-excludes-heuristics","content":" By default, Pyrefly includes several items in your project-excludes(see project-excludes for the default values). These items are path patterns we've determined rarely have files that should be type checked, but can require a very long time to crawl while enumerating files, or contain third-party code that you likely don't care about errors in. When specifying project-excludes, we always append these defaults to whatever is specified by CLI or in your configuration.  Sometimes, these preselected settings can interfere with your project's setup.disable-project-excludes-heuristics lets you start from scratch, setting that default to [], so you can fully specify your project-excludes in case we get it wrong.  Type: boolDefault: falseFlag equivalent: --disable-project-excludes-heuristics  ","version":"Next","tagName":"h3"},{"title":"search-path‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#search-path","content":" A file path describing the roots from which imports should be found and imported from (including modules in project-includes). This takes the highest precedence in import order, before typeshed and site-package-path. When a project-includestype checked file is imported by another type checked file, we check all search roots to determine how to import it.  Type: list of directories specifying the rootDefault: import rootFlag equivalent: --search-pathEquivalent configs: extraPaths in Pyright, mypy_path in mypyNotes: We automatically apply some heuristics to improve your experience, especially when no configuration is provided. Seedisable-search-path-heuristics to disable this behavior, and Search Path Heuristics for the additional paths we add to your search-path.Libraries should not be listed here, since they may override typeshedvalues for your whole project, and have different import semantics with respect to typing. SeeImport Resolutionfor more information about how modules are imported.  ","version":"Next","tagName":"h3"},{"title":"disable-search-path-heuristics‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#disable-search-path-heuristics","content":" Disable any search path heuristics/additional search path behavior that Pyrefly will attempt to do for you. This can be useful if Pyrefly is picking up the wrong import paths for your project, for example, if you have multiple projects in the same directory or use a monorepo setup with the import root outside of the directory your configuration is defined in.  See Search Path Heuristics for more information on the search paths that are automatically added, and are affected by this flag. For more information on import resultion in general see theimport resolution docs.  Type: boolDefault: falseFlag equivalent: --disable-search-path-heuristicsEquivalent configs: noneNotes To see what search path we find for your a given file in your project, or your project overall, you can run pyrefly dump-config [&lt;file&gt;...].  Search Path Heuristics‚Äã  Pyrefly adds extra search paths to your configuration behind-the-scenes to handle the most common ways of setting up and configuring your project, on top of anysearch-path entries you may pass in through the CLI or set in your config.  The two heuristics that are currently supported are:  Adding your import root to the end of your search path. Your import root is a src/ directory in the same directory as a config file, the parent directory containing your config file if there's an __init__.py or __init__.pyi presentor the config file's directory itself if none of the previously mentioned directories or files can be found. See Configuration Finding for more information on what we'll find as a config file.If no config can be found, each directory from the given file to / will be added as a fallback search path.  See more on how Pyrefly does import resolution.  ","version":"Next","tagName":"h3"},{"title":"site-package-path‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#site-package-path","content":" A file path describing a root from which imports should be found and imported from. This takes the lowest priority in import resolution, after search-path and typeshed.  See more on how Pyrefly does import resolution.  Type: list of directoriesDefault: ./typings + the result from Environment Autoconfiguration, or[] if the Python interpreter cannot be queriedFlag equivalent: --site-package-pathEquivalent configs: noneNotes: The queried interpreter's site package paths will always be included in addition to any user-specified value, unless environment auto-configuration is turned off.Ideally, this should not be set manually, unless you're using a venv, running one-off tests, testing specific behavior, or having trouble with Environment Autoconfiguration. Setting this explicitly, especially when not using a venv, will make it difficult for your configuration to be reused between different systems and platforms.If you're running into problems with editiable installations in your project, please read up on editable installs with static analysis tools.  ","version":"Next","tagName":"h3"},{"title":"python-platform‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python-platform","content":" The value used with conditions based on type checking againstsys.platformvalues.  Type: stringDefault: result from Environment Autoconfiguration, or &quot;linux&quot; if the Python interpreter cannot be queriedFlag equivalent: --python-platformEquivalent configs: pythonPlatform in Pyright, platform in mypy  ","version":"Next","tagName":"h3"},{"title":"python-version‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python-version","content":" The value used with conditions based on type checking againstsys.versionvalues. The format should be &lt;major&gt;[.&lt;minor&gt;[.&lt;micro&gt;]], where minor and micro can be omitted to take the default positional value.  Type: string of the format &lt;major&gt;[.&lt;minor&gt;[.&lt;micro&gt;]]Default: result from Environment Autoconfiguration, or3.13.0 if the Python interpreter cannot be queriedFlag equivalent: --python-versionEquivalent configs: pythonVersion in Pyright, python_version in mypy  ","version":"Next","tagName":"h3"},{"title":"conda-environment‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#conda-environment","content":" The name of the Conda environment to query when attempting to autoconfigure Python environment values (site-package-path, python-platform, python-version). See the Environment Autoconfiguration section for more information. We query Conda with conda info --envs, then find the environment's interpreter in Environment Autoconfirugration.  We will query Conda for information about this environment, even when it's not sourced, unless a Python environment (venv, Conda) is activated or --python-interpreter-path or--conda-environment are passed in through the CLI.  conda-environment, fallback-python-interpreter-name, conda-environment, and skip-interpreter-query are mutually exclusive with each other.  Type: string of existing Conda environment nameDefault: noneFlag equivalent: --conda-environmentEquivalent configs: noneNotes: This enables the use of a non-local but customizable global environment without having to hard-code a path, which is not preferable on a shared project.  ","version":"Next","tagName":"h3"},{"title":"python-interpreter-path‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python-interpreter-path","content":" The Python interpreter to query when attempting to autoconfigure Python environment values (site-package-path, python-platform, python-version). See the Environment Autoconfiguration section for more information.  conda-environment, fallback-python-interpreter-name, conda-environment, and skip-interpreter-query are mutually exclusive with each other.  Type: path to executableDefault: $(which python3), then $(which python), or noneFlag equivalent: --python-interpreter-pathEquivalent configs: python_executable in mypyNotes: This executes the value present in the python-interpreter-path field without any checks. It could be a security risk if your python-interpreter-path is an arbitrary executable.If you don't have a Python interpreter installed on your machine, we'll output an error letting you that we couldn't appropriately configure your environment. Configure skip-interpreter-query to skip the check and avoid the error.  NOTE: Ideally, this should not be set manually, unless you're using a venv, running one-off tests, testing specific behavior, or having trouble with Environment Autoconfiguration. Setting this explicitly, especially when not using a venv, will make it difficult for your configuration to be reused between different systems and platforms.  ","version":"Next","tagName":"h3"},{"title":"fallback-python-interpreter-name‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#fallback-python-interpreter-name","content":" The Python interpreter, available on your $PATH, to use. Pyrefly will performwhich &lt;your command&gt;, and automatically fill in python-interpreter-path for you with the found path. Pyrefly will automatically search for python3 and python on your path when this option and python-interpreter-path are unset ifskip-interpreter-query = false, so this should primarily be used when you have a non-standard Python executable you want to use.  conda-environment, fallback-python-interpreter-name, conda-environment, and skip-interpreter-query are mutually exclusive with each other.  Type: string of command to useDefault: python3, then python, or noneFlag equivalent: --fallback-python-interpreter-nameNotes: This executes the value present in the fallback-python-interpreter-name field without any checks. It could be a security risk if your fallback-python-interpreter-name is an arbitrary executable.If you don't have a Python interpreter installed on your machine, we'll output an error letting you that we couldn't appropriately configure your environment. Configure skip-interpreter-query to skip the check and avoid the error.  ","version":"Next","tagName":"h3"},{"title":"skip-interpreter-query‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#skip-interpreter-query","content":" Skip querying any interpreters and do not do anyEnvironment Autoconfiguration. This means that Pyrefly will take hard-coded defaults for python-versionand python-platform, and will use an emptysite-package-path. It's likely you'll want to override these to match the environment you'll be running in.  conda-environment, fallback-python-interpreter-name, conda-environment, and skip-interpreter-query are mutually exclusive with each other.  Type: boolDefault: falseFlag equivalent: --skip-interpreter-query  ","version":"Next","tagName":"h3"},{"title":"typeshed-path‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#typeshed-path","content":" Override the version of typeshed that's being used for type checking. The provided path should point to the root of typeshed.  Typeshed contains the type information for Python's standard library, which Pyrefly uses for type checking and resolving both the most basic types (like object, str, ...) and types/type signatures from stdlib modules.  Type: path to typeshedDefault: none (resolves to bundled typeshed)Flag equivalent: --typeshed-path  ","version":"Next","tagName":"h3"},{"title":"baseline‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#baseline","content":" Path to a baseline JSON file for comparing type errors. Errors matching the baseline are suppressed, so only newly-introduced errors are reported. This is useful when introducing type checking to a project for the first time, or when rolling out changes that would otherwise produce many new errors at once.  To generate (or re-generate) the baseline file, run:  pyrefly check --baseline=&quot;&lt;path to baseline file&gt;&quot; --update-baseline   See the Error Suppressions docs for more details on how baseline files work.  Type: path to a JSON fileDefault: none (no baseline)Flag equivalent: --baselineNotes: baseline is a project-level setting and cannot be overridden insub-config sections.Errors suppressed by the baseline file are still shown in the IDE.Errors are matched with the baseline by file, error code, and column number.  ","version":"Next","tagName":"h3"},{"title":"errors‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#errors","content":" Configure the severity for each kind of error that Pyrefly emits: error, warn, ignore.  info Want type error squiggles to show up in your editor by default? Try setting python.pyrefly.displayTypeErrors to &quot;force-on&quot; in your editor settings, create a pyrefly.toml file in your project root, or add a [tool.pyrefly] section to your pyproject.toml (can be empty).  Type: Table of error code to boolean representing enabled statusDefault: errors = {}/[errors]Flag equivalent: --error, --warn, --ignoreEquivalent configs:type check rule overridesand type evaluation settingsin Pyright,enable_error_code anddisable_error_codein mypyNotes: Setting &lt;error-code&gt; = true means the error will be shown at default severity (or severity ERROR if the error is off by default). Setting&lt;error-code&gt; = false will disable the error for type checking.If you want to disable type errors in IDE mode, you can also setdisable-type-errors-in-ide, which will automatically disable all type errors and Pyrefly diagnostics in the IDE.  ","version":"Next","tagName":"h3"},{"title":"disable-type-errors-in-ide‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#disable-type-errors-in-ide","content":" Disables type errors from showing up when running Pyrefly in an IDE. This is primarily used when Pyrefly is acting in a language-server-only mode, but some kind of manual configuration is necessary for it to work properly, or when you wouldonly want to see type errors on CLI/CI runs.  Type: boolDefault: falseFlag equivalent: noneNotes: if you want to disable errors on CLI/CI runs as well, or if you're looking to turn on/off specific errors, you may be looking for the errors config option instead.  ","version":"Next","tagName":"h3"},{"title":"skip-lsp-config-indexing‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#skip-lsp-config-indexing","content":" Disables automatic project indexing when running Pyrefly as a language server. Enabling this may speed up LSP startup and reduce resource usage on large projects, at the cost of some language server features that rely on a full project index.  Type: boolDefault: falseFlag equivalent: none  ","version":"Next","tagName":"h3"},{"title":"replace-imports-with-any‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#replace-imports-with-any","content":" Instruct Pyrefly to unconditionally replace the given ModuleGlobs with typing.Any and ignore import errors for the module. For example, with from x.y import z in a file, adding x.*, *.y, or x.y to this config will silence those import errors and replace the module with typing.Any. If the module can be found, its type information will still be replaced with typing.Any.  This is different from ignore-missing-imports, which only replaces the import with typing.Any if it can't be found.  Type: list of regexDefault: []Flag equivalent: --replace-imports-with-anyEquivalent configs: follow_imports = skip in mypy  ","version":"Next","tagName":"h3"},{"title":"ignore-missing-imports‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#ignore-missing-imports","content":" Instruct Pyrefly to replace the given ModuleGlobs with typing.Any and ignore import errors for the module only when the module can't be found.  For example, with from x.y import z in a file, adding x.*, *.y, or x.y to this config will silence those import errors and replace the module with typing.Anyif x.y can't be found. If x.y can be found, then z's type will be used.  This is different from replace-imports-with-any, which will always, unconditionally replace the import with typing.Any.  Type: list of regexDefault: []Flag equivalent: --ignore-missing-importsEquivalent configs: ignore_missing_imports in mypyNotes: errors = {missing-import = false} (TOML inline table for errors) has similar behavior in Pyrefly, but ignoresall import errors instead of import errors from specific modules.When a .pyc file is encountered and no source/stub files are available, Pyrefly automatically treats module as typing.Any. This behavior ensures that compiled Python files without available source code do not cause import errors and are handled permissively.  ","version":"Next","tagName":"h3"},{"title":"ignore-errors-in-generated-code‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#ignore-errors-in-generated-code","content":" Whether to ignore type errors in generated code. If enabled, generated files will be treated as if they are included in project-excludes. The generated code status is determined by checking if the file contents contain the substring '@generated'.  Type: boolDefault: falseFlag equivalent: --ignore-errors-in-generated-codeEquivalent configs: none  ","version":"Next","tagName":"h3"},{"title":"infer-with-first-use‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#infer-with-first-use","content":" Whether to infer type variables not determined by a call or constructor based on their first usage. This includes empty containers like [] and {}.  The default behavior is similar to Mypy - the type of the variable is inferred based on the first usage.  x = [] x.append(1) # x is list[int] x.append(&quot;2&quot;) # error!   Setting this to false will make Pyrefly infer Any for unsolved type variables, which behaves like Pyright.  x = [] # x is list[Any] x.append(1) # ok x.append(&quot;2&quot;) # ok   Type: boolDefault: trueFlag equivalent: --infer-with-first-use  ","version":"Next","tagName":"h3"},{"title":"untyped-def-behavior‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#untyped-def-behavior","content":" How should Pyrefly treat function definitions with no parameter or return type annotations?  By default, Pyrefly uses the &quot;check-and-infer-return-type&quot; behavior and will check all function bodies, inferring the return type.  info To provide inferred return types with check-and-infer-return-type, especially for site-package paths (third-party packages), Pyrefly may need to load and analyze more modules than you might otherwise see from mypy. This may result in increased type check durations or an output showing more modules analyzed than you expect. If this behavior is not preferred, you should setuntyped-def-behavior to skip-and-infer-return-any in your config or pass it in as a flag.  If this option is set to &quot;check-and-infer-return-any&quot;, then Pyrefly will still check the function body but will treat the return type as Any.  If this option is set to &quot;skip-and-infer-return-any&quot;, Pyrefly will again treat the return type as Any, but will also skip checking the function body. In this case, Pyrefly will also infer Any as the type of any attributes inferred based on this function body. This behavior is what PEP 484 specifies, although we do not recommend it for most users today; since Pyrefly will not analyze the bodies of untyped functions, language server functionality like showing types on hover and finding definitions will not be available there.  info skip-and-infer-return-any is mypy's default inference behavior, and how we will attempt to migrate your existing mypy configuration when running pyrefly init. See Migrating from Mypy for more information on config migration.  Type: one of &quot;check-and-infer-return-type&quot;, &quot;check-and-infer-return-any&quot;,&quot;skip-and-infer-return-any&quot;Default: &quot;check-and-infer-return-type&quot;Flag equivalent: --untyped-def-behaviorEquivalent configs: The &quot;check-and-infer-return-type&quot; behavior emulates Pyright's default behavior.The &quot;skip-and-infer-return-any&quot; behavior emulates mypy's default behavior.The &quot;check-and-infer-return-any&quot; behavior emulates mypy'scheck_untyped_defs flag.  ","version":"Next","tagName":"h3"},{"title":"use-ignore-files‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#use-ignore-files","content":" Whether to allow Pyrefly to use ignore files in your project and automatically add excluded files and directories to your project-excludes. Similar to project-excludes, when explicitly specifying files to check, ignore files are not used.  Pyrefly automatically searches for ignore files such as .gitignore, .ignore, and .git/info/excludes in an upward search from your project root. Only the first of each type of ignore file will be used, so if you have a .gitignore and .git/info/excludesavailable, in different directories, Pyrefly will use both of them. Pyrefly will not use global ignore files.  When multiple ignore files are found, Pyrefly checks them for excludes matches when determining the files to type check in the order of .gitignore, .ignore, and.git/info/excludes, taking the result of the first ignore file that has a match (either allowlist or denylist). Regular.gitignore-style allowlist/denylist matching rules apply.  Type: boolDefault: trueFlag equivalent: --use-ignore-files  ","version":"Next","tagName":"h3"},{"title":"build-system‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#build-system","content":" Pyrefly supports integrating into build systems to discover targets to type check and their dependencies. It currently natively supportsBuck2, as well as arbitrary build systems via custom queries.  Note that support for build systems is currently unstable, and breakage may occur without notice. Support will likely be lower priority than other issues for a while.  Buck2‚Äã  To configure Pyrefly to use Buck2 as a build system, add the following to yourpyrefly.toml:  [build-system] type = &quot;buck&quot; # Optional: The isolation dir for Buck2 to use. isolation-dir = &quot;pyrefly&quot; # Optional: Extra flags passed to Buck2. extras = [&quot;--verbose&quot;, &quot;4&quot;]   Behind the scenes, Pyrefly will run theprelude//python/sourcedb/pyrefly.bxl:main BXL script to get the necessary information about the targets to type check.  Here is a description of the supported optional options:  isolation-dir  Name of the isolation dir to use when running the BXL query (see buck2 --helpor Buck's documentation for more information about isolation dirs).  Type: string Default: none (Buck's own default is v2)  extras  Extra command line arguments passed to buck2 when running the query.  Type: list of stringsDefault: []  Custom queries‚Äã  Arbitrary build systems can be integrated using the custom type:  [build-system] type = &quot;custom&quot; command = [&quot;some&quot;, &quot;command&quot;, &quot;...&quot;]   Here is a description of the supported options:.  command  The command executed to query the build system about available targets.  Pyrefly will call this in the form &lt;command...&gt; @&lt;argfile&gt;, where &lt;argfile&gt;has the format:  -- &lt;arg-flag&gt; &lt;arg&gt; ...   &lt;arg-flag&gt; is either --file or --target, depending on the type of&lt;arg&gt;, and &lt;arg&gt; is an absolute path to a file or a build system's target.  The command should output a JSON file with the following structure:  { &quot;root&quot;: &quot;/path/to/this/repository&quot;, &quot;db&quot;: { &quot;//colorama:py-stubs&quot;: { &quot;srcs&quot;: { &quot;colorama&quot;: [ &quot;colorama/__init__.pyi&quot; ] }, &quot;deps&quot;: [], &quot;buildfile_path&quot;: &quot;colorama/BUCK&quot;, &quot;python_version&quot;: &quot;3.12&quot;, &quot;python_platform&quot;: &quot;linux&quot; }, &quot;//colorama:py&quot;: { &quot;srcs&quot;: { &quot;colorama&quot;: [ &quot;colorama/__init__.py&quot; ] }, &quot;deps&quot;: [&quot;//colorama:py-stubs&quot;], &quot;buildfile_path&quot;: &quot;colorama/BUCK&quot;, &quot;python_version&quot;: &quot;3.12&quot;, &quot;python_platform&quot;: &quot;linux&quot; }, &quot;//colorama:colorama&quot;: { &quot;alias&quot;: &quot;//colorama:py&quot; } } }   Where:  root is the absolute path the root of the repository.db is a map from target names to either: library target definitions (e.g. //colorama:py and //colorama:py-stubs here)target aliases (e.g. //colorama:colorama here)  For reference, the command invoked as part of the Buck2 integration is:  buck2 [--isolation-dir &lt;isolation_dir&gt;] bxl --reuse-current-config [&lt;extras&gt;...] prelude//python/sourcedb/pyrefly.bxl:main @&lt;argfile&gt;   Type: list of stringsDefault: none (the option is required)  repo_root  Path to the root of the repository.  Type: pathDefault: none  ","version":"Next","tagName":"h3"},{"title":"permissive-ignores‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#permissive-ignores","content":" Should Pyrefly ignore errors based on annotations from other tools, e.g. # pyre-ignore or # mypy: ignore? By default, respects # pyrefly: ignore and # type: ignore. Enabling this option is equivalent to passing the names of all tools to enabled-ignores.  Type: boolDefault: falseFlag equivalent: --permissive-ignores  ","version":"Next","tagName":"h3"},{"title":"enabled-ignores‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#enabled-ignores","content":" What set of tools should Pyrefly respect ignore directives from? Passing the names of all tools is equivalent to enabling permissive-ignores.  Type: list of toolsDefault: [&quot;type&quot;, &quot;pyrefly&quot;]Flag equivalent: --enabled-ignores  ","version":"Next","tagName":"h3"},{"title":"sub-config‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#sub-config","content":" Override specific config values for matched paths in your project. SeeSubConfigs for more information on the structure and values that can be overridden here.  Type: TOML array of tables with a SubConfig structureDefault: []Flag equivalent: noneEquivalent configs: executionEnvironments in Pyright, per-module config options in mypy  ","version":"Next","tagName":"h3"},{"title":"recursion-depth-limit‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#recursion-depth-limit","content":" warning This is a debugging option for investigating stack overflow issues. You should only use this if Pyrefly is crashing with a stack overflow. If you encounter such a crash, pleaseopen an issue.  Maximum recursion depth before triggering overflow protection. When set to a non-zero value, Pyrefly will detect when type checking recursion exceeds this limit and handle it according to recursion-overflow-handler.  Type: integerDefault: 0 (disabled)Flag equivalent: --recursion-depth-limit  ","version":"Next","tagName":"h3"},{"title":"recursion-overflow-handler‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#recursion-overflow-handler","content":" warning This is a debugging option. See recursion-depth-limit above.  How to handle when the recursion depth limit is exceeded:  &quot;break-with-placeholder&quot;: Return a placeholder type and emit an internal error. Safe for IDE use. &quot;panic-with-debug-info&quot;: Dump debug information to stderr and panic. For debugging stack overflow issues. Type: one of &quot;break-with-placeholder&quot;, &quot;panic-with-debug-info&quot; Default: &quot;break-with-placeholder&quot; Flag equivalent: --recursion-overflow-handler  ","version":"Next","tagName":"h3"},{"title":"Configuration Details‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-details","content":" This section describes some of the configuration options, behaviors, or types in more depth, when there are details shared between multiple config options or the information is more than what can fit under a single config option description.  ","version":"Next","tagName":"h2"},{"title":"Environment Autoconfiguration‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#environment-autoconfiguration","content":" Unless skip-interpreter-query is set, we'll attempt to query a Python interpreter to determine your python-platform orpython-version if they're unset. We also get asite-package-path from your interpreter to determine which packages you have installed and append those to the end of any site-package-pathyou've configured yourself, either through CLI flags or a config file.  We look for an interpreter with the following logic:  Use python-interpreter-path,fallback-python-interpreter-name](#fallback-python-interpreter-name), or [conda-environment` if any are set by a flag. More than one cannot be set in flags at the same time.Determine if there's an active venv or conda environment. If both are active at the same time, we take venv over conda.Use python-interpreter-path,fallback-python-interpreter-name](#fallback-python-interpreter-name), or [conda-environment` if either are set in a config file. Both cannot be set in a config at the same time.Find a venv at the root of the project by searching for something that looks like a Python interpreter (matches python(\\d(\\.\\d+)?)?(.exe)? regex), and looking for a pyvenv.cfg file in known locations. If we can't determine the root of your project with a config file or other well-known root marker file (e.g. setup.py,pyrightconfig.json, mypy.ini), this step is skipped.Query $(which python3) and $(which python) (platform independent) to use a system-installed interpreter.Fall back to Pyrefly's default values for any unspecified config options.  The config options we query the interpreter for are:  python-platform: sys.platformpython-version: sys.version_info[:3]site-package-path: site.getsitepackages() + [site.getusersitepackages()]  info You can run pyrefly dump-config and pass in your file or configuration like you would with pyrefly check to see what Pyrefly finds for your Python interpreter andsite-package-path, along with other useful config-debugging features.  ","version":"Next","tagName":"h3"},{"title":"Filesystem Globbing‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#filesystem-globbing","content":" We use a standard Unix-style glob, which allows for wildcard matching when specifying a fileset. It is similar to regex, but more restricted given the subset of allowed syntax for paths on a filesystem. We currently only allow matching files with a .py, .pyi, or .pyw suffix.  The globs provided are relative to the config, if one is found, or the current working directory otherwise. Absolute path globs can also be provided, though this is generally not recommended, since it may not be compatible with other systems type checking your project.  We recognize the following wildcards: * matches zero or more characters in a single directory component** matches the current and any sub directories/files in those sub directories? matches any one character[&lt;pattern&gt;] matches any character or character range between the brackets (character range separated by -)[!&lt;pattern&gt;] excludes any character or character range between the brackets and after the !Note: [] can be used to match ?, *, [, ] literally (e.g. [?]), although these are invalid as part of a Python path.  We also support non-wildcard paths, so a relative (or absolute) path like src/ will match all Python files under src/or src/my_file.py will match src/my_file.py exactly.  Any directories matched will also have their .py and .pyi files recursively matched. src/* will match all files and directories under src/, so therefore, we will recursively match everything under src/.  Examples:  src/**/*.py: only match .py files under src/src, src/, src/*, src/**, and src/**/*: match all .py and .pyi files under `src/?.py and [A-z].py: match any file that looks like &lt;letter&gt;.pysrc/path/to/my/file.py: only match src/path/to/my/file.pysrc/**/tests, src/**/tests/, src/**/tests/**, and src/**/tests/**/*: match all .py and .pyi files in src/under a directory named tests  ","version":"Next","tagName":"h3"},{"title":"Module Globbing‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#module-globbing","content":" In some config options, we've added globbing for module paths. This is different from both path globs and regex, in the sense that we're performing a match on a Python dotted import, such as this.is.any.module. The only wildcard we recognize is *, which represents zero or more segments of a module path, unless it starts a glob, in which case it must match one or more segments. The wildcard must be surrounded by ., unless it is at the start or end of a module glob.  Examples:  this.is.a.module would be equivalent to a regex like ^this\\.is\\.a\\.module. It will only match imports that look likethis.is.a.module.this.is.*.module would become ^this\\.is(\\..+)*\\.module$. It would match: this.is.modulethis.is.a.modulethis.is.a.really.long.path.to.a.module *.my.module would be equivalent to a regex like ^.+\\.my\\.module$. It would match: this.is.my.moduleheres.my.module It will not match: my.module this.is.* would be equivalent to a regex like ^this\\.is(\\..+)*. It would match: this.is.my.modulethis.is  ","version":"Next","tagName":"h3"},{"title":"Sub-Configs‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#sub-configs","content":" Sub-Configs are a method for overriding one or more config options for specific files based on filepath glob matching. Only certain config options are allowed to be overridden, and a need to override other configs means you likely need to use a separate config file for your subdirectory. You can have as many SubConfigs as you want in a project, and even multiple separate SubConfigs that can apply to a given file when the matches glob pattern matches.  SubConfig Allowed Overrides‚Äã  We currently allow the following config options to be overridden in a SubConfig:  errorsreplace-imports-with-anyuntyped-def-behaviorignore-errors-in-generated-code  All SubConfig overrides replace the values appearing in the 'root' or top-level of the Pyrefly configuration.  Any configs that change the list of files we're type checking, Python environment, or where we look for imports cannot be included in SubConfigs. Some other configs we also do not include because we think they make it difficult to reason about your project type checks, but you canopen an issue or make a pull request if you disagree and would like to see the option supported.  SubConfig Table Structure‚Äã  A SubConfig has two or more entries:  a matches key, with a Filesystem Glob detailing which files the config applies to.at least one of the SubConfig allowed overrides  SubConfig Option Selection‚Äã  Since you can have more than one SubConfig matching a file, we need to define a resolution order to determine which SubConfig's option should be selected. Pyrefly does this by filtering SubConfigs whose matches does not match the given file, then takes the first non-null value that can be found in the order the SubConfigs appear in your configuration.  If no SubConfigs match, or there are no non-null config options present, then we take the value in the 'root'/top-level Pyrefly config (or Pyrefly default if no value is specified).  SubConfig Example‚Äã  For the following config, this how options would be resolved.  replace-imports-with-any = [ &quot;sympy.*&quot;, &quot;*.series&quot;, ] ignore-errors-in-generated-code = true # disable `bad-assignment` and `invalid-argument` for the whole project [errors] bad-assignment = false invalid-argument = false [[sub-config]] # apply this to `sub/project/tests/file.py` matches = &quot;sub/project/tests/file.py&quot; # any unittest imports will by typed as `typing.Any` replace-imports-with-any = [&quot;unittest.*&quot;] [[sub-config]] # apply this config to all files in `sub/project` matches = &quot;sub/project/**&quot; # enable `assert-type` errors in `sub/project` [sub-config.errors] assert-type = true [[sub-config]] # apply this config to all files in `sub` matches = &quot;sub/**` # disable `assert-type` errors in `sub` [sub-config.errors] assert-type = false [[sub-config]] # apply this config to all files under `tests` dirs in `sub/` matches = &quot;sub/**/tests/**&quot; # any pytest imports will be typed as `typing.Any` replace-imports-with-any = [&quot;pytest.*&quot;]   sub/project/tests/file.py replace-imports-with-any: [&quot;unittest.*&quot;]errors: {assert-type = true}ignore-errors-in-generated-code: true sub/project/tests/another_file.py replace-imports-with-any: [&quot;pytest.*&quot;]errors: {assert-type = true}ignore-errors-in-generated-code: true sub/project/non_test_file.py replace-imports-with-any: [&quot;sympy.*&quot;, &quot;*.series&quot;]errors: {assert-type = true}ignore-errors-in-generated-code: true sub/sub_file.py replace-imports-with-any: [&quot;sympy.*&quot;, &quot;*.series&quot;]errors: {assert-type = false}ignore-errors-in-generated-code: true top_level_file.py replace-imports-with-any: [&quot;sympy.*&quot;, &quot;*.series&quot;]errors: {assert-type = true, bad-assignment = false, invalid-argument = false}ignore-errors-in-generated-code: true  ","version":"Next","tagName":"h3"},{"title":"Conda and Venv Support‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#conda-and-venv-support","content":" We plan on adding extra automatic support for Condaand Venv at some point soon, but we haven't made it around to doing this yet. If you would like to import packages from these in the meantime, you can follow the following steps.  ","version":"Next","tagName":"h3"},{"title":"Venv‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#venv","content":" If you have a venv set up locally, you can get Pyrefly working with it by having your venv sourced in your shell (source .venv/bin/activate), and we will automatically pick up your installed packages. To pick up your packages even when your environment isn't sourced, you can add .venv/bin/python3 (or&lt;path_to_venv&gt;/bin/python3) to your Pyrefly configuration underpython-interpreter-path or pass it in with the --python-interpreter-path flag.  ","version":"Next","tagName":"h3"},{"title":"Conda‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#conda","content":" If you have conda set up locally, you can get Pyrefly working with it by having your Conda environment sourced in your shell (conda activate &lt;environment&gt;), and we will automatically pick up your installed packages. To pick up your packages even when your environment isn't sourced, you can query your environment's install location with conda env list, and add &lt;conda_environment_path&gt;/bin/python3 to your Pyrefly configuration under python-interpreter-path or pass it in with the --python-interpreter-path flag.  ","version":"Next","tagName":"h3"},{"title":"Example Configurations‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-configurations","content":" This section displays an example config showing the usage of all config options listed above to make creating your own easier, and to give you an easy place to start.  ","version":"Next","tagName":"h2"},{"title":"Default pyrefly.toml‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#default-pyreflytoml","content":" This is a configuration with the Pyrefly defaults. If you have an interpreter installed, some of these values may be overridden.  ###### configuring what to type check and where to import from # check all Python files under the containing directory project-includes = [&quot;**/*.py*&quot;] # exclude some uninteresting files project-excludes = [&quot;**/node_modules&quot;, &quot;**/__pycache__&quot;, &quot;**/*venv/**&quot;, &quot;**/.[!/.]*/**&quot;] # perform an upward search for `.gitignore`, `.ignore`, and `.git/info/exclude`, and # add those to `project-excludes` automatically use-ignore-files = true # import project files from &quot;.&quot; search-path = [&quot;.&quot;] # let Pyrefly try to guess your search path disable-search-path-heuristics = false # do not include any third-party packages (except those provided by an interpreter) site-package-path = [] ###### configuring your python environment # assume we're running on linux, regardless of the actual current platform python-platform = &quot;linux&quot; # assume the Python version we're using is 3.13, without querying an interpreter python-version = &quot;3.13&quot; # is Pyrefly disallowed from querying for an interpreter to automatically determine your # `python-platform`, `python-version`, and extra entries to `site-package-path`? skip-interpreter-query = false # query the default Python interpreter on your system, if installed and `python_platform`, # `python-version`, or `site-package-path` are unset. # python-interpreter-path = null # this is commented out because there are no `null` values in TOML #### configuring your type check settings # wildcards for which Pyrefly will unconditionally replace the import with `typing.Any` replace-imports-with-any = [] # wildcards for which Pyrefly will replace the import with `typing.Any` if it can't be found ignore-missing-imports = [] # should Pyrefly skip type checking if we find a generated file? ignore-errors-in-generated-code = false # what should Pyrefly do when it encounters a function that is untyped? untyped-def-behavior = &quot;check-and-infer-return-type&quot; # can Pyrefly recognize ignore directives other than `# pyrefly: ignore` and `# type: ignore` permissive-ignores = false [errors] # this is an empty table, meaning all errors are enabled by default # no `[[sub-config]]` entries are included, since there are none by default   ","version":"Next","tagName":"h3"},{"title":"Example pyrefly.toml‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-pyreflytoml","content":" project-includes = [&quot;src&quot;] project-excludes = [&quot;**/.[!/.]*&quot;, &quot;**/tests&quot;] search-path = [&quot;src&quot;] site-package-path = [&quot;venv/lib/python3.12/site-packages&quot;] python-platform = &quot;linux&quot; python-version = &quot;3.12&quot; python-interpreter-path = &quot;venv/bin/python3&quot; replace-imports-with-any = [ &quot;sympy.*&quot;, &quot;*.series&quot;, ] ignore-errors-in-generated-code = true # disable `bad-assignment` and `invalid-argument` for the whole project [errors] bad-assignment = false invalid-argument = false [[sub-config]] # apply this to `sub/project/tests/file.py` matches = &quot;sub/project/tests/file.py&quot; # any unittest imports will by typed as `typing.Any` replace-imports-with-any = [&quot;unittest.*&quot;] [[sub-config]] # apply this config to all files in `sub/project` matches = &quot;sub/project/**&quot; # enable `assert-type` errors in `sub/project` [sub-config.errors] assert-type = true   ","version":"Next","tagName":"h3"},{"title":"Example pyproject.toml‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-pyprojecttoml","content":" ... # Pyrefly header [tool.pyrefly] #### configuring what to type check and where to import from project-includes = [&quot;src&quot;] project-excludes = [&quot;**/.[!/.]*&quot;, &quot;**/tests&quot;] search-path = [&quot;src&quot;] site-package-path = [&quot;venv/lib/python3.12/site-packages&quot;] #### configuring your python environment python-platform = &quot;linux&quot; python-version = &quot;3.12&quot; python-interpreter-path = &quot;venv/bin/python3&quot; #### configuring your type check settings replace-imports-with-any = [ &quot;sympy.*&quot;, &quot;*.series&quot;, ] ignore-errors-in-generated-code = true [tool.pyrefly.errors] bad-assignment = false invalid-argument = false [[tool.pyrefly.sub-config]] # apply this config to all files in `sub/project` matches = &quot;sub/project/**&quot; # enable `assert-type` errors in `sub/project` [tool.pyrefly.sub-config.errors] assert-type = true [[tool.pyrefly.sub-config]] # apply this config to all files in `sub` matches = &quot;sub/**` # disable `assert-type` errors in `sub/project` [tool.pyrefly.sub-config.errors] assert-type = false # other non-Pyrefly configs ...   ","version":"Next","tagName":"h3"},{"title":"Exit Codes‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#exit-codes","content":" Code\tMeaning0\tSuccess - command completed without issues 1\tUser error - command completed but problems (e.g., type errors) were found 3\tInfrastructure error - an error in the environment prevented the command from completing 101\tPanic - Pyrefly encountered an internal error and crashed ","version":"Next","tagName":"h2"},{"title":"Import Resolution","type":0,"sectionRef":"#","url":"/en/docs/import-resolution/","content":"","keywords":"","version":"Next"},{"title":"Relative Imports‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#relative-imports","content":" If the import is relative (starting with one or more dots), the import is resolved relative to the path of the file importing it. A single dot at the beginning of the import (e.g. .file.to.import) represents the current directory, and more dots (e.g. ..other.file) will continue to walk upward.  ","version":"Next","tagName":"h2"},{"title":"Absolute Imports‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#absolute-imports","content":" For absolute imports, Pyrefly searches for a match in each of the following groups. The matching process is explained in the next paragraph.  Try to import from the search path. See the search path section for more information.Try to import from typeshed.Try to import from the fallback search path. See the fallback search path section for more information on the contents of the search path.Try to import from the site package path. See thesite package path section for more information on the contents of the site package path.Return an import error.  When searching for a match in one of the above groups, Pyrefly performs the following process over two passes, one looking for stub packages, and the other looking for source packages. SeeStub Files vs Source Files for more information.  Attempt to match each part of the name to directories in the group, selecting the first match that is found.If the result is a .pyi file or regular package (directory with an__init__.py/__init__.pyi file), return the result. Otherwise, keep searching and attempt to find a .pyi file or regular package.  ","version":"Next","tagName":"h2"},{"title":"Search Path‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#search-path","content":" The search path (see search-path in configuration docs) consists of several entries representing project files.  Search path from CLI args.Search path from config files.If disable-search-path-heuristicsis not set, Pyrefly appends an import root directory to the search path.  The import root is:  src/ if there's a src/ directory in the same directory as the config file.The parent directory (..) if there's an __init__.py or __init__.pyi in the same directory as the config file.Otherwise, the directory containing the config file.  ","version":"Next","tagName":"h3"},{"title":"Fallback Search Path‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#fallback-search-path","content":" The fallback search path is a heuristic automatically constructed by Pyrefly to attempt to find project files when there's no config file marking the project root, and Pyrefly is unable to determine from other heuristics where an import root might be. It is only constructed whendisable-search-path-heuristicsis not set.  The fallback search path consists of each directory from the directory containing a given file to the root of your filesystem. For example, if you have the following setup:  / |- projects/ |- project_a/ | |- b/ | | |- c.py | |- d.py |- project_e/ |- f.py   c.py's fallback search path would be ['/projects/project_a/b', '/projects/project_a', '/projects', '/']  d.py could be importable with the paths d, project_a.d, or projects.project_a.d.f.py could be importable with the paths project_e.f or projects.project_e.f.  e.py's fallback search path would be ['/projects/project_a', '/projects', '/']  c.py could be importable with the paths b.c, project_a.b.c, or projects.project_a.b.cf.py could be importable with the paths project_e.f or projects.project_e.f  f.py's fallback search path would be ['/projects/project_e', '/projects', '/']  c.py could be importable with the paths project_a.b.c or projects.project_a.b.cd.py could be importable with the paths project_a.d or projects.project_a.d  ","version":"Next","tagName":"h3"},{"title":"Site Package Path‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#site-package-path","content":" The site package path (see site-package-path in configuration docs) consists of several entries representing third-party packages.  Site package path from a config file (if no CLI override is present) or CLI args.A site package path queried from a Python interpreter, if one could be found. See Environment Autoconfigurationfor more information on finding interpreters.  ","version":"Next","tagName":"h3"},{"title":"Stub Files vs Source Files‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#stub-files-vs-source-files","content":" Astub fileis any file that ends with a .pyi file suffix. They have many uses, including adding typing to non-Python extension code, distributing typing information separate from implementation, or overriding an implementation with more accurate typing information.  A stub package is a second package corresponding to a regular package, with -stubsappended to its name. A -stubs package should only include stub files (.pyi), which override any .py or .pyi files in the non-stubs package. These are preferred when available, since they contain the interfaces a library exposes to developers. An example of this includes the popular library pandas, and its stub package, pandas-stubs.  When importing from a non-stubs package, Pyrefly loads typing information from imports by first searching for a relevant -stubs package, then by looking at the non-stubs package's .pyi files, then falls back to a .py file. SeeAbsolute Imports for details on when non-stubs packages are allowed to be used for types, and how you can override that behavior.  ","version":"Next","tagName":"h2"},{"title":"Bundled Third Party Stubs‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#bundled-third-party-stubs","content":" Pyrefly bundles stubs for several popular third party libraries along with its binary which are used for type checking and IDE features. These bundled stubs have special import resolution rules which differ from how installed stubs might be treated. The decision tree below describes the scenarios in which third party stubs are used.  - Pyrefly config file present? - Yes - Is the package installed? - Yes - Are stubs installed by user? - Yes Installed stubs are used. - No UntypedImport error. - No MissingImport error. - No - Is the package installed? - Yes Bundled stubs used. - No MissingSourceForStubs error.   ","version":"Next","tagName":"h2"},{"title":"Editable Installs‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#editable-installs","content":" When using static analysis tools with an editable install, the editable install should be configured to use .pthfiles that contain file paths (/project/src/module) rather than executable lines (started with import) that install import hooks. See setuptools docand PEP 660 for more information.  Import hooks can provide an editable installation that offers a more accurate representation of the actual installation environment. However, since resolving module locations through an import hookrequires executing Python code at runtime, they are incompatible with Pyrefly and other static analysis tools that operate without code execution. Consequently, when an editable install is configured to use import hooks, Pyrefly will be unable to automatically locate and analyze the corresponding source files, resulting in incomplete type checking and code analysis.  Setuptools build system uses import hooks by default for editable installations. To ensure compatibility between setuptools-based editable installs and Pyrefly, setuptools must be configured to use path-based .pth files instead. This configuration should be performed through the build frontend (such as pip) by specifying the appropriate options during installation or in the project's configuration files.  ","version":"Next","tagName":"h2"},{"title":"uv with setuptools‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#uv-with-setuptools","content":" When using uv with setuptools, uv can beconfigured to avoid import hooks.  NOTE: The uv_build backend always uses path-based .pth files.  ","version":"Next","tagName":"h3"},{"title":"pip with setuptools‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#pip-with-setuptools","content":" When using pip with setuptools-based projects, there are two ways to avoid import hooks:compat modeand strict mode.  ","version":"Next","tagName":"h3"},{"title":"Hatch / Hatchling‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#hatch--hatchling","content":" Hatchling uses path-based .pth files by default. It will only use import hooks if you set dev-mode-exact to true.  ","version":"Next","tagName":"h3"},{"title":"PDM‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#pdm","content":" PDM uses path-based .pth files by default. It will only use import hooks if you seteditable-backend to &quot;editables&quot;.  ","version":"Next","tagName":"h3"},{"title":"Poetry / Poetry-core‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#poetry--poetry-core","content":" Poetry-core backend always uses path-based .pth files.  ","version":"Next","tagName":"h3"},{"title":"Debugging Import Issues‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#debugging-import-issues","content":" Pyrefly has a dump-config command that dumps the import-related config options it is using for each file it is checking. To use it, simply replace check with dump-config in your command-line invocation. ","version":"Next","tagName":"h2"},{"title":"Add Pyrefly to your IDE","type":0,"sectionRef":"#","url":"/en/docs/IDE/","content":"","keywords":"","version":"Next"},{"title":"Quick start‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#quick-start","content":" Install the Pyrefly extension from the VS Code Marketplace or Open VSX.Open any Python file and the extension will activate automatically.  tip Not seeing inlay hints in VS Code? Try setting editor.inlayHints.enabled to true in your VS Code settings.  tip Want type error squiggles to show up in your editor by default? Try setting python.pyrefly.displayTypeErrors to &quot;force-on&quot; in your editor settings, create a pyrefly.toml file in your project root, or add a [tool.pyrefly] section to your pyproject.toml (can be empty).  ","version":"Next","tagName":"h2"},{"title":"Customization‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#customization","content":" By default, Pyrefly should work in the IDE with no configuration necessary. But to ensure your project is set up properly, see configurations.  The following configuration options are IDE-specific and exposed as VSCode settings:  Disable all language services python.pyrefly.disableLanguageServices [boolean: false]: By default, Pyrefly will provide both type errors and other language features like go-to definition, intellisense, hover, etc. Set disableLanguageServices to true to keep type errors from Pyrefly unchanged but use VSCode's Python extension for everything else. Disable certain language services python.pyrefly.disabledLanguageServices [json: ]: a config to disable certain lsp methods from pyrefly. For example, if you want go-to definition but not find-references. Disable type errors python.pyrefly.displayTypeErrors [enum: default, force-on, force-off, error-missing-imports]: If 'default', Pyrefly will only provide type checking diagnostics in the IDE if your file is covered by a Pyrefly configuration. If 'force-off', Pyrefly will never provide type check diagnostics in the IDE. If 'force-on', Pyrefly will always provide type check diagnostics in the IDE. If 'error-missing-imports', Pyrefly will only show errors for missing imports and missing sources (missing-import, missing-source, and missing-source-for-stubs). Note that syntax errors (invalid-syntax and parse-error) are shown by default in every mode besides force-off. Specify a custom Pyrefly Binary (lspPath) pyrefly.lspPath [string: '']: If your platform is not supported, you can build pyrefly from source and specify the binary path with the lspPath config. Use a specific interpreter If the Python VSCode extension is installed, selecting an interpreter will override the interpreter and settings Pyrefly uses to type check your project, even if one is specified in your Pyrefly configuration.python.defaultInterpreterPath will override the default interpreter selected by VSCode for your workspace. Control hover tooltip links python.analysis.showHoverGoToLinks [boolean: true]: Controls whether hover tooltips include &quot;Go to definition&quot; and &quot;Go to type definition&quot; navigation links. Set to false for cleaner tooltips with only type information. Control comment section folding pyrefly.commentFoldingRanges [boolean: false]: Controls whether comment section folding ranges are included in the editor. When true, comments following the pattern # Section Name ---- (with 4+ trailing dashes) create collapsible regions, similar to R's code section convention. Set to true to enable this feature.  When used with non-VSCode editors, these options can also be configured by sending them via initializationOptions in the LSP initialization request.  Below is an example of a value that can be passed for initializationOptions:  { &quot;pythonPath&quot;: &quot;/usr/bin/python3&quot;, &quot;commentFoldingRanges&quot;: true, &quot;pyrefly&quot;: { &quot;displayTypeErrors&quot;: &quot;default&quot;, &quot;disableLanguageServices&quot;: false, &quot;extraPaths&quot;: [&quot;/path/to/extra/modules&quot;], &quot;analysis&quot;: { &quot;diagnosticMode&quot;: &quot;workspace&quot;, &quot;importFormat&quot;: &quot;absolute&quot;, &quot;inlayHints&quot;: { &quot;callArgumentNames&quot;: &quot;off&quot;, &quot;functionReturnTypes&quot;: true, &quot;pytestParameters&quot;: false, &quot;variableTypes&quot;: true }, &quot;showHoverGoToLinks&quot;: true }, &quot;disabledLanguageServices&quot;: { &quot;definition&quot;: false, &quot;declaration&quot;: false, &quot;typeDefinition&quot;: false, &quot;codeAction&quot;: false, &quot;completion&quot;: false, &quot;documentHighlight&quot;: false, &quot;references&quot;: false, &quot;rename&quot;: false, &quot;signatureHelp&quot;: false, &quot;hover&quot;: false, &quot;inlayHint&quot;: false, &quot;documentSymbol&quot;: false, &quot;semanticTokens&quot;: false, &quot;implementation&quot;: false } } }   ","version":"Next","tagName":"h2"},{"title":"Issues?‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#issues","content":" If you experience issues with the Pyrefly extension, please create an issue on github.  ","version":"Next","tagName":"h2"},{"title":"Other Editors‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#other-editors","content":" Support for other editors is community-driven. If you would like to set this up, please contribute.  ","version":"Next","tagName":"h2"},{"title":"Antigravity, Windsurf, Cursor and Kiro‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#antigravity-windsurf-cursor-and-kiro","content":" You can use Pyrefly in your favorite AI editor that supports OpenVSX extensions. Search for &quot;Pyrefly&quot; in the extension marketplace and install it. Similar to VSCode, Pyrefly will automatically activate when you open a Python file.  To avoid conflicts, you should disable other Python language servers by either setting &quot;Language Server: None&quot; in the extension settings or by disabling the Pyright or BasedPyright extensions.    ","version":"Next","tagName":"h3"},{"title":"Jetbrains / Pycharm‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#jetbrains--pycharm","content":" PyCharm users can enable native Pyrefly support in the settings:  Go to Python | Tools | Pyrefly in the Settings dialog. Select the Enable checkbox. In the Execution mode setting, select how PyCharm should search for the executable: Interpreter mode: PyCharm searches for an executable installed in your interpreter. To install the Pyrefly package for the selected interpreter, click Install Pyrefly. Path mode: PyCharm searches for an executable in $PATH. If the executable is not found, you can specify the path by clicking the Browse... icon. Select which options should be enabled.  For more information, refer to PyCharm documentation.  ","version":"Next","tagName":"h3"},{"title":"Neovim‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#neovim","content":" Pyrefly supports native Neovim support through lspconfig on Neovim 0.11+. Install and setup Pyrefly using the settings below.  The recommended way to set up Pyrefly in Neovim 0.11+ is:  Install or update the neovim/nvim-lspconfig, mason-org/mason.nvim, and mason-org/mason-lspconfig.nvim plugins with your plugin manager of choice.Add the following to your Neovim init.lua:  require(&quot;mason&quot;).setup() require(&quot;mason-lspconfig&quot;).setup()   In Neovim, run :MasonInstall pyrefly or add pyrefly to your ensure_installed options:  require(&quot;mason-lspconfig&quot;).setup { ensure_installed = { &quot;pyrefly&quot; }, }   Alternative setups and configurations While the above section describes the fastest way to set up Pyrefly, you may already have a setup or prefer to use other approaches for your lspconfig. Below we describe alternatives to both Pyrefly installation and configuration. note We don't provide instructions for setting up Neovim with versions prior to Neovim 0.11, though Pyrefly can work with them through neovim/nvim-lspconfig. Install Pyrefly for Neovim There are two methods we currently support for installing Pyrefly for Neovim: (recommended) Install the mason-org/mason.nvim plugin, which handles installing language services and configuring them easily.Use a system installation. mason.nvim mason.nvim is our recommended approach, since it makes Pyrefly and other language servers, linters, and utilities easily available to Neovim. note Installing a binary with Mason will take precedence over other system installations. It might be worth using system installations (including installations in virtual environments) if you need to switch between different versions of Pyrefly for different projects. Install Mason using your Neovim plugin manager of choice, and make sure you call its setup function to make it available. To install Pyrefly, run :MasonInstall pyrefly in Neovim, and it will be installed! You can install a specific version of Pyrefly with :MasonInstall pyrefly@&lt;version&gt;, and manage Mason installations (including per-language-server-specific settings!) with :Mason. System Installations Pyrefly can also work with Neovim's lspconfig when using a system installation. This will work as long as the Pyrefly binary you want to use is available on your $PATH, which you can check by making sure commands like pyrefly --help succeed. If an installation is available on your $PATH, continue on to configure below. To install Pyrefly, you can use the package manager of your choice. We support uv, pip, Cargo, and anything else that can interface with PyPI (see Installation for more info). note If you're installing Pyrefly into a virtual environment, please be aware that Pyrefly will only work within Neovim if the virtual environment is activated when you start Neovim. Before moving on, double check that you can access Pyrefly on your $PATH. If you can, then continue with configure. If Pyrefly is not available on your $PATH, you can try the following: If you're using a virtual environment, try source .venv/bin/activate to ensure your venv is running, then see if pyrefly is available.If you're using uv, you can ensure uv-installed tools are available on your path by running uv tool update-shell.Configure lspconfig to use a specific executable/command by updating your Pyrefly-specific lspconfig settings. To do this, override the cmd configuration option with your command in the configuration section below. Configure Pyrefly for Neovim This section describes how to tell Neovim how Pyrefly can be run, as well as how to override those settings. You have two options on how to do this: (recommended) Install or update the neovim/nvim-lspconfig plugin to get Pyrefly's (and other language servers') default configs. You can override specific settings if you'd like.Setup your language server manually without installing extra plugins. Configs with neovim/nvim-lspconfig plugin neovim/nvim-lspconfig is a Neovim plugin acting as a repository of language server settings (a repository of language server settings) installed and updated to get Pyrefly's default configuration. We also recommend installing or updating the mason-org/mason-lspconfig.nvim plugin if you're using Mason, which provides other nice functionality when using Mason with lspconfig. If you install mason-org/mason-lspconfig.nvim, be sure to source it in your Neovim config. To override specific settings, see :h vim.lsp.config. See :h vim.lsp.Config and :h vim.lsp.ClientConfig for values you can override, and the nvim-lspconfig Pyrefly config for default values. Example overriding cmd and filetypes vim.lsp.config('pyrefly', { -- example of how to run `uv` installed Pyrefly without adding to your path cmd = { 'uvx', 'pyrefly', 'lsp' } }) No-plugin Configs You have the option to setup your language server withoutneovim/nvim-lspconfig. Simply copy/modify the Pyrefly defaults fromnvim-lspconfigin a block like below. **NOTE: This should be in a file under nvim/lsp/pyrefly.lua ---@type vim.lsp.Config return { cmd = { &quot;pyrefly&quot;, &quot;lsp&quot; }, } tip This Youtube tutorial explains setting up a language server in more depth and with a more organized setup, so check it out if you want to learn more. info Want type error squiggles to show up in your editor by default? You can create a pyrefly.toml in your project root, add a [tool.pyrefly] section in your pyproject.toml, or add the following to the config object passed into vim.lsp.config. { settings = { python = { pyrefly = { displayTypeError = 'force-on' } } } } Enable Pyrefly for Neovim If you've installed Pyrefly with Mason and have mason-org/mason-lspconfig.nvim installed, then your language server should just work! You can check by opening a file your language server should cover and running :checkhealth lsp to see if it's started. You may need to restart Neovim for any changes made above to take effect. Otherwise, to make sure your language servers are activated, be sure to enable them with the syntax below. vim.lsp.enable({&quot;pyrefly&quot;}) tip If you're using init.vim, you can use a lua heredoc to execute lua and enable your config.  ","version":"Next","tagName":"h3"},{"title":"Vim/Neovim + coc.nvim‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#vimneovim--cocnvim","content":" Ensure the pyrefly is on $PATH, add following snippet to your coc-settings.json:  &quot;languageserver&quot;: { &quot;pyrefly&quot;: { &quot;command&quot;: &quot;pyrefly&quot;, &quot;args&quot;: [&quot;lsp&quot;], &quot;filetypes&quot;: [&quot;python&quot;], &quot;rootPatterns&quot;: [&quot;pyrefly.toml&quot;, &quot;pyproject.toml&quot;, &quot;.git&quot;], } },   tip Type errors aren't shown unless a configuration exists. To always display type errors with coc.nvim, add the following initializationOptions to your configuration: &quot;languageserver&quot;: { &quot;pyrefly&quot;: { &quot;command&quot;: &quot;pyrefly&quot;, &quot;args&quot;: [&quot;lsp&quot;], &quot;filetypes&quot;: [&quot;python&quot;], &quot;rootPatterns&quot;: [&quot;pyrefly.toml&quot;, &quot;pyproject.toml&quot;, &quot;.git&quot;], &quot;initializationOptions&quot;: { &quot;pyrefly&quot;: { &quot;displayTypeErrors&quot;: &quot;force-on&quot; } } } } Use &quot;default&quot; to only show type errors when a configuration exists, &quot;force-off&quot; to never show them, or &quot;error-missing-imports&quot; to only show import-related errors - this can help you determine if your Python interpreter is set correctly and all packages are installed.  ","version":"Next","tagName":"h3"},{"title":"Vim + ALE‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#vim--ale","content":" Pull the latest version of ALE and add the following lines to your configuration to enable Pyrefly in Vim with ALE:  let g:ale_linters = { ... \\ 'python': ['pyrefly'], ... \\ }   ","version":"Next","tagName":"h3"},{"title":"Emacs‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#emacs","content":" There are several emacs packages that implement the language server protocol; the eglot package is built into recent versions of emacs. You can tell eglot to use pyrefly (which we assume is on your $PATH) with the following configuration:  (add-to-list 'eglot-server-programs `((python-ts-mode python-mode) . (&quot;pyrefly&quot; &quot;lsp&quot;)))   If you are using use-package, this command would run inside of the :config block; a minimal example would look like this:  (use-package eglot :ensure t :hook ((python-mode python-ts-mode) . eglot-ensure) :config (add-to-list 'eglot-server-programs `((python-ts-mode python-mode) . (&quot;pyrefly&quot; &quot;lsp&quot;))))   ","version":"Next","tagName":"h3"},{"title":"Helix‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#helix","content":" Ensure that pyrefly is on $PATH (If you got Pyrefly using pip install pyrefly, it should already be on your path). Add this snippet to your languages.toml file  [language-server.pyrefly] command = &quot;pyrefly&quot; args = [&quot;lsp&quot;] [[language]] name = &quot;python&quot; language-servers = [&quot;pyrefly&quot;]   ","version":"Next","tagName":"h3"},{"title":"Sublime‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#sublime","content":" See the documentation here.  ","version":"Next","tagName":"h3"},{"title":"Positron‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#positron","content":" Positron comes with Pyrefly out of the box. See the documentation here.  ","version":"Next","tagName":"h3"},{"title":"Jupyter Lab‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#jupyter-lab","content":" Pyrefly may be used in Jupyter Lab through the jupyterlab-lsp extension.  ","version":"Next","tagName":"h3"},{"title":"Zed‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#zed","content":" Zed users can install the Pyrefly extension from here or by visiting the extensions marketplace:    Here's an example of a Zed config with Pyrefly integration:  { &quot;lsp&quot;: { &quot;pyrefly&quot;: { &quot;binary&quot;: { &quot;path&quot;: &quot;.venv/bin/pyrefly&quot;, &quot;arguments&quot;: [&quot;lsp&quot;] } } }, &quot;languages&quot;: { &quot;Python&quot;: { &quot;language_servers&quot;: [&quot;pyrefly&quot;], } } }  ","version":"Next","tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/en/docs/installation/","content":"","keywords":"","version":"Next"},{"title":"Install‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#install","content":" You can use uv, poetry, pip, pixi or conda to install Pyrefly. The following commands show you how to install Pyrefly and run 2 basic commands: init and check.  pyrefly init will update your pyproject.toml file (or create a pyrefly.toml file) in your project directory, including some basic configuration. It will also attempt to migrate your existing type checker configuration.pyrefly check --summarize-errors will run the Pyrefly type checker on your project, providing a list of type errors and a summary of error types. The --summarize-errors flag is optional, remove it if you don't want summary stats.pyrefly suppress will mark all existing errors as ignored, allowing you to start with a clean check. (You can also use pyrefly check --suppress-errors.)  Simply cd into your project directory and run:    PipCondauvPoetryPixi pip install pyrefly pyrefly init pyrefly check --summarize-errors   ","version":"Next","tagName":"h2"},{"title":"Configure‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#configure","content":" You can set up a basic configuration file to type-check your project. You can add configuration options to a pyproject.toml file or create a pyrefly.toml file in your project directory. All configuration options are documented here.  [tool.pyrefly] search_path = [ &quot;example_directory/...&quot; ]   Then, run pyrefly check again, and the tool will use your configuration options.  The tool may return a list of type errors; this is perfectly normal. You have a few options at this point:  Use # pyrefly: ignore comments to silence the errors. This will get your project to a clean type-checking state, and you can reduce the number of errors as you go. We've included a command that can do this for you:  pyrefly suppress   Use extra configuration options to silence specific categories of errors or exclude files with more errors than average.    ","version":"Next","tagName":"h2"},{"title":"Upgrading Pyrefly‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#upgrading-pyrefly","content":" Upgrading the version of Pyrefly you're using or a third-party library you depend on can reveal new type errors in your code. Fixing them all at once is often unrealistic. We've written scripts to help you temporarily silence them.  # Step 1 pyrefly suppress   # Step 2 &lt;run your formatter of choice&gt;   # Step 3 pyrefly suppress --remove-unused   Repeat these steps until you achieve a clean formatting run and a clean type check.  This will add # pyrefly: ignore comments to your code, enabling you to silence errors and return to fix them later. This can make the process of upgrading a large codebase much more manageable.    ","version":"Next","tagName":"h2"},{"title":"Add Pyrefly to CI‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#add-pyrefly-to-ci","content":" After your project passes type checks without errors, you can prevent new bugs from being introduced. Enforce this through CI (Continuous Integration) to prevent other maintainers from merging code with errors. Here is an example for GitHub.  Save your workflow in the following path within your repository:  .github/workflows/typecheck.yml   GitHub automatically detects .yml files within .github/workflows/ and sets up the defined workflows.  name: Pyrefly Type Check on: pull_request: branches: [main] workflow_dispatch: # Allows manual triggering from the GitHub UI jobs: typecheck: runs-on: ubuntu-latest steps: - name: Check out code uses: actions/checkout@v4 - name: Set up Python uses: actions/setup-python@v5 # Install Python dependencies and create environment - name: Install dependencies and run type checking run: | python -m venv .venv source .venv/bin/activate python -m pip install --upgrade pip # Install your dependencies; adjust the following lines as needed pip install -r requirements-dev.txt - name: Install Pyrefly run: pip install pyrefly - name: Run Pyrefly Type Checker run: pyrefly check   ","version":"Next","tagName":"h2"},{"title":"Inline PR Annotations‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#inline-pr-annotations","content":" Pyrefly can emit errors as GitHub Actions workflow commands so that type errors appear inline when reviewing pull requests.  To enable this, pass --output-format=github:   - name: Run Pyrefly Type Checker run: pyrefly check --output-format=github   ","version":"Next","tagName":"h3"},{"title":"A few notes about this setup:‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#a-few-notes-about-this-setup","content":" Building your environment and installing dependencies will enhance type safety by checking the types of imports. This is not required, but encouraged!Simply drop in pyrefly check to existing workflows that build and test your environment.   - name: Run Pyrefly Type Checker run: pyrefly check   Your pyrefly.toml or Pyrefly configs in your pyproject.toml will be automatically detected. Learn how to configure Pyrefly here.    ","version":"Next","tagName":"h3"},{"title":"Pre-commit‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#pre-commit","content":" Pyrefly provides a pre-commit hook so you can automatically type check files before they are committed.  We maintain a dedicated repository for this integration here: facebook/pyrefly-pre-commit  That repository contains:  A pre-commit hookInstallation instructionsExample configuration snippets for your project and CI  To get started, follow the setup steps in the repo‚Äôs README. ","version":"Next","tagName":"h2"},{"title":"Migrating from Mypy","type":0,"sectionRef":"#","url":"/en/docs/migrating-from-mypy/","content":"","keywords":"","version":"Next"},{"title":"Running Pyrefly‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#running-pyrefly","content":" Like mypy, pyrefly can be given a list of files to check:  $ pyrefly check file1.py file2.py   The easiest way to run pyrefly on all files in a project is to run it from the project root:  $ cd your/project $ pyrefly check   Pyrefly is designed to have sensible defaults, and you may not need to configure it at all. However, projects with existing mypy configs may want to configure pyrefly to suit their own needs.  ","version":"Next","tagName":"h2"},{"title":"Mypy Config Migration‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#mypy-config-migration","content":" To make it as easy as possible to get started with pyrefly, we've provided a script for automatically migrating a mypy config to pyrefly.  $ pyrefly init path/to/your/project   This will search for an existing mypy.ini or pyproject.toml with a tool.mypy section, and then transform it into a pyrefly.toml (or [tool.pyrefly] section) while preserving as many options as possible. See init --help for more options.  We do recommend checking the resulting config for errors. While there is some overlap between mypy's config options and pyrefly's config options, it's not always possible to cleanly translate one config option to another.  If you'd rather start fresh with a hand-written config, please see the pyrefly configuration docs. If you run into any issues with config migration, please let us know!  ","version":"Next","tagName":"h2"},{"title":"Config options‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#config-options","content":" The following config options make Pyrefly behave more like Mypy:  # By default, mypy does not check unannotated function bodies. The following flag will configure Pyrefly to match mypy's behavior: untyped_def_behavior = &quot;skip-and-infer-return-any&quot;   # If mypy is configured with `--check-untyped-defs` or `--strict` it will check function bodies where the function signature is unannotated. # The following flag will enable this behavior: untyped_def_behavior = &quot;check-and-infer-return-any&quot;   # Direct Pyrefly to respect `# mypy: ignore` and `# mypy: ignore-errors` comments permissive-ignores = true   ","version":"Next","tagName":"h3"},{"title":"Config Migration Details‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#config-migration-details","content":" files, modules, and packages are combined into project_includes. This should work exactly the same for files and packages. Mypy doesn't recurse into modules, but pyrefly will.  Pyrefly makes an effort to transform the exclude regex into a list of filepath globs for project_excludes. This should excel on simple regexes, such as some/file.py|exclude_dir/, which becomes [&quot;**/some/file.py&quot;, &quot;**/exclude_dir/&quot;].  The ignore_missing_imports per-module config option is turned into a list of modules. For example:  [mypy-some.*.module] ignore_missing_imports = True   Becomes:  replace_imports_with_any = [&quot;some.*.module&quot;]   Mypy's follow_imports = &quot;skip&quot; is handled the same way.  Pyrefly does support mypy's module name pattern syntax: see Module Globbing in the configuration docs.  Mypy's follow_untyped_imports option is allowed to be global or per-module. The pyrefly equivalent, use_untyped_imports, is only global. This setting defaults to true unless the follow_untyped_imports is disabled in the [mypy] section of the migrated config.  ","version":"Next","tagName":"h3"},{"title":"Mypy Error Codes and Pyrefly Error Kinds‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#mypy-error-codes-and-pyrefly-error-kinds","content":" Pyrefly maps Mypy's error codes to equivalent pyrefly error kinds. While not every error code has an equivalent error kind, we make an effort to ensure that pyrefly suppresses the same errors that mypy does.  This may lead to overly broad error suppressions, and you may want to consider removing some error kinds from the disable list. You can also use a SubConfig to selectively silence errors in specific files, or see Silencing Errors for how to suppress errors at the source.  See Error Kind Mapping for a table showing the relationship between type check diagnostic settings and error kinds.  ","version":"Next","tagName":"h3"},{"title":"Per-Module configs‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#per-module-configs","content":" Mypy's per-module configs let you change a wide range of configuration options for modules matching a module wildcard. Pyrefly's SubConfigs are a similar mechanism that let you configure pyrefly's behavior for files matching a filepath glob. However, they support significantly fewer options, and only disable_error_code and enable_error_code will be migrated over to the pyrefly config.  ","version":"Next","tagName":"h3"},{"title":"Silencing Errors‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#silencing-errors","content":" Like mypy, pyrefly has ways to silence specific error codes. Full details can be found in the Error Suppression docs  To silence an error on a specific line, add a disable comment above that line. You can either suppress all errors on that line:  # pyrefly: ignore x: str = 1   Or target a specific error type:  # pyrefly: ignore[bad-assignment] x: str = 1   To suppress all instances of an error, disable that error in the config:  [errors] missing-import = false   This is equivalent to mypy's disable_error_code, though of course the error codes are different!  ","version":"Next","tagName":"h2"},{"title":"Error Kind Mapping‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#error-kind-mapping","content":" This table shows the mapping between mypy's error codes and pyrefly's error kinds.  This table will be expanded as more diagnostics are supported.  Mypy\tPyreflyattr-defined\tmissing-attribute union-attr\tmissing-attribute ","version":"Next","tagName":"h3"},{"title":"Migration Guides","type":0,"sectionRef":"#","url":"/en/docs/migrating-to-pyrefly/","content":"","keywords":"","version":"Next"},{"title":"Migration Guides‚Äã","type":1,"pageTitle":"Migration Guides","url":"/en/docs/migrating-to-pyrefly/#migration-guides","content":" Migrating from Mypy - Guide for transitioning from Mypy to PyreflyMigrating from Pyright - Guide for transitioning from Pyright to Pyrefly  Choose the appropriate guide based on your current type checker to get started with your migration to Pyrefly. ","version":"Next","tagName":"h2"},{"title":"Pydantic Lax Mode Type Conversions","type":0,"sectionRef":"#","url":"/en/docs/pydantic-lax-conversions/","content":"","keywords":"","version":"Next"},{"title":"Atomic Type Conversions‚Äã","type":1,"pageTitle":"Pydantic Lax Mode Type Conversions","url":"/en/docs/pydantic-lax-conversions/#atomic-type-conversions","content":" Named unions are used for atomic types to keep type signatures concise.  Input Type\tNamed Union\tExpanded Typeint\tLaxInt\tint | bool | float | str | bytes | Decimal float\tLaxFloat\tint | bool | float | str | bytes | Decimal bool\tLaxBool\tbool | int | float | str | Decimal Decimal\tLaxDecimal\tDecimal | int | float | str str\tLaxStr\tstr | bytes | bytearray bytes\tLaxBytes\tstr | bytes | bytearray date\tLaxDate\tdate | datetime | int | float | str | bytes | Decimal datetime\tLaxDatetime\tdate | datetime | int | float | str | bytes | Decimal time\tLaxTime\ttime | int | float | str | bytes | Decimal timedelta\tLaxTimedelta\ttimedelta | int | float | str | bytes | Decimal Path\tLaxPath\tPath | str UUID\tLaxUuid\tUUID | str None\t(no conversion)\tNone    ","version":"Next","tagName":"h2"},{"title":"Compositional Type Conversions‚Äã","type":1,"pageTitle":"Pydantic Lax Mode Type Conversions","url":"/en/docs/pydantic-lax-conversions/#compositional-type-conversions","content":" Notation:  T_converted means the type T is recursively converted using lax mode rules (e.g., int ‚Üí LaxInt)T_flattened means the type T is converted and expanded (e.g., int ‚Üí int | bool | float | str | bytes | Decimal)  Input Type/Container\tOutput Type/Containertype[T]\ttype[T_converted] T1 | T2 | ...\tT1_flattened | T2_flattened | ... list[T], set[T], frozenset[T], Sequence[T], Iterable[T], deque[T], tuple[T, ...]\tIterable[T_converted] tuple[T1, T2, ...]\tIterable[T1_flattened | T2_flattened | ...] dict[K, V]\tMapping[K, V_converted]  Examples:  Type wrapper: type[int] ‚Üí type[LaxInt]Union types: Each member is converted and flattened. int | bool ‚Üí int | bool | float | str | bytes | DecimalSingle-element containers and unbounded tuples: Named unions are preserved. list[int] ‚Üí Iterable[LaxInt]Concrete tuples: Element types are expanded and flattened. tuple[int, str] ‚Üí Iterable[int | bool | float | str | bytes | bytearray | Decimal]Dictionaries: Only values are converted; keys remain unchanged. dict[str, int] ‚Üí Mapping[str, LaxInt] ","version":"Next","tagName":"h2"},{"title":"Migrating from Pyright","type":0,"sectionRef":"#","url":"/en/docs/migrating-from-pyright/","content":"","keywords":"","version":"Next"},{"title":"Running Pyrefly‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#running-pyrefly","content":" Like pyright, pyrefly can be given a list of files to check:  $ pyrefly check file1.py file2.py   The easiest way to run pyrefly on all files in a project is to run it from the project root:  $ cd your/project $ pyrefly check   Pyrefly doesn't need a config file to start checking your code. Its sensible defaults are designed to work well for most projects. However, projects with existing pyright configs may want to configure pyrefly to suit their own needs.  ","version":"Next","tagName":"h2"},{"title":"Pyright Config Migration‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#pyright-config-migration","content":" To make it as easy as possible to get started with pyrefly, we've provided a script for automatically migrating a pyright config to pyrefly.  $ pyrefly init path/to/your/project   This will search for an existing pyrightconfig.json or pyproject.toml with a tool.pyright section, and then transform it into a pyrefly.toml (or [tool.pyrefly] section) while preserving as many options as possible. See init --help for more options.  There is a significant overlap between pyright's and pyrefly's configuration options, so migration is pretty straightforward. However, it may be worth checking the generated config for errors, just in case.  If you'd rather start fresh with a hand-written config, please see the pyrefly configuration docs. If you run into any issues with config migration, please let us know!  ","version":"Next","tagName":"h2"},{"title":"Config Migration Details‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#config-migration-details","content":" When it comes to listing files, pyright uses just paths, while pyrefly supports glob patterns. Thankfully, paths are a subset of glob patterns, so pyrefly can just use the paths as-is. You could consider manually simplifying the paths into glob patterns, but it's not necessary.  Pyright supports four platforms: Windows, Linux, Darwin (macOS), and All. Since pyrefly only supports Python's supported platforms, we choose to treat &quot;All&quot; as &quot;linux&quot;.  ","version":"Next","tagName":"h2"},{"title":"Type Check Diagnostic Settings and Error Kinds‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#type-check-diagnostic-settings-and-error-kinds","content":" Pyrefly maps pyright's type check diagnostics settings to equivalent pyrefly error kinds. While not every diagnostic setting has an equivalent error kind, we make an effort to ensure that pyrefly suppresses the same errors that pyright does.  This may lead to overly broad error suppressions, and you may want to consider removing some error kinds from the disable list. You can also use a SubConfig to selectively silence errors in specific files, or see Silencing Errors for how to suppress errors at the source.  See Error Kind Mapping for a table showing the relationship between type check diagnostic settings and error kinds.  ","version":"Next","tagName":"h3"},{"title":"Execution Environments‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#execution-environments","content":" Pyright's execution environments let you customize the Python version, platform, module search paths, and diagnostic settings for some part of your project. Pyrefly's SubConfigs are a similar mechanism that let you configure pyrefly's behavior for files matching a filepath glob. However, subconfigs do not support changing the Python version, platform, or module search paths.  Diagnostic settings are carried over to the equivalent subconfig, using the mapping mentioned above.  ","version":"Next","tagName":"h3"},{"title":"Extending Builtins‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#extending-builtins","content":" Pyright automatically imports any builtins defined in __builtins__.pyi at the project root or in a custom stubs directory specified by stubPath (defaulting to ./typings).  Pyrefly supports this behavior - the directory for stubPath should be added to your Pyrefly config's site-package-path.  ","version":"Next","tagName":"h3"},{"title":"Silencing Errors‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#silencing-errors","content":" Like pyright, pyrefly has ways to silence specific error codes. Full details can be found in the Error Suppression docs.  To silence an error on a specific line, add a disable comment above that line. You can either suppress all errors on that line:  # pyrefly: ignore x: str = 1   Or target a specific error type:  # pyrefly: ignore[bad-assignment] x: str = 1   To suppress all instances of an error, disable that error in the config:  [errors] missing-import = false   This is similar to pyright's type check rule overrides, though of course the error codes are different!  You can also use:  permissive-ignores = true   To allow pyright: ignore comments to be used by Pyrefly.  ","version":"Next","tagName":"h2"},{"title":"Error Kind Mapping‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#error-kind-mapping","content":" This table shows the mapping between pyright's type check diagnostics settingsand pyrefly's error kinds.  This table will be expanded as more diagnostics are supported.  Pyright\tPyreflyreportMissingImports\tmissing-import reportMissingModuleSource\tmissing-import ","version":"Next","tagName":"h2"},{"title":"Experimental Pydantic Support","type":0,"sectionRef":"#","url":"/en/docs/pydantic/","content":"","keywords":"","version":"Next"},{"title":"Feedback‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#feedback","content":" We welcome your feedback and suggestions. Please share your thoughts and ideas here.    ","version":"Next","tagName":"h3"},{"title":"What is Pydantic?‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#what-is-pydantic","content":" Pydantic is a Python library designed for data validation and parsing using Python type annotations. While it shares similarities with dataclasses in creating structured data containers, Pydantic additionally provides extensive runtime data validation.    ","version":"Next","tagName":"h2"},{"title":"How Pyrefly Supports Pydantic‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#how-pyrefly-supports-pydantic","content":" Understands Pydantic constructs like BaseModel, Field, ConfigDict, and model-level config options.Performs static analysis that mirrors Pydantic's runtime validation logic, minimizing false positives in your IDE.Provides immediate feedback (e.g. red squiggles or type errors) when the code would fail under Pydantic's actual behavior.Does not require a plugin or manual config ‚Äî support is builtin and automatic.    ","version":"Next","tagName":"h2"},{"title":"Validation Modes‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#validation-modes","content":" Pydantic models can use two validation modes:  Lax (Default): Values are automatically coerced when possible. For example, a string like &quot;123&quot; can be coerced to an integer.Strict: Coercion is disabled, and only exactly matching types are accepted.  Pyrefly reads your model config to determine the validation mode, so it can strike a balance between providing useful typing and IDE support while maintaining Pydantic's flexibility.  ","version":"Next","tagName":"h2"},{"title":"How Lax Mode Works in Pyrefly‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#how-lax-mode-works-in-pyrefly","content":" In lax mode (the default), Pyrefly uses named union types to represent the acceptable input types for each field. These named unions keep type signatures concise and readable while closely reflecting Pydantic's runtime coercion behavior.  For example, when you define a field with type int in lax mode, Pyrefly represents it as LaxInt, which is equivalent to int | bool | float | str | bytes | Decimal (based on Pydantic's conversion table):  from pydantic import BaseModel from typing import reveal_type from decimal import Decimal class Model(BaseModel): x: int = 0 reveal_type(Model.__init__) # revealed type is (self: Model, *, x: LaxInt = ..., **Unknown) -&gt; None # int field accepts: int, bool, float, str, bytes, Decimal Model(x=1) Model(x=True) Model(x=1.0) Model(x='123') Model(x=b'123') Model(x=Decimal('123'))   Note: Pyrefly applies named unions (like LaxInt) to atomic types and recursively to nested types. Container types are converted to more general types to handle variance: for example, list[int] becomes Iterable[LaxInt]. When you use union types (e.g., int | bool), each member is expanded individually and then flattened into a regular union.  For a complete reference of all type conversions in lax mode, see the Lax Mode Type Conversions page.    ","version":"Next","tagName":"h3"},{"title":"Comparison to Existing Tools‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#comparison-to-existing-tools","content":" Mypy‚Äôs Pydantic plugin has five configuration options to control how strict the checking is ‚Äî for example, whether coercion is allowed or extra fields are permitted.Pyrefly works differently. It doesn't rely on external config. Instead, it inspects your code directly ‚Äî things like strict=True or extra='forbid' and strikes a balance between Pydantic's flexibility and Pyrefly's type checking.    ","version":"Next","tagName":"h2"},{"title":"How to Use‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#how-to-use","content":" You don‚Äôt need to enable or configure anything to use Pyrefly‚Äôs Pydantic support.  Just:  Install pydantic (preferably v2).Install pyrefly (version 0.33.0 or later).Write your Pydantic models as usual.Run Pyrefly on your code.  Pyrefly will recognize Pydantic constructs like BaseModel, Field, and model_config, and provide appropriate type checking automatically. You can follow this link to try it out on some small examples.    ","version":"Next","tagName":"h2"},{"title":"Supported Features with Examples‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#supported-features-with-examples","content":" The following examples showcase which Pydantic features are currently supported by Pyrefly. Pyrefly does not cover all Pydantic features, but these features should provide good coverage of the most common Pydantic use cases. You can request additional Pydantic features to be supported by opening a GitHub issue.  ","version":"Next","tagName":"h2"},{"title":"Immutable fields with ConfigDict‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#immutable-fields-with-configdict","content":" from pydantic import BaseModel, ConfigDict # Marking a model as frozen (immutable) class Model(BaseModel): model_config = ConfigDict(frozen=True) x: int = 42 m = Model() m.x = 10 # Error: Cannot set field `x` because the model is frozen   ","version":"Next","tagName":"h3"},{"title":"Strict vs Non-Strict Field Validation‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#strict-vs-non-strict-field-validation","content":" from pydantic import BaseModel, Field # Lax mode (default): runtime coercion allowed class User(BaseModel): name: str age: int # This passes at runtime and in Pyrefly because age accepts strings in lax mode y = User(name=&quot;Alice&quot;, age=&quot;30&quot;) # Strict mode: enforce exact types, no coercion class User2(BaseModel): name: str age: int = Field(strict=True) # This triggers type errors in Pyrefly and red squiggles in the IDE, # and will also fail at runtime due to type mismatch. z = User2(name=&quot;Alice&quot;, age=&quot;30&quot;) # Error: age expects int, not str   ","version":"Next","tagName":"h3"},{"title":"Handling Extra Fields in Pydantic Models‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#handling-extra-fields-in-pydantic-models","content":" By default, Pydantic models allow extra fields (fields not defined in the model) to be passed during initialization. This behavior is consistent with Pyrefly‚Äôs support, which follows the default extra='allow' behavior.  from pydantic import BaseModel # Extra fields allowed by default class ModelAllow(BaseModel): x: int # This works fine: extra field `y` is allowed and ignored ModelAllow(x=1, y=2) # Explicitly forbid extra fields by setting `extra='forbid'` class ModelForbid(BaseModel, extra=&quot;forbid&quot;): x: int # This will raise a type error because of unexpected field `y`, which is consistent with runtime behavior. ModelForbid(x=1, y=2)   ","version":"Next","tagName":"h3"},{"title":"Handling field constraints‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#handling-field-constraints","content":" Pyrefly provides limited support for range constraints on fields.  from pydantic import BaseModel, Field class Model(BaseModel): x: int = Field(gt=0, lt=10) Model(x=5) # OK Model(x=0) # Error: Argument value `Literal[0]` violates Pydantic `gt` constraint for field `x` Model(x=15) # Error: Argument value `Literal[15]` violates Pydantic `lt` constraint for field `x`   ","version":"Next","tagName":"h3"},{"title":"Root Models‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#root-models","content":" from pydantic import RootModel, StrictInt class IntRootModel(RootModel[int]): pass class StrictIntRootModel(RootModel[StrictInt]): pass m1 = IntRootModel(123) # OK m2 = IntRootModel(&quot;123&quot;) # OK - lax mode allows string-to-int coercion m3 = StrictIntRootModel(&quot;123&quot;) # Error: StrictInt doesn't allow coercion   ","version":"Next","tagName":"h3"},{"title":"Alias validation‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#alias-validation","content":" from pydantic import BaseModel, Field class Model(BaseModel, validate_by_name=True, validate_by_alias=True): x: int = Field(alias='y') # both `x` and `y` are valid aliases Model(x=0) Model(y=0)  ","version":"Next","tagName":"h3"},{"title":"Pyrefly Frequently Asked Questions","type":0,"sectionRef":"#","url":"/en/docs/pyrefly-faq/","content":"","keywords":"","version":"Next"},{"title":"How do I pronounce Pyrefly?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#how-do-i-pronounce-pyrefly","content":" It's pronounced PIE-ur-fly, rhyming with &quot;firefly.&quot;  ","version":"Next","tagName":"h2"},{"title":"What is the relationship to Pyre?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#what-is-the-relationship-to-pyre","content":" Pyrefly is a ground-up rebuild that doesn‚Äôt share any core type checking code with Pyre. Not only is Pyrefly written in a new language (Rust instead of OCaml), but its design deviates in a major way from Pyre. Rust enables us to deliver substantial performance improvements and support multiple operating systems (including Windows). Beyond the core type checker itself, there are helper tooling and many lessons learned that we will take from Pyre and the community of Python type checking maintainers who have done tremendous work to get the state of type checking to where it is today.  ","version":"Next","tagName":"h2"},{"title":"Is Pyrefly a type checker or a language server?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#is-pyrefly-a-type-checker-or-a-language-server","content":" Yes üòâ  Pyrefly is both of these things, and you can use one without the other if you choose.  type checking: Pyrefly can be used as a standalone type checker - directly run in your terminal, added to your CI or integrated into your IDE via an extension (made possible by leveraging language server capabilities)language server: Pyrefly can be used as a standalone Python language server, integrated into your IDE with all the typical IDE features you would expect (hover, go-to-definition etc.). You can use it with or without type checking enabled.  ","version":"Next","tagName":"h2"},{"title":"Yet another Type Checker! Why not improve the ones adopted by the community already?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#yet-another-type-checker-why-not-improve-the-ones-adopted-by-the-community-already","content":" We are standing on the shoulders of giants. The contributions to Python typing by Mypy, Pyright, Pytype, Pyre and others have been invaluable. We borrowed concepts and learned from them as we rolled our own. Open source conformance matters to us a lot. While we might make some opinionated decisions, we'll adhere to the PEP process. Pyre was the only type checker that could scale for Meta‚Äôs needs and was starting to show its age, so we started with a ground-up rewrite aimed at usability and performance.  We built a custom engine for incremental computation and designed our type-checking algorithm based on years of experience in gradual typing theory and Rust expertise. By open-sourcing this technology we hope it can serve projects of any size well.  ","version":"Next","tagName":"h2"},{"title":"Why Rust?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#why-rust","content":" We would have preferred to write Pyrefly in Python, but we didn't think we could hit our ambitious performance goals using Python today (hopefully future work around free-threaded Python and JIT changes that). After ruling out Python, we wanted something that was safe, cross-platform, compiled to WASM (for a Playground experience). Rust and Go are probably the best choices for those goals, and our team at Meta had more experience with Rust.  ","version":"Next","tagName":"h2"},{"title":"Where do I report bugs?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#where-do-i-report-bugs","content":" Please open an issue on our GitHub page. You can leave feature requests there as well :) Our current goal is to get through our first major milestone, and after that we can look at bugs and features beyond the current roadmap.  ","version":"Next","tagName":"h2"},{"title":"Can I contribute to Pyrefly?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#can-i-contribute-to-pyrefly","content":" Please see the: contributing guidelines.  ","version":"Next","tagName":"h2"},{"title":"How do I know this project won't go unmaintained after a year?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#how-do-i-know-this-project-wont-go-unmaintained-after-a-year","content":" Great question. We have made a substantial investment in Pyrefly, use it internally and aligned open source maintainability as a key principle for starting this project in the first place. We‚Äôre in it for the long haul. Using it is the best way to encourage further investment from our leadership.  ","version":"Next","tagName":"h2"},{"title":"This is cool, I want to learn more about the technical details.‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#this-is-cool-i-want-to-learn-more-about-the-technical-details","content":" See our README.md for the high level design. We plan to add more detailed documentation along with announcements on https://engineering.fb.com  ","version":"Next","tagName":"h2"},{"title":"I don't like Python's Type System. Stop wasting your time.‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#i-dont-like-pythons-type-system-stop-wasting-your-time","content":" Tell us more - seriously! We want to hear your objections to typing. We hope that better tooling, improvements to the type system and well typed libraries will help provide make development easier. If all else fails our fast code navigation and inference algorithm might spark joy in your IDE, so give us a chance.  Curious about something else or just want to chat about bolting types onto Python, join us on Discord. ","version":"Next","tagName":"h2"},{"title":"Python Typing 101","type":0,"sectionRef":"#","url":"/en/docs/python-typing-for-beginners/","content":"","keywords":"","version":"Next"},{"title":"1. What is a Type?‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#1-what-is-a-type","content":" A type is a classification that defines what operations can be performed on a piece of data, what values it can hold, and how it behaves in memory. Types are fundamental to programming because they help ensure that operations on data make sense.  For example:  An int (integer) type can be added, subtracted, or multipliedA str (string) type can be concatenated or splitA list type can be indexed, sliced, or iterated over  Note: These are just examples of common operations for each data type. Python's built-in types support many more operations that are not listed here.  Understanding types helps you predict how your code will behave and avoid runtime errors from trying to perform operations that don't make sense, such as dividing a string by a number.  ","version":"Next","tagName":"h2"},{"title":"2. What is a Type Hint in Python?‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#2-what-is-a-type-hint-in-python","content":" A type hint in Python is a way to indicate the expected data type of a variable, function parameter, or return value. It's a hint to other developers (and to tools like type checkers and IDEs) about what type of data should be used with a particular piece of code.  Type hints are not enforced at runtime by Python itself, but they can be used by third-party tools (like Pyrefly) to catch type-related errors before your code runs. They also serve as documentation, making it easier for others to understand how to use your code. Here's an example of a simple function with type hints:  def greet(name: str) -&gt; None: print(f&quot;Hello, {name}!&quot;)   In this example:  name: str indicates that the name parameter should be a string.-&gt; None specifies that the function doesn't return any value (similar to void in other languages).  ","version":"Next","tagName":"h2"},{"title":"3. Why Bother with Type Hints?‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#3-why-bother-with-type-hints","content":" Python is a dynamically typed language, which means you can write code without declaring types. However, this can lead to bugs or ambiguity in your code.  TL;DR  Catch bugs before running the code.Improve editor autocomplete &amp; refactors.Turn your code into living documentation.  # Without hints ‚Äì is &quot;times&quot; a str, int, or list? def repeat(text, times): return text * times # With hints ‚Äì intent is crystal clear. def repeat(text: str, times: int) -&gt; str: return text * times  In this example:  The first function lacks type hints, making it unclear what types text and times should be. The * operator works differently depending on types (string repetition, list repetition, or multiplication).The second function uses type hints to clearly indicate that text should be a string, times should be an integer, and the function returns a string.This clarity helps prevent bugs like accidentally passing a string for times or using the function incorrectly.  ","version":"Next","tagName":"h2"},{"title":"Can you spot the bug?‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#can-you-spot-the-bug","content":" class Rectangle: width: int height: int def __init__(self, width: int, height: int) -&gt; None: self.width = width self.height = height rect = Rectangle(width=100, height=50) area = rect.width * rect.hieght print(area)   In this example:  The bug is a typo in rect.hieght (should be rect.height).Without type hints, Python would only report this error at runtime when it tries to access the non-existent attribute.With type hints and a tool like Pyrefly, this error would be caught before running the code because the Rectangle class has defined attributes width and height, but not hieght.  Spelling is hard! Let's add the dataclass decorator to our class definition. This will generate a constructor for us, and also add a few other useful methods.  #Pyrefly will catch this spelling error before you run the code from dataclasses import dataclass @dataclass class Rectangle: width: int height: int rect = Rectangle(width=100, height=50) area = rect.width * rect.hieght  In this dataclass example:  The @dataclass decorator automatically generates methods like __init__, __repr__, and __eq__ based on the class attributes.Type hints are used to define the class attributes (width: int, height: int).The same spelling error exists (rect.hieght), but tools like Pyrefly can catch this before runtime because the dataclass clearly defines which attributes exist.This demonstrates how type hints combined with dataclasses provide both convenience and better error detection.  ","version":"Next","tagName":"h3"},{"title":"4. Primitive Types‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#4-primitive-types","content":" Since Python 3.9 you can use all the primitive types directly as annotations.  age: int = 30 height: float = 1.85 name: str = &quot;Tyler Typer&quot; is_admin: bool = False  In this primitive types example:  Each variable is annotated with its expected type (int, float, str, bool).The values assigned match their declared types.These annotations help document the code and allow type checkers to verify that operations on these variables are valid for their types.For example, a type checker would flag an error if you tried age + name since adding an integer and string isn't a valid operation.  You can also specify a parameter as optional by using Optional type, or now with the | None syntax.  # Optional typing example from typing import Optional middle_name: Optional[str] = None # classic nickname: str | None = None # 3.10+ shorthand  In this Optional type example:  Both variables can either be a string or None.Optional[str] is the traditional syntax (pre-Python 3.10).str | None is the newer union syntax introduced in Python 3.10.These annotations tell type checkers that the variable might be None, so they can warn you if you try to perform string operations without checking for None first.  ","version":"Next","tagName":"h2"},{"title":"5. Collections‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#5-collections","content":" ","version":"Next","tagName":"h2"},{"title":"Syntax Examples‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#syntaxexamples","content":" List of numbers list[int] scores: list[int] = [98, 87, 91]Tuple of two floats tuple[float, float] point: tuple[float, float] = (3.0, 4.0)Dict of str -&gt; int dict[str, int] inventory: dict[str, int] = {&quot;apples&quot;: 5}Set of strings set[str] authors: set[str] = {&quot;Bob&quot;, &quot;Eve&quot;}  Since Python 3.9 you can subscript built‚Äëins directly‚Äîno need for from typing import List.  ","version":"Next","tagName":"h3"},{"title":"6. Functions‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#6-functions","content":" # Simple function def add(a: int, b: int) -&gt; int: return a + b  In this basic function example:  Both parameters a and b are annotated as integers.The function is annotated to return an integer (-&gt; int).This tells type checkers that the function should only be called with integers and that the return value should only be used in contexts where an integer is expected.  Default values keep their annotation:  # Function with default value def greet(name: str, polite: bool = True) -&gt; str: return &quot;Hello!&quot; if polite else f&quot;Yo {name}&quot;  In this function with default values:  The name parameter must be a string.The polite parameter is a boolean with a default value of True.The function returns a string.Even though polite has a default value, it still has a type annotation to ensure that if it's explicitly provided, it must be a boolean.  Variable‚Äëlength arguments:  # Variable length functions from collections.abc import Callable Logger = Callable[[str], None] def debug(*msgs: str, log: Logger | None) -&gt; None: for m in msgs: if log is not None: log(m) else: print(m)  In this variable-length arguments example:  Logger is defined as a type alias for a callable that takes a string and returns nothing (None).*msgs: str indicates that the function accepts any number of string arguments.log: Logger | None means the log parameter can be either a Logger function or None.The function is annotated to return None.This demonstrates how to type complex function signatures with variable arguments and function parameters.  ","version":"Next","tagName":"h2"},{"title":"7. Get Type Hint Signals Directly in Your Editor‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#7-get-type-hint-signals-directly-in-your-editor","content":" You can download the Pyrefly extension for VSCode to get type hint signals directly in your IDE.  Next, install Pyrefly and check some code:  # Fast, zero‚Äëconfig pip install pyrefly pyrefly check ./my_sample.py # Check whole directories pyrefly check app/ tests/   Create a pyrefly.toml file to configure your project. Instructions here. ","version":"Next","tagName":"h2"},{"title":"Typing Features and PEPS","type":0,"sectionRef":"#","url":"/en/docs/python-features-and-peps/","content":"Typing Features and PEPS Typing Features and PEPS available in each Python Version. Feature (click PEP for details)\tWhat it adds / looks like\tIntroduced inPEP 484 -- Core type hints &amp; typing module\tdef add(a: int, b: int) -&gt; int:\t3.5 PEP 526 -- Variable annotations\tcount: int = 0\t3.6 PEP 563 -- from __future__ import annotations (lazy eval)\tAnnotations stored as strings\t3.7 (future‚Äëflag) PEP 544 -- Protocols (structural typing)\tclass Jsonable(Protocol): ...\t3.8 PEP 589 -- TypedDict\tclass User(TypedDict): ...\t3.8 PEP 586 -- Literal types\tdef log(level: Literal[&quot;info&quot;,&quot;warn&quot;]): ...\t3.8 PEP 591 -- Final qualifier\tTOKEN: Final[str] = &quot;...&quot;\t3.8 PEP 585 -- Built‚Äëin generics\tlist[int], dict[str, Any]\t3.9 PEP 593 -- Annotated\tx: Annotated[int, &quot;units=px&quot;]\t3.9 PEP 604 -- Union syntax\tint | None\t3.10 PEP 612 -- ParamSpec / Concatenate\tdecorator‚Äësafe generics\t3.10 PEP 613 -- TypeAlias qualifier\tVector: TypeAlias = list[float]\t3.10 PEP 647 -- TypeGuard for narrowing\tdef is_str(x) -&gt; TypeGuard[str]: ...\t3.10 PEP 655 -- Required / NotRequired for TypedDict\toptional vs. mandatory keys\t3.11 PEP 646 -- Variadic generics (TypeVarTuple, Unpack)\ttensor shapes, 2‚ÄëD arrays, ...\t3.11 PEP 673 -- Self type\tfluent APIs: def set(...) -&gt; Self:\t3.11 PEP 681 -- dataclass_transform helper\tlibraries like Pydantic, attrs\t3.11 PEP 695 -- Class‚Äëlevel generics syntax\tclass Box[T]: ...\t3.12 PEP 698 -- @override decorator\tflag intentional overrides\t3.13 PEP 649 -- New deferred‚Äëeval algorithm (replaces PEP 563)\tbecomes the default\t3.14","keywords":"","version":"Next"},{"title":"Pyrefly Report","type":0,"sectionRef":"#","url":"/en/docs/report/","content":"","keywords":"","version":"Next"},{"title":"Usage‚Äã","type":1,"pageTitle":"Pyrefly Report","url":"/en/docs/report/#usage","content":" Run pyrefly report on a file or directory:  pyrefly report path/to/file.py pyrefly report path/to/directory/   The command outputs a JSON object keyed by file path. For each file, the report includes:  Line count ‚Äî the total number of lines in the file.Functions ‚Äî every function and method, including its fully-qualified name, parameter annotations, and return annotation.Classes ‚Äî every class, along with a list of incompletely-annotated attributes (including those inherited from base classes).Suppressions ‚Äî every # pyrefly: ignore[...] comment, with the suppressed error codes.  You can pipe the output to other tools (e.g. jq) or ingest it into dashboards to track annotation coverage over time. ","version":"Next","tagName":"h2"},{"title":"Pyrefly Error Kinds","type":0,"sectionRef":"#","url":"/en/docs/error-kinds/","content":"","keywords":"","version":"Next"},{"title":"abstract-method-call‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#abstract-method-call","content":" This error is raised when code attempts to invoke a method decorated with@abstractmethod. Abstract methods have no implementation, so calling them is always invalid, even if the signature would otherwise match.  from abc import ABC, abstractmethod class Base(ABC): @classmethod @abstractmethod def build(cls) -&gt; &quot;Base&quot;: ... Base.build() # Cannot call abstract method `Base.build` [abstract-method-call]   ","version":"Next","tagName":"h2"},{"title":"annotation-mismatch‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#annotation-mismatch","content":" This error indicates a mismatch between multiple annotations for a single variable. This is relatively uncommon, but it can happen in if-statements:  if some_cond: x: int = 1 else: x: str = &quot;two&quot; # Inconsistent type annotations for x: str, int [annotation-mismatch]   It can be helpful to annotate the variable before branch, especially if there is a useful default value for it. For example:  x: str = &quot;default&quot; if some_cond: x = &quot;actual value&quot;   ","version":"Next","tagName":"h2"},{"title":"assert-type‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#assert-type","content":" An assert-type error is raised when a typing.assert_type() call fails.  This error kind should never be suppressed, since that rather defeats the point of of typing.assert_type().  ","version":"Next","tagName":"h2"},{"title":"bad-argument-count‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-argument-count","content":" This error arises when a function is called with the wrong number of arguments.  def takes_three(one: int, two: int, three: int) -&gt; complex: ... take_three(3, 2) # Expected 1 more positional argument [bad-argument-count]   Note that missing-argument will be raised if pyrefly can identify that specific arguments are missing. As such, this error is more likely to appear when too many args are supplied, rather than too few.  This example shows both kinds of errors:  from typing import Callable def apply(f: Callable[[int, int], int]) -&gt; int: return f(1) # Expected 1 more positional argument [bad-argument-count] apply() # Missing argument `f` in function `apply` [missing-argument]   ","version":"Next","tagName":"h2"},{"title":"bad-argument-type‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-argument-type","content":" This error indicates that the function was called with an argument of the wrong type.  def example(x: int) -&gt; None: ... example(&quot;one&quot;) # Argument `Literal['two']` is not assignable to parameter `x` with type `int` in function `example` [bad-argument-type]   This can also happen with *args and **kwargs:  def bad_args(*args: int) -&gt; None: ... bad_args(1, &quot;two&quot;) # Argument `Literal['two']` is not assignable to parameter with type `int` in function `bad_args` [bad-argument-type]   def bad_kwargs(**kwargs: int) -&gt; None: ... bad_args(x=1, y=&quot;two&quot;) # Keyword argument `y` with type `Literal['two']` is not assignable to kwargs type `int` in function `bad_kwargs` [bad-argument-type]   ","version":"Next","tagName":"h2"},{"title":"bad-assignment‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-assignment","content":" The most common cause of this error is attempting to assign a value that conflicts with the variable's type annotation.  x: str = 1 # `Literal[1]` is not assignable to `str` [bad-assignment]   However, it can occur in several other situations.  Here, x is marked as Final, so assigning a new value to it is an error.  from typing import Final x: Final = 1 x = 2 # `x` is marked final [bad-assignment]   In another case, attempting to annotate an assignment to an instance attribute raises this error.  class A: x: int a = A() a.x: int = 2 # Type cannot be declared in assignment to non-self attribute `a.x` [bad-assignment]   ","version":"Next","tagName":"h2"},{"title":"bad-class-definition‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-class-definition","content":" This error indicates that there is something wrong with the class definition. It tends to be a bit rarer, since most issues would be tagged with other error kinds, such asannotation-mismatch or one of the function errors. inheritance has its own complexities, so it has its own error kind called invalid-inheritance.  One place you may see it is dynamic class generation:  from enum import Enum Ex = Enum(&quot;Ex&quot;, [(&quot;Red&quot;, 1), (&quot;Blue&quot;, 2), (&quot;Red&quot;, 3)]) # Duplicate field `Red` [bad-class-definition]   However, it is best practice to use the class syntax if possible, which doesn't treat duplicate names as an error.  ","version":"Next","tagName":"h2"},{"title":"bad-context-manager‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-context-manager","content":" This error occurs when a type that cannot be used as a context manager appears in a with statement.  class A: def __enter__(self): ... with A(): ... # `A` is missing an `__exit__` method!   ","version":"Next","tagName":"h2"},{"title":"bad-dunder-all‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-dunder-all","content":" This error occurs when __all__ is explicitly defined for a module but contains an entry that cannot be found in the module's definitions, wildcard imports, or submodules (for __init__.py files).  __all__ = [&quot;x&quot;, &quot;y&quot;] # Name `y` is listed in `__all__` but is not defined in the module x = 5   To fix this error, either define the missing name or remove it from __all__:  __all__ = [&quot;x&quot;, &quot;y&quot;] x = 5 y = 10 # Now `y` is defined   ","version":"Next","tagName":"h2"},{"title":"bad-function-definition‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-function-definition","content":" Like bad-class-definition, this error kind is uncommon because other error kinds are used for more specific issues. For example, argument order is enforced by the parser, so def f(x: int = 1, y: str) is a parse-error.  ","version":"Next","tagName":"h2"},{"title":"bad-index‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-index","content":" Attempting to access a container with an incorrect index. This only occurs when Pyrefly can statically verify that the index is incorrect, such as with a fixed-length tuple.  def add_three(x: tuple[int, int]) -&gt; int: return x[0] + x[1] + x[2]   Pyrefly also knows the keys of TypedDicts, but those have their own error kind.  ","version":"Next","tagName":"h2"},{"title":"bad-instantiation‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-instantiation","content":" This error occurs when attempting to instantiate a class that cannot be instantiated, such as a protocol:  from typing import Protocol class C(Protocol): ... C() # bad-instantiation   ","version":"Next","tagName":"h2"},{"title":"bad-keyword-argument‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-keyword-argument","content":" bad-keyword-argument pops up when a keyword argument is given multiple values:  def f(x: int) -&gt; None: pass f(x=1, x=2)   However, this is often accompanied by a parse-error for the same issue.  ","version":"Next","tagName":"h2"},{"title":"bad-match‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-match","content":" This error is used in two cases.  The first is when there is an issue with a match statement. For example, Ex only has 2 fields but the case lists 3:  class Ex: __match_args__ = ('a', 'b') def __init__(self, a: int, b: str) -&gt; None: self.a = a self.b = b def do(x: Ex) -&gt; None: match x: case Ex(a, b, c): print(&quot;This is an error&quot;)   It is also used when __match_args__ is defined incorrectly. It must be a tuple of the names of the class's attributes as literal strings. For class Ex in the previous example, __match_args__ = ('a', 'c') would be an error because Ex.c does not exist.  ","version":"Next","tagName":"h2"},{"title":"bad-override‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-override","content":" When a subclass overrides a field or method of its base class, care must be taken that the override won't cause problems.  Some of these are obvious:  class Base: def f(self, a: int) -&gt; None: pass class NoArg(Base): def f(self) -&gt; None: pass class WrongType(Base): def f(self, a: str) -&gt; None: pass def uses_f(b: Base) -&gt; None: b.f(1)   These errors are rather obvious: uses_f will fail if given a NoArg or WrongType instance, because those methods don't expect an int argument!  The guiding idea here is the Liskov Substitution Principle, the idea that a subclass can stand in for a base class at any point without breaking the program.  This can be a little subtle at first blush. Consider:  class Base: def f(self, a: int) -&gt; None: pass class Sub(Base): def f(self, a: float) -&gt; None: pass   Is this OK? Yes! int is treated as a subclass of float, or to put it another way, a function that accepts float can accept every int. That means everywhere that we call Base.f can safely call Sub.f.  The opposite case, where Base.f takes float and Sub.f takes int, is an error because Sub.f cannot accept every float value.  Note that bad overrides caused by inconsistent parameter names are separately reported as bad-param-name-override.  ","version":"Next","tagName":"h2"},{"title":"bad-param-name-override‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-param-name-override","content":" Arises when a subclass overrides a method of its base class while changing the name of a positional parameter. This is a type of bad override but has a separate error kind so that it can be selectively disabled if desired. Changing the name of a parameter breaks callers that pass in an argument by name:  class Base: def f(self, a: int) -&gt; None: pass class Sub(Base): def f(self, b: int) -&gt; None: pass def f(base: Base): base.f(a=0) f(Sub()) # oops!   ","version":"Next","tagName":"h2"},{"title":"bad-raise‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-raise","content":" In a raise statement of the form raise x from y, x must be an exception, and y must be an exception or None.  def bad_raise() -&gt; None: raise Exception() # ok raise 1 # error raise Exception() from None # ok raise Exception() from Exception() # ok raise Exception() from 1 # error   ","version":"Next","tagName":"h2"},{"title":"bad-return‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-return","content":" Arises when a function does not return a value that is compatible with the function's return type annotation.  def bad_return() -&gt; None: return 1   Real-world examples are often less obvious, of course, due to complex control flow and type relationships.  This error is also raised for generator functions:  from typing import Generator # Generator has 3 types: the yield, send, and return types. def bad_gen() -&gt; Generator[int, None, str]: yield 1 return 2 # should be a str!   ","version":"Next","tagName":"h2"},{"title":"bad-specialization‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-specialization","content":" &quot;Specialization&quot; refers to instantiating a generic type with a concrete type. For example, list is a generic type, and list[int] is that type specialized with int.  Each generic type has an expected number of type vars, and each type var can be bound or constrained. Attempting to use specialize a generic type in a way that violates these specifications will result in a bad-specialization error:  x: list[int, str]   ","version":"Next","tagName":"h2"},{"title":"bad-typed-dict‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-typed-dict","content":" This error is reported when a TypedDict definition includes an unsupported keyword argument. According to the typing specification, the only keyword argument allowed in a TypedDict's base class list is total.  from typing import TypedDict # This is an error because `foo` is not a valid keyword. class InvalidTD(TypedDict, foo=1): x: int # This is valid. class ValidTD(TypedDict, total=False): x: int   ","version":"Next","tagName":"h2"},{"title":"bad-typed-dict-key‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-typed-dict-key","content":" This error arises when TypedDicts are used with incorrect keys, such as a key that does not exist in the TypedDict.  from typing import TypedDict class Ex(TypedDict): a: int b: str def test(x: Ex) -&gt; None: # These two keys don't exist x.nope x[&quot;wrong&quot;] # TypedDict keys must be strings! x[1]   ","version":"Next","tagName":"h2"},{"title":"bad-unpacking‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-unpacking","content":" An error caused by unpacking, such as attempting to unpack a list, tuple, or iterable into the wrong number of variables.  def two_elems() -&gt; tuple[int, str]: return (1, &quot;two&quot;) a, b, c = two_elems()   Note that pyrefly can only report this error if it knows how many elements the thing being unpacked has.  # A bare `tuple` could have any number of elements def two_elems() -&gt; tuple: return (1, &quot;two&quot;) a, b, c = two_elems()   ","version":"Next","tagName":"h2"},{"title":"deprecated‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#deprecated","content":" This warning occurs on usage of a deprecated class or function.  The default severity of this diagnostic is warn.  from warnings import deprecated @deprecated(&quot;deprecated&quot;) def f(): ... f() # deprecated!   ","version":"Next","tagName":"h2"},{"title":"implicit-abstract-class‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#implicit-abstract-class","content":" Pyrefly emits this error when a class defines abstract members but is not declared abstract (for example, it does not inherit from abc.ABC or use abc.ABCMeta). Such classes cannot be instantiated because they have unimplemented abstract methods. Add ABC as a base class, adjust the metaclass, or provide concrete implementations to resolve the issue.  The default severity of this diagnostic is ignore.  ","version":"Next","tagName":"h2"},{"title":"implicit-any‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#implicit-any","content":" This error is emitted when Pyrefly infers an implicit Any type in your code for type variables or generic parameters that cannot be determined. This is common in gradually-typed code, but reduces type safety so we provide this error for users that want to enforce fully-typed codebases.  Typically, it can be fixed by providing explicit type arguments or default values for type variables.  The default severity of this diagnostic is ignore.  # this only errors when first-use inference is disabled x = [] # error: infers list[Any]   ","version":"Next","tagName":"h2"},{"title":"implicit-import‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#implicit-import","content":" A module exists, but was not imported. At runtime, if something has made this import before your code, it will work. But relies on whatever did the import to continue doing it.  import importlib importlib.util.find_spec(&quot;os&quot;) # error, `importlib.util` was not imported   ","version":"Next","tagName":"h2"},{"title":"implicitly-defined-attribute‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#implicitly-defined-attribute","content":" An attribute was implicitly defined by assignment to self in a method that we do not recognize as always executing. We recognize constructors and some test setup methods; we will emit an error for any attributes defined by assignment in other methods.  The default severity of this diagnostic is ignore.  class C: def __init__(self): self.x = 0 # no error, `__init__` always executes def f(self): self.y = 0 # error, `y` may be undefined if `f` does not execute   ","version":"Next","tagName":"h2"},{"title":"inconsistent-inheritance‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#inconsistent-inheritance","content":" When a class inherits from multiple base classes, the inherited fields must be consistent.  Example:  class A: f: str class B: f: int class C(A, B): ... # error, the field `f` is inconsistent   ","version":"Next","tagName":"h2"},{"title":"inconsistent-overload‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#inconsistent-overload","content":" The signature of a function overload is inconsistent with the implementation. See the typing specificationfor details on the consistency checks Pyrefly performs.  Example:  from typing import overload @overload def f(x: int) -&gt; int: ... @overload def f(x: str) -&gt; str: ... # error, overload accepts `str` but implementation only accepts `int` def f(x: int) -&gt; int | str: return x   ","version":"Next","tagName":"h2"},{"title":"internal-error‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#internal-error","content":" Ideally you'll never see this one. If you do, please consider filing a bug.  ","version":"Next","tagName":"h2"},{"title":"invalid-annotation‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-annotation","content":" There are several reasons why an annotation may be invalid. The most common case is misusing a typing special form, such as typing.Final, typing.ClassVar, typing.ParamSpec, and so on.  from typing import * # Final must have a value a: Final # ClassVar can only be used in a class body b: ClassVar[int] = 1   The error messages will explain how the special form is being misused. Consult the typing docs and typing spec for more information.  ","version":"Next","tagName":"h2"},{"title":"invalid-argument‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-argument","content":" This error is used to indicate an issue with an argument to special typing-related functions.  For example, typing.NewType is a handy special form for creating types that are distinct from a base type.  from typing import * # The first arg must match the name! Mismatch = NewType(&quot;Wrong Name&quot;, int) # NewTypes cannot be used in isinstance. UserId = NewType(&quot;UserId&quot;, int) if isinstance(1, UserId): ...   ","version":"Next","tagName":"h2"},{"title":"invalid-decorator‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-decorator","content":" This error indicates that a decorator was used incorrectly. For example, using @typing.final on a non-method function.  from typing import final @final def f() -&gt; None: pass   ","version":"Next","tagName":"h2"},{"title":"invalid-inheritance‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-inheritance","content":" An error caused by incorrect inheritance in a class or type definition. This can pop up in quite a few cases:  Trying to subclass something that isn't a class.Subclassing a type that does not support it, such as a NewType or a Final class.Attempting to mix Protocols with non-Protocol base classes.Trying to make a generic enum.Trying to give a TypedDict a metaclass.  And so on!  ","version":"Next","tagName":"h2"},{"title":"invalid-literal‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-literal","content":" typing.Literal only allows a limited set of types as parameters. Attempting to use Literal with anything else is an error.  from typing import Literal # These are legal Literal[1.0] Literal['a', 'b', 'c'] # This is not class A: ... Literal[A()]   ","version":"Next","tagName":"h2"},{"title":"invalid-overload‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-overload","content":" The @overload decorator requires that the decorated function has at least two overloaded signatures and a base implementation.  from typing import * @overload def no_base(x: int) -&gt; None: pass @overload def no_base(x: str) -&gt; int: pass   @overload def just_one(x: int) -&gt; None: pass def just_one(x: str) -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"invalid-param-spec‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-param-spec","content":" This error is reported when typing.ParamSpec is defined incorrectly or misused. For example:  from typing import * P = ParamSpec(&quot;Name Must Match!&quot;) P1 = ParamSpec(&quot;P1&quot;) P2 = ParamSpec(&quot;P2&quot;) def f(x, *args: P1.args, **kwargs: P2.kwargs) -&gt; None: pass   Here, P1.args and P2.kwargs can't be used together; *args and **kwargs must come from the same ParamSpec.  ","version":"Next","tagName":"h2"},{"title":"invalid-pattern‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-pattern","content":" This error is reported when a pattern is invalid at runtime. For example, enum members are values, so they must be matched as value patterns (without ()), not class patterns:  from enum import Enum class Color(Enum): RED = &quot;red&quot; def describe(color: Color) -&gt; None: match color: case Color.RED(): # Invalid pattern: use `Color.RED` (without parentheses) pass   ","version":"Next","tagName":"h2"},{"title":"invalid-self-type‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-self-type","content":" This error occurs when Self is used in a context Pyrefly does not currently support.  For example, Pyrefly does not currently allow Self for TypedDict, so the following code would error:  from typing import * class TD(TypedDict): x: Option[Self]   ","version":"Next","tagName":"h2"},{"title":"invalid-super-call‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-super-call","content":" super() has a few restrictions on how it is called.  super() can be called without arguments, but only when used inside a method of a class:  class Legal(Base1, Base2): def f(self) -&gt; None: super().f() def illegal(arg: SomeType) -&gt; None: super().f()   When the function is called with two arguments, like super(T, x), then T must be a type, and the second argument is either an object where isinstance(x, T) is true or a type where issubclass(x, T) is true.  ","version":"Next","tagName":"h2"},{"title":"invalid-syntax‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-syntax","content":" This error covers syntactical edge cases that are not flagged by the parser.  For example:  x: list[int] = [0, 2, 3] x[0]: int = 1   It's not a parse error for an assignment to have an annotation, but it is forbidden by the type checker to annotate assignment to a subscript like x[0].  ","version":"Next","tagName":"h2"},{"title":"invalid-type-alias‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-type-alias","content":" An error related to the definition or usage of a typing.TypeAlias. Many of these cases are covered by invalid-annotation, so this error specifically handles illegal type alias values:  from typing import TypeAlias x = 2 Bad: TypeAlias = x   ","version":"Next","tagName":"h2"},{"title":"invalid-type-var‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-type-var","content":" An error caused by incorrect usage or definition of a TypeVar. A few examples:  from typing import TypeVar # Old-style TypeVars must be assigned to a matching variable. Wrong = TypeVar(&quot;Name&quot;) # PEP 695-style TypeVars can be constrained, but there must be at least two: def only_one_constraint[T: (int,)](x: T) -&gt; T: ... # It's also illegal to mix the two styles together. T = TypeVar(&quot;T&quot;) def mixed[S](a: S, b: T) -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"invalid-type-var-tuple‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-type-var-tuple","content":" An error caused by incorrect usage or definition of a TypeVarTuple.  TypeVarTuple has similar error cases to TypeVar, but also a few of its own. For example:  from typing import TypeVarTuple Ts = TypeVarTuple(&quot;Ts&quot;) # TypeVarTuples must always be unpacked: bad: tuple[Ts] = (...) good: tuple[*Ts] = (...) # Only one TypeVarTuple is allowed in a list of type arguments: def two_tups[*Xs, *Ys](xs: tuple[*Xs], ys: tuple[*Ys]) -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"invalid-variance‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-variance","content":" An error caused by a type variable being used in a position incompatible with its declared variance.  For example, a covariant type variable cannot be used in a contravariant position (such as a method parameter), and a contravariant type variable cannot be used in a covariant position (such as a return type).  from typing import TypeVar, Generic T_co = TypeVar(&quot;T_co&quot;, covariant=True) T_contra = TypeVar(&quot;T_contra&quot;, contravariant=True) class BadCovariant(Generic[T_co]): # Error: covariant type variable used in contravariant position def set_value(self, value: T_co) -&gt; None: ... class BadContravariant(Generic[T_contra]): # Error: contravariant type variable used in covariant position def get_value(self) -&gt; T_contra: ...   ","version":"Next","tagName":"h2"},{"title":"invalid-yield‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-yield","content":" This error arises when yield is used in a way that is not allowed. For example:  from typing import Generator for _ in range(1, 10): yield &quot;can't yield outside of a function!&quot; def bad_yield_from() -&gt; Generator[int, None, None]: # `yield from` can only be used with iterables. yield from 1   ","version":"Next","tagName":"h2"},{"title":"missing-argument‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#missing-argument","content":" An error caused by calling a function without all the required arguments.  def takes_two(x: int, y: int) -&gt; int: return x + y takes_two(1)   ","version":"Next","tagName":"h2"},{"title":"missing-attribute‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#missing-attribute","content":" This error is raised when attempting to access an attribute that does not exist on the given object or module.  In the case of modules, attempting to import an nonexistent name will raise `missing-module-attribute instead.  import os from os import bacarat # missing-module-attribute os.jongleur() # missing-attribute   Note that objects with type Any will never raise this error.  ","version":"Next","tagName":"h2"},{"title":"missing-import‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#missing-import","content":" A module could not be found.  The error message will include which paths were searched, such as the site package paths. You may be missing a dependency, or you may need to inform Pyrefly where the module lives. See Configuration for further information.  ","version":"Next","tagName":"h2"},{"title":"missing-module-attribute‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#missing-module-attribute","content":" Arises when attempting to import a name that does not exist from a module.  This is distinct from missing-import, which is used when the module being imported does not exist, and missing-attribute, when access attributes of the module.  import this_does_not_exist # missing-import import os.bacarat # missing-import from os import joker # missing-module-attribute os.perkeo # missing-attribute   In this example, os.bacarat is treated as a module name, so failing to find it results in an missing-import.from os import joker does not tell us if joker is a module, class, function, etc., so it is treated as the more general missing-module-attribute.  ","version":"Next","tagName":"h2"},{"title":"missing-override-decorator‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#missing-override-decorator","content":" A method overrides a parent class method but does not have the @override decorator.  This error supports strict override enforcement as specified in the typing spec. When enabled, it requires all overriding methods to be explicitly marked with @typing.override.  from typing import override class Base: def foo(self) -&gt; None: ... class Derived(Base): def foo(self) -&gt; None: ... # missing-override-decorator @override def foo(self) -&gt; None: ... # OK   The default severity of this diagnostic is ignore. To enable strict override enforcement, set the severity to error in your configuration:  [tool.pyrefly] errors = { missing-override-decorator = &quot;error&quot; }   ","version":"Next","tagName":"h2"},{"title":"missing-source‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#missing-source","content":" Pyrefly was able to find a stubs package but no corresponding source package. For example, this can happen if you install the types-requests package but forget to install requests.  The default severity of this diagnostic is ignore.  ","version":"Next","tagName":"h2"},{"title":"missing-source-for-stubs‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#missing-source-for-stubs","content":" Pyrefly has bundled stubs for a package, but no corresponding source package was found.  ","version":"Next","tagName":"h2"},{"title":"no-access‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#no-access","content":" The no-access error indicates that an attribute exists, but it cannot be used in this way.  For example, classes do not have access to their instances' attributes:  class Ex: def __init__(self) -&gt; None: self.meaning: int = 42 del Ex.meaning # no-access   ","version":"Next","tagName":"h2"},{"title":"no-matching-overload‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#no-matching-overload","content":" This error is similar to the other bad function call errors, but specifically for cases where a function decorated with @overload is called with arguments that do not match any of the overloaded variations.  For example, neither of the signatures of f can take an argument of type float:  from typing import overload @overload def f(x: int) -&gt; int: ... @overload def f(x: str) -&gt; str: ... def f(x: int | str) -&gt; int | str: return x f(1.0)   ","version":"Next","tagName":"h2"},{"title":"non-exhaustive-match‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#non-exhaustive-match","content":" Pyrefly warns when a match statement over an Enum attempts to enumerate the members but forgets at least one case. Add the missing members or a default arm.  from enum import Enum class Color(Enum): RED = &quot;red&quot; BLUE = &quot;blue&quot; def describe(color: Color) -&gt; str: match color: # non-exhaustive-match case Color.RED: return &quot;danger&quot;   ","version":"Next","tagName":"h2"},{"title":"not-a-type‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#not-a-type","content":" This indicates an attempt to use something that isn't a type where a type is expected. In most cases, a more specific error kind is used.  You may see this error around incorrect type aliases:  class A: ... # Not an alias, just a string! X = &quot;A&quot; x: X = ... # X is not a type alias, so this is illegal   ","version":"Next","tagName":"h2"},{"title":"not-async‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#not-async","content":" not-async is reported when attempting to await on something that is not awaitable. This may indicate that a function should have been marked async but wasn't.  def some_func() -&gt; None: ... await some_func() # Expression is not awaitable [not-async]   This will also arise if the context manager used in an async with statement has __aenter__ and __aexit__ methods that are not marked async.  The fix is to use an async function in the await. This may mean making the function async or finding an existing async function to use instead.  ","version":"Next","tagName":"h2"},{"title":"not-callable‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#not-callable","content":" A straightforward error: something that is not a function was used as if it were a function.  One interesting place this error may occur is with decorators:  x = 1 @x # not-callable def foo() -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"not-iterable‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#not-iterable","content":" This is most likely to be seen in a for loop:  x = 1 # Or some other value for val in x: # not-iterable ...   ","version":"Next","tagName":"h2"},{"title":"not-required-key-access‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#not-required-key-access","content":" This warning indicates that a TypedDictkey marked NotRequired (or inherited from a total=False TypedDict) is being accessed without first ensuring that the key is present. Even if the value type is non-optional, the key itself may not exist at runtime, so Pyrefly encourages guarding the access with an in check or a .get()call.  The default severity of this diagnostic is ignore.  from typing import NotRequired, TypedDict class Movie(TypedDict): title: str year: NotRequired[int] def describe(movie: Movie) -&gt; int: return movie[&quot;year&quot;] # not-required-key-access def safe_describe(movie: Movie) -&gt; int: if &quot;year&quot; in movie: return movie[&quot;year&quot;] # OK: key presence established raise ValueError(&quot;Missing year&quot;)   ","version":"Next","tagName":"h2"},{"title":"open-unpacking‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#open-unpacking","content":" This error is reported on an attempt to unpack anopen TypedDict that potentially has items incompatible with the TypedDict it is being unpacked into.  The default severity of this diagnostic is ignore.  Example:  from typing import TypedDict class OpenTypedDict(TypedDict): x: int class UnpackingTarget(TypedDict): x: int y: str def f(o: OpenTypedDict) -&gt; UnpackingTarget: # Error: `o` could be an instance of a subclass of `OpenTypedDict` with an # item `y` with an incompatible type. return {&quot;y&quot;: &quot;&quot;, **o}   To fix this error, close the open TypedDict to indicate it does not contain any unknown items:  class OpenTypedDict(TypedDict, closed=True): ...   Note: In Python versions before 3.15, import TypedDict from typing_extensions rather thantyping to use the closed feature.  ","version":"Next","tagName":"h2"},{"title":"parse-error‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#parse-error","content":" An error related to parsing or syntax. This covers a variety of cases, such as function calls with duplicate keyword args, some poorly defined functions, and so on.  ","version":"Next","tagName":"h2"},{"title":"protocol-implicitly-defined-attribute‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#protocol-implicitly-defined-attribute","content":" Protocols must declare the attributes they require directly in the class body. Assigning to a new self attribute inside a protocol method introduces a member that implementations of the protocol would never be required to provide.  Add an annotated attribute (or property) to the protocol, or remove the assignment.  from typing import Protocol class Template(Protocol): name: str def method(self) -&gt; None: self.temp: list[int] = [] # protocol-implicitly-defined-attribute   ","version":"Next","tagName":"h2"},{"title":"read-only‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#read-only","content":" This error indicates that the attribute being accessed does exist but cannot be modified.  For example, a @property with no setter cannot be assigned to:  class Ex: @property def meaning(self) -&gt; int: return 42 x = Ex() x.meaning = 0   ","version":"Next","tagName":"h2"},{"title":"redefinition‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#redefinition","content":" Pyrefly reports this error when a name that already has an annotation in the current scope is annotated again with a different type. Re-annotating the same variable can lead to confusing types; prefer introducing a new name instead.  def f(x: int) -&gt; None: x: str = str(x) # redefinition   ","version":"Next","tagName":"h2"},{"title":"redundant-cast‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#redundant-cast","content":" This warning is raised when typing.cast() is used to cast a value to a type it is already compatible with. Such casts are unnecessary and can be removed to improve code clarity.  The default severity of this diagnostic is warn.  import typing x: int = 42 # This cast is redundant since x is already an int y = typing.cast(int, x) # redundant-cast # This is a valid cast since we're casting from a more general type obj: object = &quot;hello&quot; s = typing.cast(str, obj) # No warning - this is a valid cast   The redundant cast warning helps identify unnecessary type casts that don't provide any additional type safety benefits.  ","version":"Next","tagName":"h2"},{"title":"redundant-condition‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#redundant-condition","content":" This error is used to indicate a type that's equivalent to True or False is used as a boolean condition (e.g. an uncalled function)  def f() -&gt; bool: ... # This will throw error, as it's likely that the function needs to be invoked. if f: ... # This will throw error, as it's equivalent to `if True`. if &quot;abc&quot;: ...   ","version":"Next","tagName":"h2"},{"title":"reveal-type‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#reveal-type","content":" Pyrefly uses this diagnostic to communicate the output of the reveal_type function.  The default severity of this diagnostic is info.  ","version":"Next","tagName":"h2"},{"title":"unannotated-attribute‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unannotated-attribute","content":" This error is raised when a class attribute is missing a type annotation and is initialized with the None literal. Without an explicit annotation, Pyrefly infers the type as Any | None, which reduces type safety. To fix it, add an explicit type annotation to the attribute.  The default severity of this diagnostic is ignore.  class MyClass: # error: This expression is implicitly inferred to be `Any | None`. Please provide an explicit type annotation. value = None # Fixed version: class MyClass: value: int | None = None   ","version":"Next","tagName":"h2"},{"title":"unannotated-parameter‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unannotated-parameter","content":" This error is raised when a function parameter is missing a type annotation. This helps enforce fully-typed codebases by ensuring all parameters have explicit types. To fix it, add a type annotation to the parameter.  Note: The self and cls parameters are excluded from this check as they are implicitly typed.  The default severity of this diagnostic is ignore.  def process_data(x: int, y): # error: `process_data` is missing an annotation for parameter `y` return x + y # Fixed version: def process_data(x: int, y: int) -&gt; int: return x + y   ","version":"Next","tagName":"h2"},{"title":"unannotated-return‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unannotated-return","content":" This error is raised when a function is missing a return type annotation. This helps enforce fully-typed codebases by ensuring all functions declare their return types explicitly. To fix it, add a return type annotation to the function.  The default severity of this diagnostic is ignore.  def calculate_sum(x: int, y: int): # error: `calculate_sum` is missing a return annotation return x + y # Fixed version: def calculate_sum(x: int, y: int) -&gt; int: return x + y   ","version":"Next","tagName":"h2"},{"title":"unbound-name‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unbound-name","content":" This error corresponds to the runtime NameError, indicating that a variable is referenced but does not exist.  def do_things(stuff: list[int]) -&gt; str: ... do_thing([1, 2]) # typo! Or, unbound-name   ","version":"Next","tagName":"h2"},{"title":"unexpected-keyword‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unexpected-keyword","content":" A function was called with an extra keyword argument.  def two_args(a: int, b: int) -&gt; int: ... two_args(a=1, b=2, c=3)   ","version":"Next","tagName":"h2"},{"title":"unexpected-positional-argument‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unexpected-positional-argument","content":" A positional argument was passed for a keyword-only parameter.  def takes_kwonly(*, x: int) -&gt; int: ... takes_kwonly(1) # should be `takes_kwonly(x=1)`!   ","version":"Next","tagName":"h2"},{"title":"unknown-name‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unknown-name","content":" unknown-name occurs when attempting to load a name from another scope, but the name cannot be found.  def where() -&gt; None: # There is no spoon: unknown-name global spoon   ","version":"Next","tagName":"h2"},{"title":"unnecessary-comparison‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unnecessary-comparison","content":" This warning is raised when an identity comparison (is or is not) is made between literals whose comparison result is statically known.  The default severity of this diagnostic is warn.  def test0() -&gt; None: # Different literals are always different objects if 1 is 2: # unnecessary-comparison: always False pass # Same singletons are always the same object if True is not False: # unnecessary-comparison: always True pass def test1(x: object) -&gt; None: # Comparing an instance to a class is always False if x is int: # unnecessary-comparison: did you mean isinstance(x, int)? pass   This check is relatively conservative and only warns on limited cases where the comparison is highly likely to be redundant.  ","version":"Next","tagName":"h2"},{"title":"unreachable‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unreachable","content":" This error is raised when a return or yield can never be reached because it comes after a statement that always exits the current flow, such as return, raise, break, or continue.  def example(): return 1 return 2 # This `return` statement is unreachable [unreachable] def generator(): return yield 1 # This `yield` expression is unreachable [unreachable] def loop_example(): while True: break return 1 # This `return` statement is unreachable [unreachable]   Note that yield statements can follow other yield statements without error, since generators can produce multiple values:  def valid_generator(): yield 1 yield 2 # This is valid   ","version":"Next","tagName":"h2"},{"title":"unsafe-overlap‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unsafe-overlap","content":" Protocols decorated with @runtime_checkable may be used in isinstance and issubclass checks, but the runtime will only checks that all the required attributes are present, without looking at their types.  This error occurs when the object you're checking against the protocol has all the required attributes, but their types are not compatible.  In the example below, C should not match with P, but the isinstance check will succeed at runtime.  from typing import Protocol, runtime_checkable @runtime_checkable class P(Protocol): x: int class C: x: str c = C() if isinstance(c, P): pass   ","version":"Next","tagName":"h2"},{"title":"unsupported‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unsupported","content":" This error indicates that pyrefly does not currently support a typing feature.  ","version":"Next","tagName":"h2"},{"title":"unsupported-delete‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unsupported-delete","content":" This error occurs when attempting to del something that cannot be deleted.  Besides obvious things like built-in values (you can't del True!), some object attributes are protected from deletion. For example, read-only and required TypedDict fields cannot be deleted.  ","version":"Next","tagName":"h2"},{"title":"unsupported-operation‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unsupported-operation","content":" This error arises when attempting to perform an operation between values of two incompatible types.  if &quot;hello&quot; in 1: # int doesn't support `in`! ...   ","version":"Next","tagName":"h2"},{"title":"untyped-import‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#untyped-import","content":" Type information for some third-party libraries is shipped in a stubs package separate from the library's source code. This error is emitted when we detect that a library is being used without the recommended stubs package being installed.  The default severity of this diagnostic is ignore.  ","version":"Next","tagName":"h2"},{"title":"unused-coroutine‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unused-coroutine","content":" If the result of an async function call is not awaited or used, we will raise an error.  async def foo(): return 1 async def bar(): foo() # error await foo() # ok x = foo() # ok   ","version":"Next","tagName":"h2"},{"title":"unused-ignore‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unused-ignore","content":" This error is raised when a # pyrefly: ignore comment is not used to suppress an error, and can be safely removed.  The default severity of this diagnostic is ignore.  ","version":"Next","tagName":"h2"},{"title":"variance-mismatch‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#variance-mismatch","content":" The inferred variance of a type variable does not match its declared variance. This warning is raised for protocols where the way a type variable is used implies a different variance than what was declared. For example, if a protocol only uses T in covariant positions but T is declared as invariant, this warning suggests declaring T as covariant.  The default severity of this diagnostic is warn.  from typing import Protocol, TypeVar T = TypeVar(&quot;T&quot;) class A(Protocol[T]): # variance-mismatch: Type variable `T` in class `A` is declared as invariant, but could be covariant based on its usage def f(self) -&gt; T: ...  ","version":"Next","tagName":"h2"},{"title":"Typing for Python Developers","type":0,"sectionRef":"#","url":"/en/docs/typing-for-python-developers/","content":"","keywords":"","version":"Next"},{"title":"Types with Inference‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#types-with-inference","content":" Static analyzers can often infer types from your code‚Äîno annotations required. Pyrefly takes this a step further.  # Basic Inference from typing import reveal_type answer = 42 reveal_type(answer) # hover to reveal type fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] scores = {&quot;math&quot;: 95, &quot;science&quot;: 90} def greet(name): return f&quot;Hello, {name}!&quot; message = greet(&quot;World&quot;)  ","version":"Next","tagName":"h3"},{"title":"Where Inference Shines ‚ú®‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#where-inference-shines-","content":" Constant assignments (answer = 42 -&gt; int)List/tuple/dict literals with uniform elements (names = [&quot;A&quot;, &quot;B&quot;] -&gt; list[str])Return types if parameter types are annotated:  def add(a: int, b: int): # ‚úÖ param annotations return a + b # üîç return inferred -&gt; int  ","version":"Next","tagName":"h3"},{"title":"When to Add Hints‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#when-to-add-hints","content":" Public APIs (library or service boundaries)Mixed collections (list[int | str])Callable signatures (decorators, callbacks)  ","version":"Next","tagName":"h3"},{"title":"Define Types Inline‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#define-types-inline","content":" ","version":"Next","tagName":"h2"},{"title":"The Basics‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#the-basics","content":" Python's built-in types can be used to write many type hints.  # Example: Basic Types from typing import reveal_type age: int = 5 reveal_type(age) # revealed type: int age = &quot;oops&quot; name: str = &quot;John&quot; reveal_type(name) # revealed type: str numbers: list[int] = [1, 2, 3] reveal_type(numbers) # revealed type: list[int] names: list[str] = [&quot;John&quot;, &quot;Jane&quot;] reveal_type(names) # revealed type: list[str] person: dict[str, str] = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: &quot;30&quot;} reveal_type(person) # revealed type: dict[str, str] is_admin = True reveal_type(is_admin) # revealed type: Literal[True]  ","version":"Next","tagName":"h3"},{"title":"Functions‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#functions","content":" Defining the parameter and return types for a function doesn't just help prevent bugs, but it makes it easier to navigate in other files. You don't always need to define a return type - we'll do our best to infer it for you! We can't always get it right and an explicit return type will help your IDE navigate faster and more accurately.  # Example: Functions from typing import reveal_type def greet(name: str) -&gt; str: return f&quot;Hello, {name}!&quot; greet(&quot;Pyrefly&quot;) def whatDoesThisFunctionReturnAgain(a: int, b: int): return a + b reveal_type(whatDoesThisFunctionReturnAgain(2, 3)) # revealed type: int  ","version":"Next","tagName":"h3"},{"title":"Advanced Types‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#advanced-types","content":" ","version":"Next","tagName":"h2"},{"title":"Composing Types‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#composing-types","content":" The real power comes from composing smaller pieces into richer shapes.  ","version":"Next","tagName":"h3"},{"title":"Unions & Optional‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#unions--optional","content":" # Union and Optional Types from typing import Optional def to_int(data: str | bytes | None) -&gt; Optional[int]: if data is None: return None if isinstance(data, bytes): data = data.decode() return int(data)  ","version":"Next","tagName":"h3"},{"title":"Generics‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#generics","content":" Generics allow you to define reusable functions and classes that work with multiple types. This feature enables you to write more flexible and adaptable code.  Declaring Generic Classes:  # Example: Generic Classes from typing import reveal_type class C[T]: def __init__(self, x: T): self.x = x def box(self) -&gt; list[T]: return [self.x] c = C(0) reveal_type(c.box()) # revealed type: list[int]  Declaring Type Statements:  # Example: Type Statements type ListOrSet[T:int] = list[T] | set[T]  ParamSpec and TypeVarTuple:  # Example: ParamSpec and TypeVarTuple class ChildClass[T, *Ts, **P]: ...  ","version":"Next","tagName":"h3"},{"title":"Variance Inference in Generics‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#variance-inference-in-generics","content":" When working with generics, a key question is: if one type is a subtype of another, does the subtyping relationship carry over to generic types? For example, if int is a subtype of float, is A[int] also a subtype of A[float]?  This behavior is governed by variance:  Covariant types preserve the direction of subtyping (A[int] is a subtype of A[float]).Contravariant types reverse it.Invariant types require an exact match.  Before PEP 695, variance had to be declared manually and was often confusing. Pyrefly infers the variance automatically based on how each type parameter is used - in method arguments, return values, attributes, and base classes.  Example 1: Covariance from Immutable Attributes (Final)  # Example 1: Variance Inference from typing import Final class ShouldBeCovariant[T]: x: Final[T] def __init__(self, value: T): self.x = value x1: ShouldBeCovariant[float] = ShouldBeCovariant[int](1) # OK x2: ShouldBeCovariant[int] = ShouldBeCovariant[float](1.0) # ERROR!  How Variance is Inferred:  The attribute x is annotated as Final[T], making it immutable after initialization.Because T appears only in this read-only position, it is safe to infer T as covariant.This means: You can assign ShouldBeCovariant[int] to a variable expecting ShouldBeCovariant[float] (since int is a subtype of float).But the reverse is not allowed (ShouldBeCovariant[float] to ShouldBeCovariant[int]), which triggers a type error.  Example 2: General Variance Inference from Method and Base Class Usage  # Example 2: Variance Inference class ClassA[T1, T2, T3](list[T1]): def method1(self, a: T2) -&gt; None: ... def method2(self) -&gt; T3: ... def func_a(p1: ClassA[float, int, int], p2: ClassA[int, float, float]): v1: ClassA[int, int, int] = p1 # ERROR! v2: ClassA[float, float, int] = p1 # ERROR! v3: ClassA[float, int, float] = p1 # OK v4: ClassA[int, int, int] = p2 # ERROR! v5: ClassA[int, int, float] = p2 # OK  How Variance is Inferred:  T1 appears in the base class list[T1]. Since list is mutable, T1 is invariant.T2 is used as the type of a method parameter (a: T2) so T2 contravariant.T3 is the return type of a method (def method2() -&gt; T3) so T3 is covariant.This means: v1 fails due to mismatched T1 (invariant).v2 fails because T2 expects a supertype, but gets a subtype.v4 fails because T3 expects a subtype, but gets a supertype.  ","version":"Next","tagName":"h3"},{"title":"Structural Types and Protocols‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#structural-types-and-protocols","content":" Python also employs a structural type system, often referred to as &quot;duck typing.&quot; This concept is based on the idea that if two objects have the same shape or attributes, they can be treated as being of the same type.  ","version":"Next","tagName":"h2"},{"title":"Dataclasses‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#dataclasses","content":" Dataclasses allow you to create type-safe data structures while minimizing boilerplate.  # Example: Dataclasses from dataclasses import dataclass @dataclass class Point: x: float y: float Point(x=0.0, y=0.0) # OK Point(x=0.0, y=&quot;oops&quot;) # ERROR!  ","version":"Next","tagName":"h3"},{"title":"TypedDict‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#typeddict","content":" Typed dictionaries enable you to define dictionaries with specific key-value types. This feature lets you bring type safety to ad-hoc dictionary structures without major refactoring.  # Example: TypedDict from typing import TypedDict class Movie(TypedDict): name: str year: int good_movie: Movie = {&quot;name&quot;: &quot;Toy Story&quot;, &quot;year&quot;: 1995} # OK bad_movie: Movie = {&quot;name&quot;: &quot;The Room&quot;, &quot;year&quot;: &quot;2003&quot;} # ERROR!  ","version":"Next","tagName":"h3"},{"title":"Overloads‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#overloads","content":" Overloads allow you to define multiple function signatures for a single function. Like generics, this feature helps you write more flexible and adaptable code.  # Example: Overloads from typing import overload, reveal_type @overload def f(x: int) -&gt; int: ... @overload def f(x: str) -&gt; str: ... def f(x: int | str) -&gt; int | str: return x reveal_type(f(0)) # revealed type: int reveal_type(f(&quot;&quot;)) # revealed type: str  ","version":"Next","tagName":"h3"},{"title":"Protocols‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#protocols","content":" Protocols allows you to define interfaces without explicit inheritance. This feature helps you write more modular and composable code.  # Example: Structural Typing with Protocols from typing import Iterable, Protocol class Writer(Protocol): def write(self) -&gt; None: ... class GoodWorld: def write(self) -&gt; None: print(&quot;Hello world!&quot;) class BadWorld: pass def f(writer: Writer): pass f(GoodWorld()) # OK f(BadWorld()) # ERROR!  ","version":"Next","tagName":"h3"},{"title":"Typing Features and PEPS available in each Python Version‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#typing-features-and-peps-available-in-each-python-version","content":" See the full list of features available in the Python type system here.  ","version":"Next","tagName":"h2"},{"title":"Key Highlights Summary:‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#key-highlights-summary","content":" Inference: Python's static analyzers can infer types from your code, reducing the need for explicit annotations. This feature enhances code readability and helps catch bugs early.Defining Types: You can define types inline using Python's built-in types, which aids in documentation and improves IDE support.Advanced Types: The guide covers advanced concepts like composing types, using unions and optionals, generics, protocols, and structural types like dataclasses and TypedDict.Practical Examples: The guide includes examples of functions, generic classes, structural typing with protocols, and more, demonstrating how to apply these concepts in real-world scenarios. ","version":"Next","tagName":"h3"}]