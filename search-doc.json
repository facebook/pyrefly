[{"title":"Give your Python IDE a Glow-Up with Pyrefly","type":0,"sectionRef":"#","url":"/blog/2025/09/15/ide-extension/","content":"","keywords":"","version":null},{"title":"Background - What is a Language Server and Why Does It Matter?‚Äã","type":1,"pageTitle":"Give your Python IDE a Glow-Up with Pyrefly","url":"/blog/2025/09/15/ide-extension/#background---what-is-a-language-server-and-why-does-it-matter","content":" The Language Server Protocol (LSP) is a standardized way for code editors to communicate with language-specific servers that provide features like autocomplete, go-to-definition, and symbol renaming. Instead of each editor implementing these features separately, LSP allows a single language server to support multiple editors. Pyrefly‚Äôs language server capabilities are based on the Language Server Protocol Specification and are designed to still be blazing fast even on code bases with over 20 million lines of code.  A key capability of many language servers, including Pyrefly, is typechecking, which enhances IDE features by providing type diagnostics. Pyrefly‚Äôs language server not only reports type errors like basic type checkers, such as Mypy, but also replaces core IDE functionalities including ‚Äúfind definition,‚Äù hover (displaying types and docstrings), and completions. By consolidating these features, Pyrefly ensures that the types it checks and the types displayed in your IDE will always match.  ","version":null,"tagName":"h2"},{"title":"Instagram - A Case Study on the Pain of Slow Code Navigation‚Äã","type":1,"pageTitle":"Give your Python IDE a Glow-Up with Pyrefly","url":"/blog/2025/09/15/ide-extension/#instagram---a-case-study-on-the-pain-of-slow-code-navigation","content":" Meta operates an incredibly large Python codebase - a massive monorepo containing almost 1.5 million Python files maintained by thousands of developers. Instagram is one of those projects, with over 20 million lines of Python code. At this scale, even simple navigation tasks like jumping to a function definition, searching for references, or loading syntax highlights could take almost a minute in the worst cases. That may not sound like a lot on its own, but experiencing it every few minutes quickly becomes frustrating and has a tangible impact on developer productivity, especially when multiplied across a large company like Meta.  Pyrefly emerged in part to address this exact challenge (you can read more about our origin story in our intro blog). In real world use cases, developers who switched from Pyright (the default LSP for VSCode) to Pyrefly spent 98% less time waiting on hover results and go-to definition was ~10x faster. On the slowest files (p99), these IDE responses grew from an order of minutes to seconds (30x improvement). If those numbers are hard to visualise, the TL;DR is that this upgrade took instagram developers from questioning ‚Äúis my editor frozen?‚Äù to not giving their IDE a second thought.    Pyrefly (left) vs Pyright (right) autocomplete speed comparison  These early results are certainly promising indications of a smoother developer experience for Meta engineers, and we're excited to share more insights as developers continue using Pyrefly. But Pyrefly isn‚Äôt just for Meta developers, it‚Äôs open source and ready for everyone to explore! If you‚Äôre curious about Pyrefly‚Äôs language server features and want to see how to get it up and running in your IDE, keep reading!  ","version":null,"tagName":"h2"},{"title":"Pyrefly LSP at a Glance‚Äã","type":1,"pageTitle":"Give your Python IDE a Glow-Up with Pyrefly","url":"/blog/2025/09/15/ide-extension/#pyrefly-lsp-at-a-glance","content":" While Pyrefly is still in Alpha as of the time of posting, it already supports most of the essential IDE capabilities that Python developers rely on daily, such as:  Autocomplete: predicts what you‚Äôre likely to type next, reducing the need to remember exact names of variables, functions, and others, even importing them automatically for youGo to Definition: allows you to jump directly to the source of a function, class, or variable with a single click.Hover: when you hover over a symbol, Pyrefly displays useful information such as type annotations, documentation, and inferred types.Rename symbols: right click to rename variables, functions, or classes across the entire codebase.Typechecking: Pyrefly will also show type errors and infer types, which you can toggle on or off in your Pyrefly settings (more info in the next section)And many more! explore the full list and details in the Pyrefly IDE docs.  The Pyrefly team and our open-source community are continuously working on improvements and new features so stay tuned for updates! We also want to hear from you - what features do you need to make your IDE experience better? Open a GitHub issue or join our discord to share your thoughts.  ","version":null,"tagName":"h2"},{"title":"How to add Pyrefly to your IDE‚Äã","type":1,"pageTitle":"Give your Python IDE a Glow-Up with Pyrefly","url":"/blog/2025/09/15/ide-extension/#how-to-add-pyrefly-to-your-ide","content":" Pyrefly can be used in a range of IDEs, including standard GUI editors like VSCode or Pycharm, terminal editors like Neovim or Emacs, and AI editors like Cursor or Windsurf. You can check out the full list of supported IDEs in the Pyrefly IDE docs.  For GUI editors, setup is pretty straightforward and generally follows the same steps:  Search for ‚Äúpyrefly‚Äù in the appropriate extension marketplace for your IDE and install itOpen any Python file and the extension will activate automaticallyNote: if using an editor other than VSCode you may need to uninstall the default Python LSP in your editor. You can do this by opening your extension settings and setting &quot;Language Server: None&quot;Optional: we recommend all developers use a typechecker as part of their regular software development process, however we know that type errors in your IDE can be noisy, so the type errors feature is not turned on by default if you don't have a pyrefly.toml (from pyrefly init). If you DO want type errors to show up in your editor everywhere (as red squiggles), you should update your extension settings to include &quot;python.pyrefly.displayTypeErrors&quot;: &quot;force-on&quot;    For terminal editors the setup process can vary depending on which editor you use so check out the installation documentation for specific instructions.  ","version":null,"tagName":"h2"},{"title":"Conclusion‚Äã","type":1,"pageTitle":"Give your Python IDE a Glow-Up with Pyrefly","url":"/blog/2025/09/15/ide-extension/#conclusion","content":" As Python projects continue to grow in size and complexity, having a fast, reliable, and scalable language server is essential for maintaining developer productivity (and our sanity to be honest). So if you‚Äôre working on a large codebase and want an LSP designed with scalability in mind we invite you to give Pyrefly a try!  While the project is still in Alpha we‚Äôre especially eager to hear from more users like you about how the IDE extension performs on real world codebases. If you have any feedback, bug reports or feature requests please feel free to open a GitHub issue, and if you have any questions or need support please come chat with us on Discord!  Happy coding, fellow pyreflies! üî•ü™∞ ","version":null,"tagName":"h2"},{"title":"Introducing Pyrefly - A new type checker and IDE experience for Python","type":0,"sectionRef":"#","url":"/blog/introducing-pyrefly/","content":"","keywords":"","version":null},{"title":"Get started‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#get-started","content":" Ready to dive in? The official Pyrefly website has all the details, but to quickly get started:  Install Pyrefly on the command-line: pip install pyrefly.Migrate your existing type checker configuration to Pyrefly.Enhance Your IDE: Download the Pyrefly extension for VSCode and enjoy a lightning fast IDE experience from starter projects to monorepos.Leave feedback for us on GitHub.  ","version":null,"tagName":"h2"},{"title":"Why we built Pyrefly‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#why-we-built-pyrefly","content":" Back in 2017, we embarked on a mission to create a type checker that could handle Instagram‚Äôs massive codebas of typed Python. This mission led to the birth of the Pyre type checker, inspired by the robust designs of Hack and Flow, and written in OCaml to deliver scalable performance.  Over the years, Pyre served us well, but as the type system evolved and the need for typechecking to drive responsive IDE emerged, it was clear that we needed to take a new approach. We explored alternate solutions and leveraged community tools like Pyright for code navigation. But the need for an extensible type checker that can bring code navigation, checking at scale, and exporting types to other services drove us to start over, creating Pyrefly.  ","version":null,"tagName":"h2"},{"title":"The principles behind Pyrefly‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#the-principles-behind-pyrefly","content":" Today, we‚Äôre excited to unveil Pyrefly, a project we‚Äôve been developing openly on GitHub. We invite you to explore our work and try it out on your own project. While a project like Pyrefly is the sum of thousands of technical choices, a few notable principles we‚Äôve followed are:  ","version":null,"tagName":"h2"},{"title":"Performance‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#performance","content":" We want to shift checks that used to happen later on CI to happening on every single keystroke. That requires checking code at speed (on large codebases we can check 1.8 million lines of code per second!) and careful thought to incrementality and updates. Pyrefly is implemented in Rust and designed for high performance on codebases of all sizes.  ","version":null,"tagName":"h3"},{"title":"IDE first‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#ide-first","content":" We want the IDE and command line to share a consistent view of the world, which means crafting abstractions that capture the differences without incurring unnecessary costs. Designing these abstractions from the beginning is much easier than retrofitting them, which we tried with Pyre.  ","version":null,"tagName":"h3"},{"title":"Inference‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#inference","content":" Some Python programs are typed, but many aren‚Äôt. We want users to benefit from types even if they haven‚Äôt annotated their code ‚Äì so automatically infer types for returns and local variables and display them in the IDE. What‚Äôs more, in the IDE you can even double click to insert these inferred types if you think that would make the program better.  ","version":null,"tagName":"h3"},{"title":"Open source‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#open-source","content":" Python is open source, and hugely popular. The Python typing specification is open source, which made Pyrefly vastly easier to develop. Many of the libraries Meta contributes to are open source,( e.g., PyTorch).  Pyrefly is also open source, available on GitHub under the MIT license, and we encourage pull requests and issue reports. We also have a Discord channel for more free flowing discussions. We would love to build a community around Pyrefly.  ","version":null,"tagName":"h3"},{"title":"The future of Pyrefly‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#the-future-of-pyrefly","content":" We will work with the Python community to drive the language forward and improve the developer experience. Since the beginning of Pyre, we open sourced our code and contributed a number of PEPs alongside the community of type checker maintainers. We feel we can do more with Pyrefly to help Python developers leverage the benefits of types for developers, library authors, and folks just learning the language.  Meta has leveraged types in dynamic languages from the beginning and knows the significant benefits it brings to developer productivity and security. We plan to share more of our learnings and tooling with blogs, better types in the ecosystem and language enhancements.  Today we‚Äôre releasing Pyrefly as an alpha. At the same time, we‚Äôre busy burning down the long-tail of bugs and features aiming to remove the alpha label this Summer. Your feedback is invaluable to get there, so please give it a try and report your bugs or things you think can be improved. Even if Pyrefly isn‚Äôt right for your project, we would love to hear how you use types and what you would like to see improved in your editor.  Join us on the journey as we help illuminate your bugs with Pyrefly. Happy coding! üêç‚ú®  ","version":null,"tagName":"h2"},{"title":"Hear more about Pyrefly‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#hear-more-about-pyrefly","content":" Check out the episode of the Meta Tech Podcast where several team members share their experience developing Pyrefly and technical details for how it works. We also just talked at PyCon US about high-performance Python through faster type checking and free threaded execution.  To learn more about Meta Open Source, visit ouropen source site, subscribe to our YouTube channel, or follow us on Facebook, Threads, X, and LinkedIn.  ","version":null,"tagName":"h2"},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"Introducing Pyrefly - A new type checker and IDE experience for Python","url":"/blog/introducing-pyrefly/#acknowledgements","content":" Pyrefly was created By Meta‚Äôs Python Language Tooling Team: Jia Chen, Rebecca Chen, Sam Goldman, David Luo, Kyle Into, Zeina Migeed, Neil Mitchell, Maggie Moss, Conner Nilsen, Aaron Pollack, Teddy Sudol, Steven Troxler, Lucian Wischik, Danny Yang, and Sam Zhou. ","version":null,"tagName":"h3"},{"title":"Why Today‚Äôs Python Developers Are Embracing Type Hints","type":0,"sectionRef":"#","url":"/blog/why-typed-python/","content":"","keywords":"","version":null},{"title":"What is Typed Python?‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#what-is-typed-python","content":" Before we dive into why you should be using typed Python in your daily development lives, first we need to understand some core concepts and how we got here.  ","version":null,"tagName":"h2"},{"title":"Dynamic vs static typing‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#dynamic-vs-static-typing","content":" The classic Python programming language that you know and love is dynamically typed. What does that mean exactly? It means that types are determined at runtime, not when you write your code. Variables can hold any type of value, and you don't need to declare what type they are.  Here‚Äôs an example of dynamic typing in action:  x = 5 # x is an integer x = &quot;hello&quot; # now x is a string x = [1,2,3] # now x is a list   This behaviour is one of the things that sets Python apart from languages that are statically typed, like Java or C++, which require you to declare types from the get go:  int x = 5; std::string x_str = &quot;hello&quot;; std::vector&lt;int&gt; x_vec = {1, 2, 3};   In the above example we can‚Äôt just reassign the variable x to a value of whatever type we want, it can only hold an integer because of the static typing nature of the C++ language.  The fact that Python is a dynamically typed language is one of the reasons it is so easy to use and popular amongst new and experienced programmers alike. It makes it easy to develop quick demos, experimental research and proof of concepts, without needing to spend precious development time declaring types. This flexibility has been instrumental in Python's adoption in AI, data science, and scientific computing, where researchers need to rapidly iterate and experiment with different approaches.  However‚Ä¶ (surely you knew there was a ‚Äúbut‚Äù coming?)  We are quickly moving past the ‚Äúproof-of-concept‚Äù phase for many of these industries. AI and machine learning efforts are actively being integrated into production applications, and with that comes production-level expectations of reliability and stability. Relying on dynamic typing opens these codebases up to a certain level of risk that may not be acceptable at the scale they are now expected to operate.  ","version":null,"tagName":"h3"},{"title":"Enter PEP 484: Static Typing Comes to Python‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#enter-pep-484-static-typing-comes-to-python","content":" Cast your mind back to September 2014: Germany has just won the world cup, skinny jeans are still in fashion and Taylor Swift‚Äôs ‚ÄúShake it Off‚Äù is number 1 on the charts. That same month PEP 484 was first created, proposing the addition of type hints to Python, and fundamentally changing how future developers would be able to write and maintain Python code.  With PEP 484‚Äôs acceptance and introduction in Python 3.5, developers could now use static type annotations to declare the expected data types of function arguments and return values, and subsequent PEPs have continually added more features to expand and refine Python's type system. Today you can write statically typed Python statements like this:  def my_func(x: int, y: str) -&gt; bool: z: str = str(x) return z == y   The key innovation of PEP 484 was introducing a gradual type system that allows developers to slowly add type annotations over time without breaking existing code. The system works by:  Only type-checking functions that have explicit return or parameter annotationsIntroducing the Any type as an escape hatch that has all possible attributesAssuming untyped functions implicitly return Any  This approach has meant developers can incrementally adopt typing, while still allowing them to take advantage of the default dynamic typing approach that makes Python so easy to work with and ideal for quick prototyping.  ","version":null,"tagName":"h3"},{"title":"Benefits of Python Type Hints: Write Better Code, Faster‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#benefits-of-python-type-hints-write-better-code-faster","content":" So why specifically should you start using type hints in your Python code? Python type hints offer a range of advantages that can significantly improve the quality, maintainability, and scalability of your codebase, at the same time making it easier for other developers to understand your code and collaborate with you.  ","version":null,"tagName":"h2"},{"title":"Types help you catch bugs early‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#types-help-you-catch-bugs-early","content":" Type hints assist static analysis tools in identifying mismatches and potential errors before the code is executed, allowing for early bug detection. Take the following example:  def add_numbers(a, b): return a + b ... add_numbers(3, &quot;4&quot;) # Potential error   The above error might be easy to spot when you‚Äôre calling the function so close to where you‚Äôre defining it, but imagine you‚Äôre working across multiple files and/or with many lines of code separating them - suddenly it‚Äôs not so easy!  In comparison, if you‚Äôre using type hints in conjunction with a typechecking tool (such as Pyrefly or MyPy), you can catch this error much earlier - when you‚Äôre actually writing the code, rather than when it fails at runtime:  def add_numbers(a: int, b: int) -&gt; int: return a + b ... add_numbers(3, &quot;4&quot;) # a typechecker will catch this error at time of writing   Using a typechecker to highlight these types of errors also ensures you can catch an error like this even if you‚Äôve missed this code path in your unit tests.  ","version":null,"tagName":"h3"},{"title":"Typed code is self-documenting‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#typed-code-is-self-documenting","content":" Another benefit of writing typed Python is that using function signatures and variable annotations provide clarity of intent for a given piece of code. In other words, it makes code easier to read and review. It makes refactoring safer and more predictable. It even helps new team members get up to speed quickly on what‚Äôs going on in your codebase without wasting their own time, or yours!  Take the following example, without type hints you have to carefully read the internal function code to understand what type of parameters will work and what will be returned:  def calculate_stats(data, weights): total = 0 weighted_sum = 0 for i, value in enumerate(data): if i &lt; len(weights): weighted_sum += value * weights[i] total += weights[i] avg = weighted_sum / total if total &gt; 0 else 0 return avg, len(data)   With this version, you can tell instantly what type of arguments you should be passing and what you should expect to get back - saving precious dev time and just generally making your life easier:  def calculate_stats(data: list[float], weights: list[float]) -&gt; tuple[float, int]: total = 0 weighted_sum = 0 for i, value in enumerate(data): if i &lt; len(weights): weighted_sum += value * weights[i] total += weights[i] avg = weighted_sum / total if total &gt; 0 else 0 return avg, len(data)   I know I know - ideally all developers should be adding clear docstrings with every function they write, but we know in reality it doesn‚Äôt always shape up that way! Adding type hints is quicker than writing a typical docstring, won‚Äôt go stale (if enforced using a typechecker) and is better than no documentation at all. Modern Python typecheckers also have IDE extensions that include autocomplete functionality to make life easier.  ","version":null,"tagName":"h3"},{"title":"Typed Python helps you scale from proof-of-concept to production-ready‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#typed-python-helps-you-scale-from-proof-of-concept-to-production-ready","content":" One of the most important benefits of using type annotations in your code is that it helps you scale your code faster and with less risk. For developers today, the pipeline from experimental code to production systems moves faster than ever, especially in AI and machine learning workflows where research prototypes must quickly evolve into robust, scalable applications.  For example, say there is a team of data scientists that has just published their findings and now needs to operationalize their models. If their published code already includes type hints it makes it much easier, quicker and safer for an engineering team to step in and integrate that research into production applications. In situations like these, type annotations act as a contract between different stages of development, making it clear how data flows through complex, multi-step processing pipelines. This is particularly valuable in AI workflows where a single type mismatch, like passing a NumPy array where a PyTorch tensor is expected, can cause silent failures or performance degradation that only surfaces under production load.  ","version":null,"tagName":"h3"},{"title":"Get Started with Typed Python today!‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#get-started-with-typed-python-today","content":" So now you know what typed python is and why you should be doing it, how can you actually get started adding types to your code?  ","version":null,"tagName":"h2"},{"title":"Step 0 - start early!‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#step-0---start-early","content":" As a general rule of thumb, the earlier in a project you start adding type annotations the better. Type hints are much easier to add as you go than to retrofit across an entire codebase later.  As we‚Äôve mentioned before, one of the great benefits of Python is that its dynamic typing default makes it very flexible and easy to get started with. So when you‚Äôre doing your initial experimentation and prototyping maybe you‚Äôre not thinking about making sure it‚Äôs type safe - and that‚Äôs ok! But as soon as you start to think your project might be going somewhere, if more than one person might be working on it, using it or just reading it, you should start adding type hints.  ","version":null,"tagName":"h3"},{"title":"Step 1 - install a type checker‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#step-1---install-a-type-checker","content":" Choose and install a type checker that fits your needs. Typecheckers leverage the code annotations you write to provide important errors and warnings to ensure your codebase is type safe.  At Meta, we recommend Pyrefly, our new open-source type checker built in Rust. Pyrefly is designed to scale from small projects to massive codebases incredibly fast, while providing excellent developer experience. Read the Pyrefly documentation to understand configuration options and best practices, then start adding simple type hints to new functions before gradually working your way up to more complex scenarios.  You should also consider working with a typechecker that supports IDE integration to get real-time feedback as you write code. Pyrefly provides extensions for editors like VS Code, PyCharm, and Vim which will highlight errors and provide autocomplete suggestions based on your type annotations.  Adding your typechecker to your CI processes is also valuable for maintaining code quality at scale. You can configure your CI/CD pipeline to run type checking on every pull request, treating type errors as build failures.  ","version":null,"tagName":"h3"},{"title":"Step 2 - make use of resources to get better at typing‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#step-2---make-use-of-resources-to-get-better-at-typing","content":" Typing is one of those skills that gets better the more you practice it in your code, but there are also great resources out there for getting to grips with the functionality and diving deeper into the concepts:  Official Python typing documentation - The typing module docs provide comprehensive coverage of all available typesPEP 484 and related PEPs - Understanding the foundational specifications helps you grasp the &quot;why&quot; behind typing decisionsDocumentation for your chosen typechecker, e.g. Pyrefly Docs on learning typingJoin community forums and get support, e.g. Pyrefly Discord, Typing Discourse  ","version":null,"tagName":"h3"},{"title":"Conclusion‚Äã","type":1,"pageTitle":"Why Today‚Äôs Python Developers Are Embracing Type Hints","url":"/blog/why-typed-python/#conclusion","content":" So there you have it - a quick trip around the world of Python typing! By now you‚Äôve hopefully learnt that type hints aren't just another Python feature to add to the long list of things you‚Äôll definitely get round to implementing eventually - they're a practical investment in your code's future. The upfront effort of adding type hints pays dividends in reduced debugging sessions, smoother code reviews, and fewer production issues. Most importantly, they give you the confidence to refactor and scale your codebase without fear of breaking things in unexpected ways. Start small by adding type annotations to your next function, add a type checker to your workflow, and before you know it writing typed Python will be second nature. Your future self (and your users and teammates!) will thank you. ","version":null,"tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/en/docs/","content":"","keywords":"","version":"Next"},{"title":"Benefits of Type Checking‚Äã","type":1,"pageTitle":"Introduction","url":"/en/docs/#benefits-of-type-checking","content":" Adding type annotations to your Python code and using a type checker like Pyrefly provides several important benefits:  Catch bugs early - Identify type-related errors during development rather than at runtimeImprove code quality - Type annotations serve as living documentation, making your code more readable and self-documentingEnhance developer experience - Get better IDE support with accurate autocomplete, refactoring tools, and inline documentationSafer refactoring - Make large-scale changes with confidence, knowing the type checker will catch incompatible type usageBetter collaboration - Types create clear contracts between different parts of your codebase, making it easier for teams to work together  ","version":"Next","tagName":"h2"},{"title":"Try Pyrefly‚Äã","type":1,"pageTitle":"Introduction","url":"/en/docs/#try-pyrefly","content":" Here's a simple example showing how Pyrefly can catch type errors:  # Example: Basic Type Checking def greet(name: str) -&gt; str: return &quot;Hello, &quot; + name # This works fine since both &quot;World&quot; is a string and greet expects a string message = greet(&quot;World&quot;) # Pyrefly catches this error before runtime due to a type misatch between 42 and &quot;str&quot; # Error: Argument of type 'int' is not assignable to parameter of type 'str' error_message = greet(42)  In this example, Pyrefly flags the second call to greet() because we're passing an integer (42) where a string is expected, helping you catch this issue before your code runs. To learn more about Python typing and how to use it effectively:  If you're new to Python, check out our Python Typing for Beginners guide.If you're familiar with Python but new to typing, see our Typing for Python Developers guide. ","version":"Next","tagName":"h2"},{"title":"Pyrefly Infer","type":0,"sectionRef":"#","url":"/en/docs/autotype/","content":"","keywords":"","version":"Next"},{"title":"Usage‚Äã","type":1,"pageTitle":"Pyrefly Infer","url":"/en/docs/autotype/#usage","content":" To use the infer feature, run the following command in your project directory:  pyrefly infer path/to/file.py # or pyrefly infer path/to/directory/   We recommend running it in small batches to make reviewing and merging changes easier. Flags can be used to turn on / off adding annotations for parameters, return types, and containers.  It is common that new annotations will expose new type errors. See our error suppression guides to learn how to automate silencing these errors. ","version":"Next","tagName":"h2"},{"title":"Pyrefly Error Suppressions","type":0,"sectionRef":"#","url":"/en/docs/error-suppressions/","content":"","keywords":"","version":"Next"},{"title":"Upgrading Pyrefly (And other changes that introduce new type errors)‚Äã","type":1,"pageTitle":"Pyrefly Error Suppressions","url":"/en/docs/error-suppressions/#upgrading-pyrefly-and-other-changes-that-introduce-new-type-errors","content":" Upgrading the version of Pyrefly you're using, or a third party library you depend on can surface new type errors in your code. Fixing them all at once is often not realistic. We've written scripts to help you temporarily silence them.  # step 1 pyrefly check --suppress-errors   # step 2 &lt;run your formatter of choice&gt;   # step 3 pyrefly check --remove-unused-ignores   Repeat the steps above until you get a clean formatting run and a clean type check.  This will add # pyrefly: ignore comments to your code that will enable you to silence errors, and come back and fix them at a later date. This can make the process of upgrading a large codebase much more manageable. ","version":"Next","tagName":"h2"},{"title":"IDE Supported Features","type":0,"sectionRef":"#","url":"/en/docs/IDE-features/","content":"","keywords":"","version":"Next"},{"title":"Go to definition‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#go-to-definition","content":" Jump to where a symbol is declared with a click or F12.      ","version":"Next","tagName":"h3"},{"title":"Find references‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#find-references","content":" List all usages of a symbol across your codebase.      ","version":"Next","tagName":"h3"},{"title":"Document symbols‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#document-symbols","content":" See an outline of all top-level items in the current file.      ","version":"Next","tagName":"h3"},{"title":"Workspace symbols‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#workspace-symbols","content":" Search globally for functions, classes, and variables.      ","version":"Next","tagName":"h3"},{"title":"Hover‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#hover","content":" See type info and docstrings when hovering over code.      ","version":"Next","tagName":"h3"},{"title":"Document highlights‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#document-highlights","content":" Highlights all other instances of the symbol under your cursor.      ","version":"Next","tagName":"h3"},{"title":"Signature help‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#signature-help","content":" Live function signatures as you type, with parameter hints.      ","version":"Next","tagName":"h3"},{"title":"Completion‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#completion","content":" Autocomplete suggestions for project-specific symbols and imports.      ","version":"Next","tagName":"h3"},{"title":"Rename‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#rename","content":" Safely rename symbols project-wide.      ","version":"Next","tagName":"h3"},{"title":"Diagnostics‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#diagnostics","content":" Type errors and warnings from Pyrefly‚Äôs checker appear in the diagnostics pane (&quot;Problems&quot; pane in VSCode).      ","version":"Next","tagName":"h3"},{"title":"Semantic tokens‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#semantic-tokens","content":" Rich syntax highlighting based on token type and origin.      ","version":"Next","tagName":"h3"},{"title":"Inlay hints‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#inlay-hints","content":" Inline hints for types, parameter names, and return values.  info If you have the default VS Code Python extension installed at the same time as Pyrefly, inlay hints will be turned off by default. In all other cases, inlay hints will be on by default.  You can turn inlay hints on or off using the VSCode Setting editor.inlayHints.enabled.      ","version":"Next","tagName":"h3"},{"title":"Notebook support‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#notebook-support","content":" Right now, Pyrefly does not work with Jupyter notebooks in VS Code. Please follow this issue for updates.  You may use Pyrefly with Jupyter notebooks in Jupyter Lab, via the jupyterlab-lsp extension. Pyrefly will appear on the list of automatically-detected language servers.  Notebook support is experimental. Please report any bugs on our Github.    ","version":"Next","tagName":"h3"},{"title":"Planned features‚Äã","type":1,"pageTitle":"IDE Supported Features","url":"/en/docs/IDE-features/#planned-features","content":" See planned features and request your own on GitHub. ","version":"Next","tagName":"h2"},{"title":"Import Resolution","type":0,"sectionRef":"#","url":"/en/docs/import-resolution/","content":"","keywords":"","version":"Next"},{"title":"Relative Imports‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#relative-imports","content":" If the import is relative (starting with one or more dots), the import is resolved relative to the path of the file importing it. A single dot at the beginning of the import (e.g. .file.to.import) represents the current directory, and more dots (e.g. ..other.file) will continue to walk upward.  ","version":"Next","tagName":"h2"},{"title":"Absolute Imports‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#absolute-imports","content":" For absolute imports, Pyrefly searches for a match in each of the following groups. The matching process is explained in the next paragraph.  Try to import from the search path. See the search path section for more information.Try to import from typeshed.Try to import from the fallback search path. See the fallback search path section for more information on the contents of the search path.Try to import from the site package path. See thesite package path section for more information on the contents of the site package path.Return an import error.  When searching for a match in one of the above groups, Pyrefly performs the following process over two passes, one looking for stub packages, and the other looking for source packages. SeeStub Files vs Source Files for more information.  Attempt to match each part of the name to directories in the group, selecting the first match that is found.If the result is a .pyi file or regular package (directory with an__init__.py/__init__.pyi file), return the result. Otherwise, keep searching and attempt to find a .pyi file or regular package.  ","version":"Next","tagName":"h2"},{"title":"Search Path‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#search-path","content":" The search path (see search-path in configuration docs) consists of several entries representing project files.  Search path from CLI args.Search path from config files.If disable-search-path-heuristicsis not set, Pyrefly appends an import root directory to the search path.  The import root is:  src/ if there's a src/ directory in the same directory as the config file.The parent directory (..) if there's an __init__.py or __init__.pyi in the same directory as the config file.Otherwise, the directory containing the config file.  ","version":"Next","tagName":"h3"},{"title":"Fallback Search Path‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#fallback-search-path","content":" The fallback search path is a heuristic automatically constructed by Pyrefly to attempt to find project files when there's no config file marking the project root, and Pyrefly is unable to determine from other heuristics where an import root might be. It is only constructed whendisable-search-path-heuristicsis not set.  The fallback search path consists of each directory from the directory containing a given file to the root of your filesystem. For example, if you have the following setup:  / |- projects/ |- project_a/ | |- b/ | | |- c.py | |- d.py |- project_e/ |- f.py   c.py's fallback search path would be ['/projects/project_a/b', '/projects/project_a', '/projects', '/']  d.py could be importable with the paths d, project_a.d, or projects.project_a.d.f.py could be importable with the paths project_e.f or projects.project_e.f.  e.py's fallback search path would be ['/projects/project_a', '/projects', '/']  c.py could be importable with the paths b.c, project_a.b.c, or projects.project_a.b.cf.py could be importable with the paths project_e.f or projects.project_e.f  f.py's fallback search path would be ['/projects/project_e', '/projects', '/']  c.py could be importable with the paths project_a.b.c or projects.project_a.b.cd.py could be importable with the paths project_a.d or projects.project_a.d  ","version":"Next","tagName":"h3"},{"title":"Site Package Path‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#site-package-path","content":" The site package path (see site-package-path in configuration docs) consists of several entries representing third-party packages.  Site package path from a config file (if no CLI override is present) or CLI args.A site package path queried from a Python interpreter, if one could be found. See Environment Autoconfigurationfor more information on finding interpreters.  ","version":"Next","tagName":"h3"},{"title":"Stub Files vs Source Files‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#stub-files-vs-source-files","content":" Astub fileis any file that ends with a .pyi file suffix. They have many uses, including adding typing to non-Python extension code, distributing typing information separate from implementation, or overriding an implementation with more accurate typing information.  A stub package is a second package corresponding to a regular package, with -stubsappended to its name. A -stubs package should only include stub files (.pyi), which override any .py or .pyi files in the non-stubs package. These are preferred when available, since they contain the interfaces a library exposes to developers. An example of this includes the popular library pandas, and its stub package, pandas-stubs.  When importing from a non-stubs package, Pyrefly loads typing information from imports by first searching for a relevant -stubs package, then by looking at the non-stubs package's .pyi files, then falls back to a .py file. SeeAbsolute Imports for details on when non-stubs packages are allowed to be used for types, and how you can override that behavior.  ","version":"Next","tagName":"h2"},{"title":"Editable Installs‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#editable-installs","content":" When using static analysis tools with an editable install, the editable install should be configured to use .pthfiles that contain file paths (/project/src/module) rather than executable lines (started with import) that install import hooks. See setuptools docand PEP 660 for more information.  Import hooks can provide an editable installation that offers a more accurate representation of the actual installation environment. However, since resolving module locations through an import hookrequires executing Python code at runtime, they are incompatible with Pyrefly and other static analysis tools that operate without code execution. Consequently, when an editable install is configured to use import hooks, Pyrefly will be unable to automatically locate and analyze the corresponding source files, resulting in incomplete type checking and code analysis.  Setuptools build system uses import hooks by default for editable installations. To ensure compatibility between setuptools-based editable installs and Pyrefly, setuptools must be configured to use path-based .pth files instead. This configuration should be performed through the build frontend (such as pip) by specifying the appropriate options during installation or in the project's configuration files.  ","version":"Next","tagName":"h2"},{"title":"uv with setuptools‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#uv-with-setuptools","content":" When using uv with setuptools, uv can beconfigured to avoid import hooks.  NOTE: The uv_build backend always uses path-based .pth files.  ","version":"Next","tagName":"h3"},{"title":"pip with setuptools‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#pip-with-setuptools","content":" When using pip with setuptools-based projects, there are two ways to avoid import hooks:compat modeand strict mode.  ","version":"Next","tagName":"h3"},{"title":"Hatch / Hatchling‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#hatch--hatchling","content":" Hatchling uses path-based .pth files by default. It will only use import hooks if you set dev-mode-exact to true.  ","version":"Next","tagName":"h3"},{"title":"PDM‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#pdm","content":" PDM uses path-based .pth files by default. It will only use import hooks if you seteditable-backend to &quot;editables&quot;.  ","version":"Next","tagName":"h3"},{"title":"Poetry / Poetry-core‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#poetry--poetry-core","content":" Poetry-core backend always uses path-based .pth files.  ","version":"Next","tagName":"h3"},{"title":"Debugging Import Issues‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#debugging-import-issues","content":" Pyrefly has a dump-config command that dumps the import-related config options it is using for each file it is checking. To use it, simply replace check with dump-config in your command-line invocation. ","version":"Next","tagName":"h2"},{"title":"Add Pyrefly to your IDE","type":0,"sectionRef":"#","url":"/en/docs/IDE/","content":"","keywords":"","version":"Next"},{"title":"Quick start‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#quick-start","content":" Install the Pyrefly extension from the VS Code Marketplace or Open VSX.Open any Python file and the extension will activate automatically.  tip Not seeing inlay hints in VS Code? Try setting editor.inlayHints.enabled to true in your VS Code settings.  tip Want type error squiggles to show up in VS Code? Try setting python.pyrefly.displayTypeErrors to &quot;force-on&quot; in your VS Code settings, or create a pyrefly.toml file in your project root.  ","version":"Next","tagName":"h2"},{"title":"Customization‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#customization","content":" By default, Pyrefly should work in the IDE with no configuration necessary. But to ensure your project is set up properly, see configurations.  The following configuration options are IDE-specific and exposed as VSCode settings:  Disable language services python.pyrefly.disableLanguageServices [boolean: false]: By default, Pyrefly will provide both type errors and other language features like go-to definition, intellisense, hover, etc. Set disableLanguageServices to true to keep type errors from Pyrefly unchanged but use VSCode's Python extension for everything else. Disable type errors python.pyrefly.displayTypeErrors [string: 'default']: If 'default', Pyrefly will only provide type check squiggles in the IDE if your file is covered by a Pyrefly configuration. If 'force-off', Pyrefly will never provide type check squiggles in the IDE. If 'force-on', Pyrefly will always provide type check squiggles in the IDE. Specify a custom Pyrefly Binary (lspPath) pyrefly.lspPath [string: '']: If your platform is not supported, you can build pyrefly from source and specify the binary path with the lspPath config. Use a specific interpreter If the Python VSCode extension is installed, selecting an interpreter will override the interpreter and settings Pyrefly uses to type check your project, even if one is specified in your Pyrefly configuration.python.defaultInterpreterPath will override the default interpreter selected by VSCode for your workspace.  ","version":"Next","tagName":"h2"},{"title":"Issues?‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#issues","content":" If you experience issues with the Pyrefly extension, please create an issue on github.  ","version":"Next","tagName":"h2"},{"title":"Other Editors‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#other-editors","content":" Support for other editors is community-driven. If you would like to set this up, please contribute.  ","version":"Next","tagName":"h2"},{"title":"Cursor and Windsurf‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#cursor-and-windsurf","content":" You can use Pyrefly in your favorite AI Editor that supports OpenVSX extensions. Search for &quot;Pyrefly&quot; in the extension marketplace and install it. Similar to VSCode, Pyrefly will automatically activate when you open a Python file. You will want to disable the other Python language server either by disabling it in the extension settings &quot;Language Server: None&quot; or by disabling the Pyright or BasedPyright extensions.    ","version":"Next","tagName":"h3"},{"title":"Jetbrains / Pycharm‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#jetbrains--pycharm","content":" An unofficial Jetbrains extension has been developed here  ","version":"Next","tagName":"h3"},{"title":"Neovim‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#neovim","content":" Pyrefly supports native Neovim support through lspconfig on Neovim 0.11+. Install and setup Pyrefly using the settings below.  The recommended way to set up Pyrefly in Neovim 0.11+ is:  Install or update the neovim/nvim-lspconfig, mason-org/mason.nvim, and mason-org/mason-lspconfig.nvim plugins with your plugin manager of choice.Add the following to your Neovim init.lua:  require(&quot;mason&quot;).setup() require(&quot;mason-lspconfig&quot;).setup()   In Neovim, run :MasonInstall pyrefly or add pyrefly to your ensure_installed options:  require(&quot;mason-lspconfig&quot;).setup { ensure_installed = { &quot;pyrefly&quot; }, }   Alternative setups and configurations While the above section describes the fastest way to set up Pyrefly, you may already have a setup or prefer to use other approaches for your lspconfig. Below we describe alternatives to both Pyrefly installation and configuration. note We don't provide instructions for setting up Neovim with versions prior to Neovim 0.11, though Pyrefly can work with them through neovim/nvim-lspconfig. Install Pyrefly for Neovim There are two methods we currently support for installing Pyrefly for Neovim: (recommended) Install the mason-org/mason.nvim plugin, which handles installing language services and configuring them easily.Use a system installation. mason.nvim mason.nvim is our recommended approach, since it makes Pyrefly and other language servers, linters, and utilities easily available to Neovim. note Installing a binary with Mason will take precedence over other system installations. It might be worth using system installations (including installations in virtual environments) if you need to switch between different versions of Pyrefly for different projects. Install Mason using your Neovim plugin manager of choice, and make sure you call its setup function to make it available. To install Pyrefly, run :MasonInstall pyrefly in Neovim, and it will be installed! You can install a specific version of Pyrefly with :MasonInstall pyrefly@&lt;version&gt;, and manage Mason installations (including per-language-server-specific settings!) with :Mason. System Installations Pyrefly can also work with Neovim's lspconfig when using a system installation. This will work as long as the Pyrefly binary you want to use is available on your $PATH, which you can check by making sure commands like pyrefly --help succeed. If an installation is available on your $PATH, continue on to configure below. To install Pyrefly, you can use the package manager of your choice. We support uv, pip, Cargo, and anything else that can interface with PyPI (see Installation for more info). note If you're installing Pyrefly into a virtual environment, please be aware that Pyrefly will only work within Neovim if the virtual environment is activated when you start Neovim. Before moving on, double check that you can access Pyrefly on your $PATH. If you can, then continue with configure. If Pyrefly is not available on your $PATH, you can try the following: If you're using a virtual environment, try source .venv/bin/activate to ensure your venv is running, then see if pyrefly is available.If you're using uv, you can ensure uv-installed tools are available on your path by running uv tool update-shell.Configure lspconfig to use a specific executable/command by updating your Pyrefly-specific lspconfig settings. To do this, override the cmd configuration option with your command in the configuration section below. Configure Pyrefly for Neovim This section describes how to tell Neovim how Pyrefly can be run, as well as how to override those settings. You have two options on how to do this: (recommended) Install or update the neovim/nvim-lspconfig plugin to get Pyrefly's (and other language servers') default configs. You can override specific settings if you'd like.Setup your language server manually without installing extra plugins. Configs with neovim/nvim-lspconfig plugin neovim/nvim-lspconfig is a Neovim plugin acting as a repository of language server settings (a repository of language server settings) installed and updated to get Pyrefly's default configuration. We also recommend installing or updating the mason-org/mason-lspconfig.nvim plugin if you're using Mason, which provides other nice functionality when using Mason with lspconfig. If you install mason-org/mason-lspconfig.nvim, be sure to source it in your Neovim config. To override specific settings, see :h vim.lsp.config. See :h vim.lsp.Config and :h vim.lsp.ClientConfig for values you can override, and the nvim-lspconfig Pyrefly config for default values. Example overriding cmd and filetypes vim.lsp.config('pyrefly', { -- example of how to run `uv` installed Pyrefly without adding to your path cmd = { 'uvx', 'pyrefly', 'lsp' } }) No-plugin Configs You have the option to setup your language server withoutneovim/nvim-lspconfig. Simply copy/modify the Pyrefly defaults fromnvim-lspconfigin a block like below. **NOTE: This should be in a file under nvim/lsp/pyrefly.lua ---@type vim.lsp.Config return { cmd = { &quot;pyrefly&quot;, &quot;lsp&quot; }, } tip This Youtube tutorial explains setting up a language server in more depth and with a more organized setup, so check it out if you want to learn more. Enable Pyrefly for Neovim If you've installed Pyrefly with Mason and have mason-org/mason-lspconfig.nvim installed, then your language server should just work! You can check by opening a file your language server should cover and running :checkhealth lsp to see if it's started. You may need to restart Neovim for any changes made above to take effect. Otherwise, to make sure your language servers are activated, be sure to enable them with the syntax below. vim.lsp.enable({&quot;pyrefly&quot;}) tip If you're using init.vim, you can use a lua heredoc to execute lua and enable your config.  ","version":"Next","tagName":"h3"},{"title":"Vim/Neovim + coc.nvim‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#vimneovim--cocnvim","content":" Ensure the pyrefly is on $PATH, add following snippet to your coc-settings.json:  &quot;languageserver&quot;: { &quot;pyrefly&quot;: { &quot;command&quot;: &quot;pyrefly&quot;, &quot;args&quot;: [&quot;lsp&quot;], &quot;filetypes&quot;: [&quot;python&quot;], &quot;rootPatterns&quot;: [&quot;pyrefly.toml&quot;, &quot;pyproject.toml&quot;, &quot;.git&quot;], } },   ","version":"Next","tagName":"h3"},{"title":"Vim + ALE‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#vim--ale","content":" Pull the latest version of ALE and add the following lines to your configuration to enable Pyrefly in Vim with ALE:  let g:ale_linters = { ... \\ 'python': ['pyrefly'], ... \\ }   ","version":"Next","tagName":"h3"},{"title":"Emacs‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#emacs","content":" There are several emacs packages that implement the language server protocol; the eglot package is built into recent versions of emacs. You can tell eglot to use pyrefly (which we assume is on your $PATH) with the following configuration:  (add-to-list 'eglot-server-programs `((python-ts-mode python-mode) . (&quot;pyrefly&quot; &quot;lsp&quot;)))   If you are using use-package, this command would run inside of the :config block; a minimal example would look like this:  (use-package eglot :ensure t :hook ((python-mode python-ts-mode) . eglot-ensure) :config (add-to-list 'eglot-server-programs `((python-ts-mode python-mode) . (&quot;pyrefly&quot; &quot;lsp&quot;))))   ","version":"Next","tagName":"h3"},{"title":"Helix‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#helix","content":" Ensure that pyrefly is on $PATH (If you got Pyrefly using pip install pyrefly, it should already be on your path). Add this snippet to your languages.toml file  [language-server.pyrefly] command = &quot;pyrefly&quot; args = [&quot;lsp&quot;] [[language]] name = &quot;python&quot; language-servers = [&quot;pyrefly&quot;]   ","version":"Next","tagName":"h3"},{"title":"Sublime‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#sublime","content":" See the documentation here.  ","version":"Next","tagName":"h3"},{"title":"Jupyter Lab‚Äã","type":1,"pageTitle":"Add Pyrefly to your IDE","url":"/en/docs/IDE/#jupyter-lab","content":" Pyrefly may be used in Jupyter Lab through the jupyterlab-lsp extension. ","version":"Next","tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/en/docs/installation/","content":"","keywords":"","version":"Next"},{"title":"Install‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#install","content":" You can use uv, poetry, pip, pixi or conda to install Pyrefly. The following commands show you how to install Pyrefly and run 2 basic commands: init and check.  pyrefly init will update your pyproject.toml file (or create a pyrefly.toml file) in your project directory, including some basic configuration. It will also attempt to migrate your existing type checker configuration.pyrefly check --summarize-errors will run the Pyrefly type checker on your project, providing a list of type errors and a summary of error types. The --summarize-errors flag is optional, remove it if you don't want summary stats.pyrefly check --suppress-errors will mark all existing errors as ignored, allowing you to start with a clean check.  Simply cd into your project directory and run:    PipCondaUVPoetryPixi pip install pyrefly pyrefly init pyrefly check --summarize-errors   ","version":"Next","tagName":"h2"},{"title":"Configure‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#configure","content":" You can set up a basic configuration file to type-check your project. You can add configuration options to a pyproject.toml file or create a pyrefly.toml file in your project directory. All configuration options are documented here.  [tool.pyrefly] search_path = [ &quot;example_directory/...&quot; ]   Then, run pyrefly check again, and the tool will use your configuration options.  The tool may return a list of type errors; this is perfectly normal. You have a few options at this point:  Use # pyrefly: ignore comments to silence the errors. This will get your project to a clean type-checking state, and you can reduce the number of errors as you go. We've included a script that can do this for you:  pyrefly check --suppress-errors   Use extra configuration options to silence specific categories of errors or exclude files with more errors than average.    ","version":"Next","tagName":"h2"},{"title":"Upgrading Pyrefly‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#upgrading-pyrefly","content":" Upgrading the version of Pyrefly you're using or a third-party library you depend on can reveal new type errors in your code. Fixing them all at once is often unrealistic. We've written scripts to help you temporarily silence them.  # Step 1 pyrefly check --suppress-errors   # Step 2 &lt;run your formatter of choice&gt;   # Step 3 pyrefly check --remove-unused-ignores   Repeat these steps until you achieve a clean formatting run and a clean type check.  This will add # pyrefly: ignore comments to your code, enabling you to silence errors and return to fix them later. This can make the process of upgrading a large codebase much more manageable.    ","version":"Next","tagName":"h2"},{"title":"Add Pyrefly to CI‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#add-pyrefly-to-ci","content":" After your project passes type checks without errors, you can prevent new bugs from being introduced. Enforce this through CI (Continuous Integration) to prevent other maintainers from merging code with errors. Here is an example for GitHub.  Save your workflow in the following path within your repository:  .github/workflows/typecheck.yml   GitHub automatically detects .yml files within .github/workflows/ and sets up the defined workflows.  name: Pyrefly Type Check on: pull_request: branches: [main] workflow_dispatch: # Allows manual triggering from the GitHub UI jobs: typecheck: runs-on: ubuntu-latest steps: - name: Check out code uses: actions/checkout@v4 - name: Set up Python uses: actions/setup-python@v5 # Install Python dependencies and create environment - name: Install dependencies and run type checking run: | python -m venv .venv source .venv/bin/activate python -m pip install --upgrade pip # Install your dependencies; adjust the following lines as needed pip install -r requirements-dev.txt - name: Install Pyrefly run: pip install pyrefly - name: Run Pyrefly Type Checker run: pyrefly check   ","version":"Next","tagName":"h2"},{"title":"A few notes about this setup:‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#a-few-notes-about-this-setup","content":" Building your environment and installing dependencies will enhance type safety by checking the types of imports. This is not required, but encouraged!Simply drop in pyrefly check to existing workflows that build and test your environment.   - name: Run Pyrefly Type Checker run: pyrefly check   Your pyrefly.toml or Pyrefly configs in your pyproject.toml will be automatically detected. Learn how to configure Pyrefly here.    ","version":"Next","tagName":"h3"},{"title":"Pre-commit‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#pre-commit","content":" Pyrefly provides a pre-commit hook so you can automatically type check files before they are committed.  We maintain a dedicated repository for this integration here: facebook/pyrefly-pre-commit  That repository contains:  Two pre-commit hooks depending on your setupInstallation instructionsExample configuration snippets for your project and CI  To get started, follow the setup steps in the repo‚Äôs README.  ","version":"Next","tagName":"h2"},{"title":"Install pre-commit‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#install-pre-commit","content":" You only need to do this once per clone. You can also include this in your as script or in your build/setup commands like setup.py or setup.cfg so it's installed for everyone.  # 1. Once per clone pip install pre-commit # or pipx install pre‚Äëcommit pre-commit install # writes .git/hooks/pre-commit # 2. Upgrade hooks when you bump versions in YAML pre-commit autoupdate # 3. Manual full run (good before the first push or when you add the hook) pre-commit run --all-files   ","version":"Next","tagName":"h3"},{"title":"Testing the hook‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#testing-the-hook","content":" 1. Introduce a cheap error  Edit any .py file and deliberately return None where the function is annotated to return int.  def foo() -&gt; int: return None   2. Stage &amp; commit  Output:  git add test.py git commit -m &quot;test: pre‚Äëcommit hook check&quot; pyrefly check............................................................Failed - hook id: pyrefly-typecheck-system - exit code: 1 INFO Checking project configured at `/myproject/pyrefly.toml` ERROR /myproject/test.py:2:12-16: Returned type `None` is not assignable to declared return type `int` [bad-return]   You should see Pyrefly fail as above, preventing the commit from being created.  3. Fix &amp; recommit  Correct the code, git add it again, and re‚Äërun git commit; this time the hook passes.  ","version":"Next","tagName":"h3"},{"title":"How this helps your project‚Äã","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#how-this-helps-your-project","content":" Earlier feedback: Developers see type mistakes immediately, not minutes later in CI.Consistent enforcement: Every commit‚Äîlocal or on CI‚Äîruns the same pyrefly check command.Clean history: Because Pyrefly checks before the commit object is created, you avoid &quot;fix type error&quot; fix‚Äëup commits.Culture of quality: Blocking problems at the doorstep raises the baseline for new contributors. ","version":"Next","tagName":"h3"},{"title":"Migrating from Mypy","type":0,"sectionRef":"#","url":"/en/docs/migrating-from-mypy/","content":"","keywords":"","version":"Next"},{"title":"Running Pyrefly‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#running-pyrefly","content":" Like mypy, pyrefly can be given a list of files to check:  $ pyrefly check file1.py file2.py   The easiest way to run pyrefly on all files in a project is to run it from the project root:  $ cd your/project $ pyrefly check   Pyrefly is designed to have sensible defaults, and you may not need to configure it at all. However, projects with existing mypy configs may want to configure pyrefly to suit their own needs.  ","version":"Next","tagName":"h2"},{"title":"Mypy Config Migration‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#mypy-config-migration","content":" To make it as easy as possible to get started with pyrefly, we've provided a script for automatically migrating a mypy config to pyrefly.  $ pyrefly init path/to/your/project   This will search for an existing mypy.ini or pyproject.toml with a tool.mypy section, and then transform it into a pyrefly.toml (or [tool.pyrefly] section) while preserving as many options as possible. See init --help for more options.  We do recommend checking the resulting config for errors. While there is some overlap between mypy's config options and pyrefly's config options, it's not always possible to cleanly translate one config option to another.  If you'd rather start fresh with a hand-written config, please see the pyrefly configuration docs. If you run into any issues with config migration, please let us know!  ","version":"Next","tagName":"h2"},{"title":"Config options‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#config-options","content":" The following config options make Pyrefly behave more like Mypy:  # By default, mypy does not check unannotated function bodies. The following flag will configure Pyrefly to match mypy's behavior: untyped_def_behavior = &quot;skip-and-infer-return-any&quot;   # If mypy is configured with `--check-untyped-defs` or `--strict` it will check function bodies where the function signature is unannotated. # The following flag will enable this behavior: untyped_def_behavior = &quot;check-and-infer-return-any&quot;   # Direct Pyrefly to respect `# mypy: ignore` and `# mypy: ignore-errors` comments permissive-ignores = true   ","version":"Next","tagName":"h3"},{"title":"Config Migration Details‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#config-migration-details","content":" files, modules, and packages are combined into project_includes. This should work exactly the same for files and packages. Mypy doesn't recurse into modules, but pyrefly will.  Pyrefly makes an effort to transform the exclude regex into a list of filepath globs for project_excludes. This should excel on simple regexes, such as some/file.py|exclude_dir/, which becomes [&quot;**/some/file.py&quot;, &quot;**/exclude_dir/&quot;].  The ignore_missing_imports per-module config option is turned into a list of modules. For example:  [mypy-some.*.module] ignore_missing_imports = True   Becomes:  replace_imports_with_any = [&quot;some.*.module&quot;]   Mypy's follow_imports = &quot;skip&quot; is handled the same way.  Pyrefly does support mypy's module name pattern syntax: see Module Globbing in the configuration docs.  Mypy's follow_untyped_imports option is allowed to be global or per-module. The pyrefly equivalent, use_untyped_imports, is only global. This setting defaults to true unless the follow_untyped_imports is disabled in the [mypy] section of the migrated config.  ","version":"Next","tagName":"h3"},{"title":"Mypy Error Codes and Pyrefly Error Kinds‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#mypy-error-codes-and-pyrefly-error-kinds","content":" Pyrefly maps Mypy's error codes to equivalent pyrefly error kinds. While not every error code has an equivalent error kind, we make an effort to ensure that pyrefly suppresses the same errors that mypy does.  This may lead to overly broad error suppressions, and you may want to consider removing some error kinds from the disable list. You can also use a SubConfig to selectively silence errors in specific files, or see Silencing Errors for how to suppress errors at the source.  See Error Kind Mapping for a table showing the relationship between type check diagnostic settings and error kinds.  ","version":"Next","tagName":"h3"},{"title":"Per-Module configs‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#per-module-configs","content":" Mypy's per-module configs let you change a wide range of configuration options for modules matching a module wildcard. Pyrefly's SubConfigs are a similar mechanism that let you configure pyrefly's behavior for files matching a filepath glob. However, they support significantly fewer options, and only disable_error_code and enable_error_code will be migrated over to the pyrefly config.  ","version":"Next","tagName":"h3"},{"title":"Silencing Errors‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#silencing-errors","content":" Like mypy, pyrefly has ways to silence specific error codes. Full details can be found in the Error Suppression docs  To silence an error on a specific line, add a disable comment above that line. You can either suppress all errors on that line:  # pyrefly: ignore x: str = 1   Or target a specific error type:  # pyrefly: ignore[bad-assignment] x: str = 1   To suppress all instances of an error, disable that error in the config:  [errors] import-error = false   This is equivalent to mypy's disable_error_code, though of course the error codes are different!  ","version":"Next","tagName":"h2"},{"title":"Error Kind Mapping‚Äã","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#error-kind-mapping","content":" This table shows the mapping between mypy's error codes and pyrefly's error kinds.  This table will be expanded as more diagnostics are supported.  Mypy\tPyreflyattr-defined\tmissing-attribute union-attr\tmissing-attribute ","version":"Next","tagName":"h3"},{"title":"Pyrefly Configuration","type":0,"sectionRef":"#","url":"/en/docs/configuration/","content":"","keywords":"","version":"Next"},{"title":"Simple Configuration Example‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#simple-configuration-example","content":" Here's an example of a simple config. To see more complex examples, including in a pyproject.toml, look atExample Configurations, which show Pyrefly's default config, as well as other ways you can set your configuration.  # set the directory Pyrefly will search for files to type check project-includes = [ &quot;a&quot;, &quot;b/c/d&quot;, &quot;e&quot; ] # manually set the `sys.platform` Pyrefly will assume when type checking python-platform = &quot;linux&quot; # return an import error when `&lt;library&gt;-stubs` can be imported, but no # non-stubs version of that library can be found ignore-missing-source = false # a table mapping error codes to an `is-enabled` boolean [errors] # disable `bad-assignment` errors bad-assignment = false # disable `bad-return` errors bad-return = false   ","version":"Next","tagName":"h2"},{"title":"Precedence in Options‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#precedence-in-options","content":" Configuration options are selected in the following order  CLI flags Examples: --project-excludes &lt;value&gt;, --python-version &lt;value&gt; Configuration options Examples: (in a pyrefly.toml) project-excludes = &lt;value&gt;, python-version = &lt;value&gt; Pyrefly defaults See Default pyrefly.toml for the default values used  ","version":"Next","tagName":"h2"},{"title":"Type Checking Modes‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#type-checking-modes","content":" Pyrefly has two different modes it can run in when type checking your project, which correspond to different but useful ways we expect most people to interact with Pyrefly:  Project mode: attempt to load a config, falling back to Pyrefly's default config when none can be found, and type check using that one config. This involves getting theproject-includes and project-excludes from the file, expanding the patterns, and type checking on those files. Project mode is used whenever no files are provided with the CLI invocation. Per-file or Single-file mode: when given FILES... (and optionally --project-excludes) during a CLI invocation, expand the patterns and find the relevant config file for each file listed. project-includes and project-excludes are ignored from the config file, but it is used for all remaining config options.  ","version":"Next","tagName":"h2"},{"title":"Configuration Finding‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-finding","content":" In both project checking mode and single-file checking mode (see Type Checking Modesfor more info), we attempt to find a project root from which to check each file, both for reading config options and for import resolution. The project root is typically the directory containing the configuration file. More precisely:  If a configuration file is provided with -c/--config, we use the directory the file is located in as the directory to check.If no configuration file is passed, we perform an upward file search from the 'start location' to the filesystem root, looking in each directory for any of the following files: pyrefly.toml, pyproject.toml,setup.py, mypy.ini, and pyrightconfig.json. If we find one, we use the directory it's found in as the containing directory.If no configuration file is found, we will still attempt to resolve imports by walking up the tree looking for a matching import. For example: when importing from a.b.c import q, if our project structure looks like /x/y/z/a/b/c, we can walk up the components of a.b.c to find a root at/x/y/z.  Note that only pyrefly.toml and pyproject.toml are parsed for config options, but we look for additional files that mark the root of a project to aid import resolution.  For project checking mode, the 'start location' is current working directory. For single-file checking mode, the start location is the directory containing each file to be type checked, and we find the config for each file matched by the pattern provided.  If a pyrefly.toml is found, it is parsed and used for type checking, and will return an error to the user on invalid types, syntax, values, or unknown config options.  If a pyproject.toml is found, Pyrefly will use the [tool.pyrefly]section if it exists, otherwise it will assume a default config. The same errors will be returned as when loading a pyrefly.toml if the config is invalid.  ","version":"Next","tagName":"h2"},{"title":"Providing a Config in Single-File Mode‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#providing-a-config-in-single-file-mode","content":" Providing -c/--config in single-file checking mode disables the upward file search for config files. All options are read from the provided config file except project-includes andproject-excludes, which are ignored.  ","version":"Next","tagName":"h3"},{"title":"Configuration Options‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-options","content":" The following section lists all recognized options that can be specified in a config file or pyproject.toml Pyrefly config section.  ","version":"Next","tagName":"h2"},{"title":"project-includes‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#project-includes","content":" The glob patterns used to describe which files to type check, typically understood as user-space files.  This does not specifyImport Resolution priority or the path an import should be resolved from. See search-path instead.  Type: list of filesystem glob patternsDefault: [&quot;**/*&quot;]Flag equivalent: FILES... argumentEquivalent configs: include in Pyright, files/modules/packages in mypyNotes: When overridden by passing in FILES..., we do not consult the relevant config file for what to use for project-excludes. If project-excludes should not use the default value, override it with the flag as well. This is because if multiple configs are loaded that conflict with project-includes, determining how to resolve checkable files gets complicated, and might become confusing to anyone attempting a type check if they're unaware of all the configs that will be used in the type check. Also, we get into a chicken-and-egg problem, where we don't know which files to exclude until we load all the configs we'll need, which requires loading all files, and imposes a large performance burden.When a project-includes pattern does not match any files, we will return an error.If you get an error about no matches for a directory when passing a glob as a CLI argument, try wrapping the glob in quotes to prevent eager shell glob expansion.  ","version":"Next","tagName":"h3"},{"title":"project-excludes‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#project-excludes","content":" The glob patterns used to describe which files to avoid type checking as way to filter files that match project-includes, but we don't want to type check.  Type: list of filesystem glob patternsDefault: [&quot;**/node_modules&quot;, &quot;**/__pycache__&quot;, &quot;**/*venv/**&quot;]Flag equivalent: --project-excludesEquivalent configs: exclude in Pyright and mypyNotes: While not explicitly part of project-excludes, there are several patterns that are filtered out of type checked files at our glob-implementation layer. Dotfiles (any files that begin with a dot (.&lt;stuff&gt;)Any files that don't end in .py or .pyiYour site-package-path (including paths queried from the interpreter) It is an error if no files are returned from any project-includes because they are filtered out by project-excludes entries. We differentiate between an error from a project-includes that doesn't match any files, and an error from all project-includes getting filtered by project-excludes.When overridden by passing in FILES..., we do not consult the relevant config file for what to use for project-excludes. If project-excludes should not use the default value, override it with the flag as well. See reasoning in project-includes notes.Your site-package-path is added to your project-excludesautomatically. If you are trying to perform type checking on a dependency in yoursite-package-path (i.e. cd &lt;site-package-path&gt;/some_dependency &amp;&amp; pyrefly check), we recommend you pull and set up your dependency from GitHub, but you can achieve this on files in your site-package-path by setting site-package-path = [] in your config.  ","version":"Next","tagName":"h3"},{"title":"search-path‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#search-path","content":" A file path describing the roots from which imports should be found and imported from (including modules in project-includes). This takes the highest precedence in import order, before typeshed and site-package-path. When a project-includestype checked file is imported by another type checked file, we check all search roots to determine how to import it.  Type: list of directories specifying the rootDefault: import rootFlag equivalent: --search-pathEquivalent configs: extraPaths in Pyright, mypy_path in mypyNotes: We automatically apply some heuristics to improve your experience, especially when no configuration is provided. Seedisable-search-path-heuristics to disable this behavior, and Search Path Heuristics for the additional paths we add to your search-path.Libraries should not be listed here, since they may override typeshedvalues for your whole project, and have different import semantics with respect to typing. SeeImport Resolutionfor more information about how modules are imported.  ","version":"Next","tagName":"h3"},{"title":"disable-search-path-heuristics‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#disable-search-path-heuristics","content":" Disable any search path heuristics/additional search path behavior that Pyrefly will attempt to do for you. This can be useful if Pyrefly is picking up the wrong import paths for your project, for example, if you have multiple projects in the same directory or use a monorepo setup with the import root outside of the directory your configuration is defined in.  See Search Path Heuristics for more information on the search paths that are automatically added, and are affected by this flag. For more information on import resultion in general see theimport resolution docs.  Type: boolDefault: falseFlag equivalent: --disable-search-path-heuristicsEquivalent configs: noneNotes To see what search path we find for your a given file in your project, or your project overall, you can run pyrefly dump-config [&lt;file&gt;...].  Search Path Heuristics‚Äã  Pyrefly adds extra search paths to your configuration behind-the-scenes to handle the most common ways of setting up and configuring your project, on top of anysearch-path entries you may pass in through the CLI or set in your config.  The two heuristics that are currently supported are:  Adding your import root to the end of your search path. Your import root is a src/ directory in the same directory as a config file, the parent directory containing your config file if there's an __init__.py or __init__.pyi presentor the config file's directory itself if none of the previously mentioned directories or files can be found. See Configuration Finding for more information on what we'll find as a config file.If no config can be found, each directory from the given file to / will be added as a fallback search path.  See more on how Pyrefly does import resolution.  ","version":"Next","tagName":"h3"},{"title":"site-package-path‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#site-package-path","content":" A file path describing a root from which imports should be found and imported from. This takes the lowest priority in import resolution, after search-path and typeshed.  See more on how Pyrefly does import resolution.  Type: list of directoriesDefault: result from Environment Autoconfiguration, or[] if the Python interpreter cannot be queriedFlag equivalent: --site-package-pathEquivalent configs: noneNotes: Ideally, this should not be set manually, unless you're using a venv, running one-off tests, testing specific behavior, or having trouble with Environment Autoconfiguration. Setting this explicitly, especially when not using a venv, will make it difficult for your configuration to be reused between different systems and platforms.If you're running into problems with editiable installations in your project, please read up on editable installs with static analysis tools.  ","version":"Next","tagName":"h3"},{"title":"python-platform‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python-platform","content":" The value used with conditions based on type checking againstsys.platformvalues.  Type: stringDefault: result from Environment Autoconfiguration, or &quot;linux&quot; if the Python interpreter cannot be queriedFlag equivalent: --python-platformEquivalent configs: pythonPlatform in Pyright, platform in mypy  ","version":"Next","tagName":"h3"},{"title":"python-version‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python-version","content":" The value used with conditions based on type checking againstsys.versionvalues. The format should be &lt;major&gt;[.&lt;minor&gt;[.&lt;micro&gt;]], where minor and micro can be omitted to take the default positional value.  Type: string of the format &lt;major&gt;[.&lt;minor&gt;[.&lt;micro&gt;]]Default: result from Environment Autoconfiguration, or3.13.0 if the Python interpreter cannot be queriedFlag equivalent: --python-versionEquivalent configs: pythonVersion in Pyright, python_version in mypy  ","version":"Next","tagName":"h3"},{"title":"conda-environment‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#conda-environment","content":" The name of the Conda environment to query when attempting to autoconfigure Python environment values (site-package-path, python-platform, python-version). See the Environment Autoconfiguration section for more information. We query Conda with conda info --envs, then find the environment's interpreter in Environment Autoconfirugration.  We will query Conda for information about this environment, even when it's not sourced, unless a Python environment (venv, Conda) is activated or --python-interpreter or--conda-environment are passed in through the CLI.  This configuration option is mutually exclusive with python-interpreter and skip-interpreter-query.  Type: string of existing Conda environment nameDefault: noneFlag equivalent: --conda-environmentEquivalent configs: noneNotes: This enables the use of a non-local but customizable global environment without having to hard-code a path, which is not preferable on a shared project.  ","version":"Next","tagName":"h3"},{"title":"python-interpreter‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python-interpreter","content":" The Python interpreter to query when attempting to autoconfigure Python environment values (site-package-path, python-platform, python-version). See the Environment Autoconfiguration section for more information.  This configuration option is mutually exclusive with conda-environment and skip-interpreter-query.  Type: path to executableDefault: $(which python3), then $(which python), or noneFlag equivalent: --python-interpreterEquivalent configs: python_executable in mypyNotes: This executes the value present in the python-interpreter field without any checks. It could be a security risk if your python-interpreter is an arbitrary executable.If you don't have a Python interpreter installed on your machine, we'll output an error letting you that we couldn't appropriately configure your environment. Configure skip-interpreter-query to skip the check and avoid the error.  NOTE: Ideally, this should not be set manually, unless you're using a venv, running one-off tests, testing specific behavior, or having trouble with Environment Autoconfiguration. Setting this explicitly, especially when not using a venv, will make it difficult for your configuration to be reused between different systems and platforms.  ","version":"Next","tagName":"h3"},{"title":"skip-interpreter-query‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#skip-interpreter-query","content":" Skip querying any interpreters and do not do anyEnvironment Autoconfiguration. This means that Pyrefly will take hard-coded defaults for python-versionand python-platform, and will use an emptysite-package-path. It's likely you'll want to override these to match the environment you'll be running in.  This configuration option is mutually exclusive with python-interpreter and conda-environment.  Type: boolDefault: falseFlag equivalent: --skip-interpreter-query  ","version":"Next","tagName":"h3"},{"title":"typeshed-path‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#typeshed-path","content":" Override the version of typeshed that's being used for type checking. The provided path should point to the root of typeshed.  Typeshed contains the type information for Python's standard library, which Pyrefly uses for type checking and resolving both the most basic types (like object, str, ...) and types/type signatures from stdlib modules.  Type: path to typeshedDefault: none (resolves to bundled typeshed)Flag equivalent: --typeshed-path  ","version":"Next","tagName":"h3"},{"title":"errors‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#errors","content":" Configure the severity for each kind of error that Pyrefly emits: error, warn, ignore.  Type: Table of error code to boolean representing enabled statusDefault: errors = {}/[errors]Flag equivalent: --error, --warn, --ignoreEquivalent configs:type check rule overridesand type evaluation settingsin Pyright,enable_error_code anddisable_error_codein mypyNotes: Setting &lt;error-code&gt; = true is the same as having no error code configuration present, which means the error will be shown. Setting &lt;error-code&gt; = false will disable the error for type checking.If you want to disable type errors in IDE mode, you can also setdisable-type-errors-in-ide, which will automatically disable all type errors and Pyrefly diagnostics in the IDE.  ","version":"Next","tagName":"h3"},{"title":"disable-type-errors-in-ide‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#disable-type-errors-in-ide","content":" Disables type errors from showing up when running Pyrefly in an IDE. This is primarily used when Pyrefly is acting in a language-server-only mode, but some kind of manual configuration is necessary for it to work properly, or when you wouldonly want to see type errors on CLI/CI runs.  Type: boolDefault: falseFlag equivalent: noneNotes: if you want to disable errors on CLI/CI runs as well, or if you're looking to turn on/off specific errors, you may be looking for the errors config option instead.  ","version":"Next","tagName":"h3"},{"title":"replace-imports-with-any‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#replace-imports-with-any","content":" Instruct Pyrefly to unconditionally replace the given ModuleGlobs with typing.Any and ignore import errors for the module. For example, with from x.y import z in a file, adding x.*, *.y, or x.y to this config will silence those import errors and replace the module with typing.Any. If the module can be found, its type information will still be replaced with typing.Any.  This is different from ignore-missing-imports, which only replaces the import with typing.Any if it can't be found.  Type: list of regexDefault: []Flag equivalent: --replace-imports-with-anyEquivalent configs: follow_imports = skip in mypy  ","version":"Next","tagName":"h3"},{"title":"ignore-missing-imports‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#ignore-missing-imports","content":" Instruct Pyrefly to replace the given ModuleGlobs with typing.Any and ignore import errors for the module only when the module can't be found.  For example, with from x.y import z in a file, adding x.*, *.y, or x.y to this config will silence those import errors and replace the module with typing.Anyif x.y can't be found. If x.y can be found, then z's type will be used.  This is different from replace-imports-with-any, which will always, unconditionally replace the import with typing.Any.  Type: list of regexDefault: []Flag equivalent: --ignore-missing-importsEquivalent configs: ignore_missing_imports in mypyNotes: errors = {import-error = false} (TOML inline table for errors) has similar behavior in Pyrefly, but ignoresall import errors instead of import errors from specific modules.When a .pyc file is encountered and no source/stub files are available, Pyrefly automatically treats module as typing.Any. This behavior ensures that compiled Python files without available source code do not cause import errors and are handled permissively.  ","version":"Next","tagName":"h3"},{"title":"ignore-errors-in-generated-code‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#ignore-errors-in-generated-code","content":" Whether to ignore type errors in generated code. If enabled, generated files will be treated as if they are included in project-excludes. The generated code status is determined by checking if the file contents contain the substring '@generated'.  Type: boolDefault: falseFlag equivalent: --ignore-errors-in-generated-codeEquivalent configs: none  ","version":"Next","tagName":"h3"},{"title":"ignore-missing-source‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#ignore-missing-source","content":" Whether to skip the check for a non-stubs package when a -stubs package is found insite-package-path. When this is true, we immediately return a -stubs package when found.  The check for a non-stubs package exists to ensure you have an importable package to use in your project. When this check returns an import error, it means we couldn't find a package, and that at runtime you may not actually be able to import the given package, even if its type stubs could be found. SeeStub Files vs Source Files for more information.  Type: boolDefault: trueFlag equivalent: --ignore-missing-sourceEquivalent configs: reportMissingModuleSource in Pyright  ","version":"Next","tagName":"h3"},{"title":"infer-with-first-use‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#infer-with-first-use","content":" Whether to infer type variables not determined by a call or constructor based on their first usage. This includes empty containers like [] and {}.  The default behavior is similar to Mypy - the type of the variable is inferred based on the first usage.  x = [] x.append(1) # x is list[int] x.append(&quot;2&quot;) # error!   Setting this to false will make Pyrefly infer Any for unsolved type variables, which behaves like Pyright.  x = [] # x is list[Any] x.append(1) # ok x.append(&quot;2&quot;) # ok   Type: boolDefault: trueFlag equivalent: --infer-with-first-use  ","version":"Next","tagName":"h3"},{"title":"untyped-def-behavior‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#untyped-def-behavior","content":" How should Pyrefly treat function definitions with no parameter or return type annotations?  By default, Pyrefly uses the &quot;check-and-infer-return-type&quot; behavior and will check all function bodies, inferring the return type.  info To provide inferred return types with check-and-infer-return-type, especially for site-package paths (third-party packages), Pyrefly may need to load and analyze more modules than you might otherwise see from mypy. This may result in increased type check durations or an output showing more modules analyzed than you expect. If this behavior is not preferred, you should setuntyped-def-behavior to skip-and-infer-return-any in your config or pass it in as a flag.  If this option is set to &quot;check-and-infer-return-any&quot;, then Pyrefly will still check the function body but will treat the return type as Any.  If this option is set to &quot;skip-and-infer-return-any&quot;, Pyrefly will again treat the return type as Any, but will also skip checking the function body. In this case, Pyrefly will also infer Any as the type of any attributes inferred based on this function body. This behavior is what PEP 484 specifies, although we do not recommend it for most users today; since Pyrefly will not analyze the bodies of untyped functions, language server functionality like showing types on hover and finding definitions will not be available there.  info skip-and-infer-return-any is mypy's default inference behavior, and how we will attempt to migrate your existing mypy configuration when running pyrefly init. See Migrating from Mypy for more information on config migration.  Type: one of &quot;check-and-infer-return-type&quot;, &quot;check-and-infer-return-any&quot;,&quot;skip-and-infer-return-any&quot;Default: &quot;check-and-infer-return-type&quot;Flag equivalent: --untyped-def-behaviorEquivalent configs: The &quot;check-and-infer-return-type&quot; behavior emulates Pyright's default behavior.The &quot;skip-and-infer-return-any&quot; behavior emulates mypy's default behavior.The &quot;check-and-infer-return-any&quot; behavior emulates mypy'scheck_untyped_defs flag.  ","version":"Next","tagName":"h3"},{"title":"use-ignore-files‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#use-ignore-files","content":" Whether to allow Pyrefly to use ignore files in your project and automatically add excluded files and directories to your project-excludes. Similar to project-excludes, when explicitly specifying files to check, ignore files are not used.  Pyrefly automatically searches for ignore files such as .gitignore, .ignore, and .git/info/excludes in an upward search from your project root. Only the first of each type of ignore file will be used, so if you have a .gitignore and .git/info/excludesavailable, in different directories, Pyrefly will use both of them. Pyrefly will not use global ignore files.  When multiple ignore files are found, Pyrefly checks them for excludes matches when determining the files to type check in the order of .gitignore, .ignore, and.git/info/excludes, taking the result of the first ignore file that has a match (either allowlist or denylist). Regular.gitignore-style allowlist/denylist matching rules apply.  Type: boolDefault: trueFlag equivalent: --use-ignore-files  ","version":"Next","tagName":"h3"},{"title":"permissive-ignores‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#permissive-ignores","content":" Should Pyrefly ignore errors based on annotations from other tools, e.g. # pyre-ignore or # mypy: ignore? By default, respects # pyrefly: ignore and # type: ignore.  Type: boolDefault: falseFlag equivalent: --permissive-ignores  ","version":"Next","tagName":"h3"},{"title":"sub-config‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#sub-config","content":" Override specific config values for matched paths in your project. SeeSubConfigs for more information on the structure and values that can be overridden here.  Type: TOML array of tables with a SubConfig structureDefault: []Flag equivalent: noneEquivalent configs: executionEnvironments in Pyright, per-module config options in mypy  ","version":"Next","tagName":"h3"},{"title":"Configuration Details‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-details","content":" This section describes some of the configuration options, behaviors, or types in more depth, when there are details shared between multiple config options or the information is more than what can fit under a single config option description.  ","version":"Next","tagName":"h2"},{"title":"Environment Autoconfiguration‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#environment-autoconfiguration","content":" Unless skip-interpreter-query is set, we'll attempt to query a Python interpreter to determine your python-platform orpython-version if they're unset. We also get asite-package-path from your interpreter to determine which packages you have installed and append those to the end of any site-package-pathyou've configured yourself, either through CLI flags or a config file.  We look for an interpreter with the following logic:  Use python-interpreter orconda-environment if either are set by a flag. Both cannot be set in flags at the same time.Determine if there's an active venv or conda environment. If both are active at the same time, we take venv over conda.Use python-interpreter orconda-environment if either are set in a config file. Both cannot be set in a config at the same time.Find a venv at the root of the project by searching for something that looks like a Python interpreter (matches python(\\d(\\.\\d+)?)?(.exe)? regex), and looking for a pyvenv.cfg file in known locations. If we can't determine the root of your project with a config file or other well-known root marker file (e.g. setup.py,pyrightconfig.json, mypy.ini), this step is skipped.Query $(which python3) and $(which python) (platform independent) to use a system-installed interpreter.Fall back to Pyrefly's default values for any unspecified config options.  The config options we query the interpreter for are:  python-platform: sys.platformpython-version: sys.version_info[:3]site-package-path: site.getsitepackages() + [site.getusersitepackages()]  info You can run pyrefly dump-config and pass in your file or configuration like you would with pyrefly check to see what Pyrefly finds for your Python interpreter andsite-package-path, along with other useful config-debugging features.  ","version":"Next","tagName":"h3"},{"title":"Filesystem Globbing‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#filesystem-globbing","content":" We use a standard Unix-style glob, which allows for wildcard matching when specifying a fileset. It is similar to regex, but more restricted given the subset of allowed syntax for paths on a filesystem. We currently only allow matching files with a .py, .pyi, or .pyw suffix.  The globs provided are relative to the config, if one is found, or the current working directory otherwise. Absolute path globs can also be provided, though this is generally not recommended, since it may not be compatible with other systems type checking your project.  We recognize the following wildcards: * matches zero or more characters in a single directory component** matches the current and any sub directories/files in those sub directories? matches any one character[&lt;pattern&gt;] matches any character or character range between the brackets (character range separated by -)[!&lt;pattern&gt;] excludes any character or character range between the brackets and after the !Note: [] can be used to match ?, *, [, ] literally (e.g. [?]), although these are invalid as part of a Python path.  We also support non-wildcard paths, so a relative (or absolute) path like src/ will match all Python files under src/or src/my_file.py will match src/my_file.py exactly.  Any directories matched will also have their .py and .pyi files recursively matched. src/* will match all files and directories under src/, so therefore, we will recursively match everything under src/.  Examples:  src/**/*.py: only match .py files under src/src, src/, src/*, src/**, and src/**/*: match all .py and .pyi files under `src/?.py and [A-z].py: match any file that looks like &lt;letter&gt;.pysrc/path/to/my/file.py: only match src/path/to/my/file.pysrc/**/tests, src/**/tests/, src/**/tests/**, and src/**/tests/**/*: match all .py and .pyi files in src/under a directory named tests  ","version":"Next","tagName":"h3"},{"title":"Module Globbing‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#module-globbing","content":" In some config options, we've added globbing for module paths. This is different from both path globs and regex, in the sense that we're performing a match on a Python dotted import, such as this.is.any.module. The only wildcard we recognize is *, which represents zero or more segments of a module path, unless it starts a glob, in which case it must match one or more segments. The wildcard must be surrounded by ., unless it is at the start or end of a module glob.  Examples:  this.is.a.module would be equivalent to a regex like ^this\\.is\\.a\\.module. It will only match imports that look likethis.is.a.module.this.is.*.module would become ^this\\.is(\\..+)*\\.module$. It would match: this.is.modulethis.is.a.modulethis.is.a.really.long.path.to.a.module *.my.module would be equivalent to a regex like ^.+\\.my\\.module$. It would match: this.is.my.moduleheres.my.module It will not match: my.module this.is.* would be equivalent to a regex like ^this\\.is(\\..+)*. It would match: this.is.my.modulethis.is  ","version":"Next","tagName":"h3"},{"title":"Sub-Configs‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#sub-configs","content":" Sub-Configs are a method for overriding one or more config options for specific files based on filepath glob matching. Only certain config options are allowed to be overridden, and a need to override other configs means you likely need to use a separate config file for your subdirectory. You can have as many SubConfigs as you want in a project, and even multiple separate SubConfigs that can apply to a given file when the matches glob pattern matches.  SubConfig Allowed Overrides‚Äã  We currently allow the following config options to be overridden in a SubConfig:  errorsreplace-imports-with-anyuntyped-def-behaviorignore-errors-in-generated-code  All SubConfig overrides replace the values appearing in the 'root' or top-level of the Pyrefly configuration.  Any configs that change the list of files we're type checking, Python environment, or where we look for imports cannot be included in SubConfigs. Some other configs we also do not include because we think they make it difficult to reason about your project type checks, but you canopen an issue or make a pull request if you disagree and would like to see the option supported.  SubConfig Table Structure‚Äã  A SubConfig has two or more entries:  a matches key, with a Filesystem Glob detailing which files the config applies to.at least one of the SubConfig allowed overrides  SubConfig Option Selection‚Äã  Since you can have more than one SubConfig matching a file, we need to define a resolution order to determine which SubConfig's option should be selected. Pyrefly does this by filtering SubConfigs whose matches does not match the given file, then takes the first non-null value that can be found in the order the SubConfigs appear in your configuration.  If no SubConfigs match, or there are no non-null config options present, then we take the value in the 'root'/top-level Pyrefly config (or Pyrefly default if no value is specified).  SubConfig Example‚Äã  For the following config, this how options would be resolved.  replace-imports-with-any = [ &quot;sympy.*&quot;, &quot;*.series&quot;, ] ignore-errors-in-generated-code = true # disable `bad-assignment` and `invalid-argument` for the whole project [errors] bad-assignment = false invalid-argument = false [[sub-config]] # apply this to `sub/project/tests/file.py` matches = &quot;sub/project/tests/file.py&quot; # any unittest imports will by typed as `typing.Any` replace-imports-with-any = [&quot;unittest.*&quot;] [[sub-config]] # apply this config to all files in `sub/project` matches = &quot;sub/project/**&quot; # enable `assert-type` errors in `sub/project` [sub-config.errors] assert-type = true [[sub-config]] # apply this config to all files in `sub` matches = &quot;sub/**` # disable `assert-type` errors in `sub` [sub-config.errors] assert-type = false [[sub-config]] # apply this config to all files under `tests` dirs in `sub/` matches = &quot;sub/**/tests/**&quot; # any pytest imports will be typed as `typing.Any` replace-imports-with-any = [&quot;pytest.*&quot;]   sub/project/tests/file.py replace-imports-with-any: [&quot;unittest.*&quot;]errors: {assert-type = true}ignore-errors-in-generated-code: trueignore-missing-source: true sub/project/tests/another_file.py replace-imports-with-any: [&quot;pytest.*&quot;]errors: {assert-type = true}ignore-errors-in-generated-code: trueignore-missing-source: true sub/project/non_test_file.py replace-imports-with-any: [&quot;sympy.*&quot;, &quot;*.series&quot;]errors: {assert-type = true}ignore-errors-in-generated-code: trueignore-missing-source: true sub/sub_file.py replace-imports-with-any: [&quot;sympy.*&quot;, &quot;*.series&quot;]errors: {assert-type = false}ignore-errors-in-generated-code: trueignore-missing-source: true top_level_file.py replace-imports-with-any: [&quot;sympy.*&quot;, &quot;*.series&quot;]errors: {assert-type = true, bad-assignment = false, invalid-argument = false}ignore-errors-in-generated-code: trueignore-missing-source: true  ","version":"Next","tagName":"h3"},{"title":"Conda and Venv Support‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#conda-and-venv-support","content":" We plan on adding extra automatic support for Condaand Venv at some point soon, but we haven't made it around to doing this yet. If you would like to import packages from these in the meantime, you can follow the following steps.  ","version":"Next","tagName":"h3"},{"title":"Venv‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#venv","content":" If you have a venv set up locally, you can get Pyrefly working with it by having your venv sourced in your shell (source .venv/bin/activate), and we will automatically pick up your installed packages. To pick up your packages even when your environment isn't sourced, you can add .venv/bin/python3 (or&lt;path_to_venv&gt;/bin/python3) to your Pyrefly configuration underpython-interpreter or pass it in with the --python-interpreter flag.  ","version":"Next","tagName":"h3"},{"title":"Conda‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#conda","content":" If you have conda set up locally, you can get Pyrefly working with it by having your Conda environment sourced in your shell (conda activate &lt;environment&gt;), and we will automatically pick up your installed packages. To pick up your packages even when your environment isn't sourced, you can query your environment's install location with conda env list, and add &lt;conda_environment_path&gt;/bin/python3 to your Pyrefly configuration under python-interpreter or pass it in with the --python-interpreter flag.  ","version":"Next","tagName":"h3"},{"title":"Example Configurations‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-configurations","content":" This section displays an example config showing the usage of all config options listed above to make creating your own easier, and to give you an easy place to start.  ","version":"Next","tagName":"h2"},{"title":"Default pyrefly.toml‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#default-pyreflytoml","content":" This is a configuration with the Pyrefly defaults. If you have an interpreter installed, some of these values may be overridden.  ###### configuring what to type check and where to import from # check all files in &quot;.&quot; project-includes = [&quot;.&quot;] # exclude dotfiles project-excludes = [&quot;**/.[!/.]*&quot;, &quot;**/*venv/**&quot;] # perform an upward search for `.gitignore`, `.ignore`, and `.git/info/exclude`, and # add those to `project-excludes` automatically use-ignore-files = true # import project files from &quot;.&quot; search-path = [&quot;.&quot;] # let Pyrefly try to guess your search path disable-search-path-heuristics = false # do not include any third-party packages (except those provided by an interpreter) site-package-path = [] ###### configuring your python environment # assume we're running on linux, regardless of the actual current platform python-platform = &quot;linux&quot; # assume the Python version we're using is 3.13, without querying an interpreter python-version = &quot;3.13&quot; # is Pyrefly disallowed from querying for an interpreter to automatically determine your # `python-platform`, `python-version`, and extra entries to `site-package-path`? skip-interpreter-query = false # query the default Python interpreter on your system, if installed and `python_platform`, # `python-version`, or `site-package-path` are unset. # python-interpreter = null # this is commented out because there are no `null` values in TOML #### configuring your type check settings # wildcards for which Pyrefly will unconditionally replace the import with `typing.Any` replace-imports-with-any = [] # wildcards for which Pyrefly will replace the import with `typing.Any` if it can't be found ignore-missing-imports = [] # should Pyrefly skip type checking if we find a generated file? ignore-errors-in-generated-code = false # should Pyrefly do a check to see if a `&lt;library&gt;-stubs` library also has `&lt;library&gt;` installed? ignore-missing-source = false # what should Pyrefly do when it encounters a function that is untyped? untyped-def-behavior = &quot;check-and-infer-return-type&quot; # can Pyrefly recognize ignore directives other than `# pyrefly: ignore` and `# type: ignore` permissive-ignores = false [errors] # this is an empty table, meaning all errors are enabled by default # no `[[sub-config]]` entries are included, since there are none by default   ","version":"Next","tagName":"h3"},{"title":"Example pyrefly.toml‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-pyreflytoml","content":" project-includes = [&quot;src&quot;] project-excludes = [&quot;**/.[!/.]*&quot;, &quot;**/tests&quot;] search-path = [&quot;src&quot;] site-package-path = [&quot;venv/lib/python3.12/site-packages&quot;] python-platform = &quot;linux&quot; python-version = &quot;3.12&quot; python-interpreter = &quot;venv/bin/python3&quot; replace-imports-with-any = [ &quot;sympy.*&quot;, &quot;*.series&quot;, ] ignore-errors-in-generated-code = true ignore-missing-source = true # disable `bad-assignment` and `invalid-argument` for the whole project [errors] bad-assignment = false invalid-argument = false [[sub-config]] # apply this to `sub/project/tests/file.py` matches = &quot;sub/project/tests/file.py&quot; # any unittest imports will by typed as `typing.Any` replace-imports-with-any = [&quot;unittest.*&quot;] [[sub-config]] # apply this config to all files in `sub/project` matches = &quot;sub/project/**&quot; # enable `assert-type` errors in `sub/project` [sub-config.errors] assert-type = true   ","version":"Next","tagName":"h3"},{"title":"Example pyproject.toml‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-pyprojecttoml","content":" ... # Pyrefly header [tool.pyrefly] #### configuring what to type check and where to import from project-includes = [&quot;src&quot;] project-excludes = [&quot;**/.[!/.]*&quot;, &quot;**/tests&quot;] search-path = [&quot;src&quot;] site-package-path = [&quot;venv/lib/python3.12/site-packages&quot;] #### configuring your python environment python-platform = &quot;linux&quot; python-version = &quot;3.12&quot; python-interpreter = &quot;venv/bin/python3&quot; #### configuring your type check settings replace-imports-with-any = [ &quot;sympy.*&quot;, &quot;*.series&quot;, ] ignore-errors-in-generated-code = true ignore-missing-source = true [tool.pyrefly.errors] bad-assignment = false invalid-argument = false [[tool.pyrefly.sub-config]] # apply this config to all files in `sub/project` matches = &quot;sub/project/**&quot; # enable `assert-type` errors in `sub/project` [tool.pyrefly.sub-config.errors] assert-type = true [[tool.pyrefly.sub-config]] # apply this config to all files in `sub` matches = &quot;sub/**` # disable `assert-type` errors in `sub/project` [tool.pyrefly.sub-config.errors] assert-type = false # other non-Pyrefly configs ...  ","version":"Next","tagName":"h3"},{"title":"Migration Guides","type":0,"sectionRef":"#","url":"/en/docs/migrating-to-pyrefly/","content":"","keywords":"","version":"Next"},{"title":"Migration Guides‚Äã","type":1,"pageTitle":"Migration Guides","url":"/en/docs/migrating-to-pyrefly/#migration-guides","content":" Migrating from Mypy - Guide for transitioning from Mypy to PyreflyMigrating from Pyright - Guide for transitioning from Pyright to Pyrefly  Choose the appropriate guide based on your current type checker to get started with your migration to Pyrefly. ","version":"Next","tagName":"h2"},{"title":"Migrating from Pyright","type":0,"sectionRef":"#","url":"/en/docs/migrating-from-pyright/","content":"","keywords":"","version":"Next"},{"title":"Running Pyrefly‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#running-pyrefly","content":" Like pyright, pyrefly can be given a list of files to check:  $ pyrefly check file1.py file2.py   The easiest way to run pyrefly on all files in a project is to run it from the project root:  $ cd your/project $ pyrefly check   Pyrefly doesn't need a config file to start checking your code. Its sensible defaults are designed to work well for most projects. However, projects with existing pyright configs may want to configure pyrefly to suit their own needs.  ","version":"Next","tagName":"h2"},{"title":"Pyright Config Migration‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#pyright-config-migration","content":" To make it as easy as possible to get started with pyrefly, we've provided a script for automatically migrating a pyright config to pyrefly.  $ pyrefly init path/to/your/project   This will search for an existing pyrightconfig.json or pyproject.toml with a tool.pyright section, and then transform it into a pyrefly.toml (or [tool.pyrefly] section) while preserving as many options as possible. See init --help for more options.  There is a significant overlap between pyright's and pyrefly's configuration options, so migration is pretty straightforward. However, it may be worth checking the generated config for errors, just in case.  If you'd rather start fresh with a hand-written config, please see the pyrefly configuration docs. If you run into any issues with config migration, please let us know!  ","version":"Next","tagName":"h2"},{"title":"Config Migration Details‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#config-migration-details","content":" When it comes to listing files, pyright uses just paths, while pyrefly supports glob patterns. Thankfully, paths are a subset of glob patterns, so pyrefly can just use the paths as-is. You could consider manually simplifying the paths into glob patterns, but it's not necessary.  Pyright supports four platforms: Windows, Linux, Darwin (macOS), and All. Since pyrefly only supports Python's supported platforms, we choose to treat &quot;All&quot; as &quot;linux&quot;.  ","version":"Next","tagName":"h2"},{"title":"Type Check Diagnostic Settings and Error Kinds‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#type-check-diagnostic-settings-and-error-kinds","content":" Pyrefly maps pyright's type check diagnostics settings to equivalent pyrefly error kinds. While not every diagnostic setting has an equivalent error kind, we make an effort to ensure that pyrefly suppresses the same errors that pyright does.  This may lead to overly broad error suppressions, and you may want to consider removing some error kinds from the disable list. You can also use a SubConfig to selectively silence errors in specific files, or see Silencing Errors for how to suppress errors at the source.  See Error Kind Mapping for a table showing the relationship between type check diagnostic settings and error kinds.  ","version":"Next","tagName":"h3"},{"title":"Execution Environments‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#execution-environments","content":" Pyright's execution environments let you customize the Python version, platform, module search paths, and diagnostic settings for some part of your project. Pyrefly's SubConfigs are a similar mechanism that let you configure pyrefly's behavior for files matching a filepath glob. However, subconfigs do not support changing the Python version, platform, or module search paths.  Diagnostic settings are carried over to the equivalent subconfig, using the mapping mentioned above.  ","version":"Next","tagName":"h3"},{"title":"Silencing Errors‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#silencing-errors","content":" Like pyright, pyrefly has ways to silence specific error codes. Full details can be found in the Error Suppression docs.  To silence an error on a specific line, add a disable comment above that line. You can either suppress all errors on that line:  # pyrefly: ignore x: str = 1   Or target a specific error type:  # pyrefly: ignore[bad-assignment] x: str = 1   To suppress all instances of an error, disable that error in the config:  [errors] import-error = false   This is similar to pyright's type check rule overrides, though of course the error codes are different!  You can also use:  permissive-ignores = true   To allow pyright: ignore comments to be used by Pyrefly.  ","version":"Next","tagName":"h2"},{"title":"Error Kind Mapping‚Äã","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#error-kind-mapping","content":" This table shows the mapping between pyright's type check diagnostics settingsand pyrefly's error kinds.  This table will be expanded as more diagnostics are supported.  Pyright\tPyreflyreportMissingImports\timport-error reportMissingModuleSource\timport-error ","version":"Next","tagName":"h2"},{"title":"Experimental Pydantic Support","type":0,"sectionRef":"#","url":"/en/docs/pydantic/","content":"","keywords":"","version":"Next"},{"title":"Feedback‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#feedback","content":" We welcome your feedback and suggestions. Please share your thoughts and ideas here.    ","version":"Next","tagName":"h3"},{"title":"What is Pydantic?‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#what-is-pydantic","content":" Pydantic is a Python library designed for data validation and parsing using Python type annotations. While it shares similarities with dataclasses in creating structured data containers, Pydantic additionally provides extensive runtime data validation.    ","version":"Next","tagName":"h2"},{"title":"Validation Modes‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#validation-modes","content":" Pydantic supports two validation modes for Pydantic models:  Lax (Default): Values are automatically converted when possible. For example, the string &quot;123&quot; will be interpreted as an integer.Strict: Coercion is disabled, and only exactly matching types are accepted.  Pyrefly reads your model config to determine the validation mode, so it can strike a balance between providing useful typing and IDE support while maintaining Pydantic's flexibility.    ","version":"Next","tagName":"h2"},{"title":"How Pyrefly Supports Pydantic‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#how-pyrefly-supports-pydantic","content":" Understands Pydantic constructs like BaseModel, Field, ConfigDict, and model-level config options.Performs static analysis that mirrors Pydantic‚Äôs runtime validation logic, minimizing false positives in your IDE.Provides immediate feedback (e.g. red squiggles or type errors) when the code would fail under Pydantic's actual behavior.Does not require a plugin or manual config ‚Äî support is builtin and automatic.    ","version":"Next","tagName":"h2"},{"title":"Comparison to Existing Tools‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#comparison-to-existing-tools","content":" Mypy‚Äôs Pydantic plugin has five configuration options to control how strict the checking is ‚Äî for example, whether coercion is allowed or extra fields are permitted.Pyrefly works differently. It doesn't rely on external config. Instead, it inspects your code directly ‚Äî things like strict=True or extra='forbid' and strikes a balance between Pydantic's flexibility and Pyrefly's type checking.    ","version":"Next","tagName":"h2"},{"title":"How to Use‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#how-to-use","content":" You don‚Äôt need to enable or configure anything to use Pyrefly‚Äôs Pydantic support.  Just:  Install pydantic (preferably v2).Write your Pydantic models as usual.Run Pyrefly on your code.  Pyrefly will recognize Pydantic constructs like BaseModel, Field, and model_config, and provide appropriate type checking automatically.    ","version":"Next","tagName":"h2"},{"title":"Examples‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#examples","content":" ","version":"Next","tagName":"h2"},{"title":"Immutable fields with ConfigDict‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#immutable-fields-with-configdict","content":" from pydantic import BaseModel, ConfigDict # Marking a model as frozen (immutable) class Model(BaseModel): model_config = ConfigDict(frozen=True) x: int = 42 m = Model() m.x = 10 # Error: Cannot set field `x` because the model is frozen   ","version":"Next","tagName":"h3"},{"title":"Strict vs Non-Strict Field Validation‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#strict-vs-non-strict-field-validation","content":" from pydantic import BaseModel, Field # Non-strict mode: runtime coercion allowed class User(BaseModel): name: str age: int # This passes at runtime and in Pyrefly. y = User(name=&quot;Alice&quot;, age=&quot;30&quot;) # Strict mode: enforce exact types, no coercion class User2(BaseModel): name: str age: int = Field(strict=True) # This triggers type errors in Pyrefly and red squiggles in the IDE, # and will also fail at runtime due to type mismatch. z = User2(name=&quot;Alice&quot;, age=&quot;30&quot;)   ","version":"Next","tagName":"h3"},{"title":"Handling Extra Fields in Pydantic Models‚Äã","type":1,"pageTitle":"Experimental Pydantic Support","url":"/en/docs/pydantic/#handling-extra-fields-in-pydantic-models","content":" By default, Pydantic models allow extra fields (fields not defined in the model) to be passed during initialization. This behavior is consistent with Pyrefly‚Äôs support, which follows the default extra='allow' behavior.  from pydantic import BaseModel # Extra fields allowed by default class ModelAllow(BaseModel): x: int # This works fine: extra field `y` is allowed and ignored ModelAllow(x=1, y=2) # Explicitly forbid extra fields by setting `extra='forbid'` class ModelForbid(BaseModel, extra=&quot;forbid&quot;): x: int # This will raise a type error because of unexpected field `y`, which is consistent with runtime behavior. ModelForbid(x=1, y=2)  ","version":"Next","tagName":"h3"},{"title":"Pyrefly Error Kinds","type":0,"sectionRef":"#","url":"/en/docs/error-kinds/","content":"","keywords":"","version":"Next"},{"title":"annotation-mismatch‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#annotation-mismatch","content":" This error indicates a mismatch between multiple annotations for a single variable. This is relatively uncommon, but it can happen in if-statements:  if some_cond: x: int = 1 else: x: str = &quot;two&quot; # Inconsistent type annotations for x: str, int [annotation-mismatch]   It can be helpful to annotate the variable before branch, especially if there is a useful default value for it. For example:  x: str = &quot;default&quot; if some_cond: x = &quot;actual value&quot;   ","version":"Next","tagName":"h2"},{"title":"assert-type‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#assert-type","content":" An assert-type error is raised when a typing.assert_type() call fails.  This error kind should never be suppressed, since that rather defeats the point of of typing.assert_type().  ","version":"Next","tagName":"h2"},{"title":"async-error‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#async-error","content":" async-error is reported when attempting to await on something that is not awaitable. This may indicate that a function should have been marked async but wasn't.  def some_func() -&gt; None: ... await some_func() # Expression is not awaitable [async-error]   This will also arise if the context manager used in an async with statement has __aenter__ and __aexit__ methods that are not marked async.  The fix is to use an async function in the await. This may mean making the function async or finding an existing async function to use instead.  ","version":"Next","tagName":"h2"},{"title":"bad-argument-count‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-argument-count","content":" This error arises when a function is called with the wrong number of arguments.  def takes_three(one: int, two: int, three: int) -&gt; complex: ... take_three(3, 2) # Expected 1 more positional argument [bad-argument-count]   Note that missing-argument will be raised if pyrefly can identify that specific arguments are missing. As such, this error is more likely to appear when too many args are supplied, rather than too few.  This example shows both kinds of errors:  from typing import Callable def apply(f: Callable[[int, int], int]) -&gt; int: return f(1) # Expected 1 more positional argument [bad-argument-count] apply() # Missing argument `f` in function `apply` [missing-argument]   ","version":"Next","tagName":"h2"},{"title":"bad-argument-type‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-argument-type","content":" This error indicates that the function was called with an argument of the wrong type.  def example(x: int) -&gt; None: ... example(&quot;one&quot;) # Argument `Literal['two']` is not assignable to parameter `x` with type `int` in function `example` [bad-argument-type]   This can also happen with *args and **kwargs:  def bad_args(*args: int) -&gt; None: ... bad_args(1, &quot;two&quot;) # Argument `Literal['two']` is not assignable to parameter with type `int` in function `bad_args` [bad-argument-type]   def bad_kwargs(**kwargs: int) -&gt; None: ... bad_args(x=1, y=&quot;two&quot;) # Keyword argument `y` with type `Literal['two']` is not assignable to kwargs type `int` in function `bad_kwargs` [bad-argument-type]   ","version":"Next","tagName":"h2"},{"title":"bad-assignment‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-assignment","content":" The most common cause of this error is attempting to assign a value that conflicts with the variable's type annotation.  x: str = 1 # `Literal[1]` is not assignable to `str` [bad-assignment]   However, it can occur in several other situations.  Here, x is marked as Final, so assigning a new value to it is an error.  from typing import Final x: Final = 1 x = 2 # `x` is marked final [bad-assignment]   In another case, attempting to annotate an assignment to an instance attribute raises this error.  class A: x: int a = A() a.x: int = 2 # Type cannot be declared in assignment to non-self attribute `a.x` [bad-assignment]   ","version":"Next","tagName":"h2"},{"title":"bad-class-definition‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-class-definition","content":" This error indicates that there is something wrong with the class definition. It tends to be a bit rarer, since most issues would be tagged with other error kinds, such asannotation-mismatch or one of the function errors. inheritance has its own complexities, so it has its own error kind called invalid-inheritance.  One place you may see it is dynamic class generation:  from enum import Enum Ex = Enum(&quot;Ex&quot;, [(&quot;Red&quot;, 1), (&quot;Blue&quot;, 2), (&quot;Red&quot;, 3)]) # Duplicate field `Red` [bad-class-definition]   However, it is best practice to use the class syntax if possible, which doesn't treat duplicate names as an error.  ","version":"Next","tagName":"h2"},{"title":"bad-context-manager‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-context-manager","content":" This error occurs when a type that cannot be used as a context manager appears in a with statement.  class A: def __enter__(self): ... with A(): ... # `A` is missing an `__exit__` method!   ","version":"Next","tagName":"h2"},{"title":"bad-function-definition‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-function-definition","content":" Like bad-class-definition, this error kind is uncommon because other error kinds are used for more specific issues. For example, argument order is enforced by the parser, so def f(x: int = 1, y: str) is a parse-error.  ","version":"Next","tagName":"h2"},{"title":"bad-instantiation‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-instantiation","content":" This error occurs when attempting to instantiate a class that cannot be instantiated, such as a protocol:  from typing import Protocol class C(Protocol): ... C() # bad-instantiation   ","version":"Next","tagName":"h2"},{"title":"bad-keyword-argument‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-keyword-argument","content":" bad-keyword-argument pops up when a keyword argument is given multiple values:  def f(x: int) -&gt; None: pass f(x=1, x=2)   However, this is often accompanied by a parse-error for the same issue.  ","version":"Next","tagName":"h2"},{"title":"bad-override‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-override","content":" When a subclass overrides a field or method of its base class, care must be taken that the override won't cause problems.  Some of these are obvious:  class Base: def f(self, a: int) -&gt; None: pass class NoArg(Base): def f(self) -&gt; None: pass class WrongType(Base): def f(self, a: str) -&gt; None: pass def uses_f(b: Base) -&gt; None: b.f(1)   These errors are rather obvious: uses_f will fail if given a NoArg or WrongType instance, because those methods don't expect an int argument!  The guiding idea here is the Liskov Substitution Principle, the idea that a subclass can stand in for a base class at any point without breaking the program.  This can be a little subtle at first blush. Consider:  class Base: def f(self, a: int) -&gt; None: pass class Sub(Base): def f(self, a: float) -&gt; None: pass   Is this OK? Yes! int is treated as a subclass of float, or to put it another way, a function that accepts float can accept every int. That means everywhere that we call Base.f can safely call Sub.f.  The opposite case, where Base.f takes float and Sub.f takes int, is an error because Sub.f cannot accept every float value.  Note that bad overrides caused by inconsistent parameter names are separately reported as bad-param-name-override.  ","version":"Next","tagName":"h2"},{"title":"bad-param-name-override‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-param-name-override","content":" Arises when a subclass overrides a method of its base class while changing the name of a positional parameter. This is a type of bad override but has a separate error kind so that it can be selectively disabled if desired. Changing the name of a parameter breaks callers that pass in an argument by name:  class Base: def f(self, a: int) -&gt; None: pass class Sub(Base): def f(self, b: int) -&gt; None: pass def f(base: Base): base.f(a=0) f(Sub()) # oops!   ","version":"Next","tagName":"h2"},{"title":"bad-return‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-return","content":" Arises when a function does not return a value that is compatible with the function's return type annotation.  def bad_return() -&gt; None: return 1   Real-world examples are often less obvious, of course, due to complex control flow and type relationships.  This error is also raised for generator functions:  from typing import Generator # Generator has 3 types: the yield, send, and return types. def bad_gen() -&gt; Generator[int, None, str]: yield 1 return 2 # should be a str!   ","version":"Next","tagName":"h2"},{"title":"bad-specialization‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-specialization","content":" &quot;Specialization&quot; refers to instantiating a generic type with a concrete type. For example, list is a generic type, and list[int] is that type specialized with int.  Each generic type has an expected number of type vars, and each type var can be bound or constrained. Attempting to use specialize a generic type in a way that violates these specifications will result in a bad-specialization error:  x: list[int, str]   ","version":"Next","tagName":"h2"},{"title":"bad-typed-dict‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-typed-dict","content":" This error is reported when a TypedDict definition includes an unsupported keyword argument. According to the typing specification, the only keyword argument allowed in a TypedDict's base class list is total.  from typing import TypedDict # This is an error because `foo` is not a valid keyword. class InvalidTD(TypedDict, foo=1): x: int # This is valid. class ValidTD(TypedDict, total=False): x: int   ","version":"Next","tagName":"h2"},{"title":"bad-unpacking‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#bad-unpacking","content":" An error caused by unpacking, such as attempting to unpack a list, tuple, or iterable into the wrong number of variables.  def two_elems() -&gt; tuple[int, str]: return (1, &quot;two&quot;) a, b, c = two_elems()   Note that pyrefly can only report this error if it knows how many elements the thing being unpacked has.  # A bare `tuple` could have any number of elements def two_elems() -&gt; tuple: return (1, &quot;two&quot;) a, b, c = two_elems()   ","version":"Next","tagName":"h2"},{"title":"delete-error‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#delete-error","content":" This error occurs when attempting to del something that cannot be deleted.  Besides obvious things like built-in values (you can't del True!), some object attributes are protected from deletion. For example, read-only and required TypedDict fields cannot be deleted.  ","version":"Next","tagName":"h2"},{"title":"deprecated‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#deprecated","content":" This error occurs on usage of a deprecated class or function:  from warnings import deprecated @deprecated(&quot;deprecated&quot;) def f(): ... f() # deprecated!   ","version":"Next","tagName":"h2"},{"title":"implicit-import‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#implicit-import","content":" A module exists, but was not imported. At runtime, if something has made this import before your code, it will work. But relies on whatever did the import to continue doing it.  import importlib importlib.util.find_spec(&quot;os&quot;) # error, `importlib.util` was not imported   ","version":"Next","tagName":"h2"},{"title":"implicitly-defined-attribute‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#implicitly-defined-attribute","content":" An attribute was implicitly defined by assignment to self in a method that we do not recognize as always executing. We recognize constructors and some test setup methods; we will emit an error for any attributes defined by assignment in other methods.  This error is off by default, and must be manually enabled in the configuration.  class C: def __init__(self): self.x = 0 # no error, `__init__` always executes def f(self): self.y = 0 # error, `y` may be undefined if `f` does not execute   ","version":"Next","tagName":"h2"},{"title":"import-error‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#import-error","content":" An error related to the import mechanism, such as when a module cannot be found.  The error message will include which paths were searched, such as the site package paths. You may be missing a dependency, or you may need to inform Pyrefly where the module lives. See Configuration for further information.  ","version":"Next","tagName":"h2"},{"title":"index-error‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#index-error","content":" Attempting to access a container with an incorrect index. This only occurs when Pyrefly can statically verify that the index is incorrect, such as with a fixed-length tuple.  def add_three(x: tuple[int, int]) -&gt; int: return x[0] + x[1] + x[2]   Pyrefly also knows the keys of TypedDicts, but those have their own error kind.  ","version":"Next","tagName":"h2"},{"title":"internal-error‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#internal-error","content":" Ideally you'll never see this one. If you do, please consider filing a bug.  ","version":"Next","tagName":"h2"},{"title":"invalid-annotation‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-annotation","content":" There are several reasons why an annotation may be invalid. The most common case is misusing a typing special form, such as typing.Final, typing.ClassVar, typing.ParamSpec, and so on.  from typing import * # Final must have a value a: Final # ClassVar can only be used in a class body b: ClassVar[int] = 1   The error messages will explain how the special form is being misused. Consult the typing docs and typing spec for more information.  ","version":"Next","tagName":"h2"},{"title":"invalid-argument‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-argument","content":" This error is used to indicate an issue with an argument to special typing-related functions.  For example, typing.NewType is a handy special form for creating types that are distinct from a base type.  from typing import * # The first arg must match the name! Mismatch = NewType(&quot;Wrong Name&quot;, int) # NewTypes cannot be used in isinstance. UserId = NewType(&quot;UserId&quot;, int) if isinstance(1, UserId): ...   ","version":"Next","tagName":"h2"},{"title":"invalid-decorator‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-decorator","content":" This error indicates that a decorator was used incorrectly. For example, using @typing.final on a non-method function.  from typing import final @final def f() -&gt; None: pass   ","version":"Next","tagName":"h2"},{"title":"invalid-inheritance‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-inheritance","content":" An error caused by incorrect inheritance in a class or type definition. This can pop up in quite a few cases:  Trying to subclass something that isn't a class.Subclassing a type that does not support it, such as a NewType or a Final class.Attempting to mix Protocols with non-Protocol base classes.Trying to make a generic enum.Trying to give a TypedDict a metaclass.  And so on!  ","version":"Next","tagName":"h2"},{"title":"invalid-literal‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-literal","content":" typing.Literal only allows a limited set of types as parameters. Attempting to use Literal with anything else is an error.  from typing import Literal # These are legal Literal[1.0] Literal['a', 'b', 'c'] # This is not class A: ... Literal[A()]   ","version":"Next","tagName":"h2"},{"title":"invalid-overload‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-overload","content":" The @overload decorator requires that the decorated function has at least two overloaded signatures and a base implementation.  from typing import * @overload def no_base(x: int) -&gt; None: pass @overload def no_base(x: str) -&gt; int: pass   @overload def just_one(x: int) -&gt; None: pass def just_one(x: str) -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"invalid-param-spec‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-param-spec","content":" This error is reported when typing.ParamSpec is defined incorrectly or misused. For example:  from typing import * P = ParamSpec(&quot;Name Must Match!&quot;) P1 = ParamSpec(&quot;P1&quot;) P2 = ParamSpec(&quot;P2&quot;) def f(x, *args: P1.args, **kwargs: P2.kwargs) -&gt; None: pass   Here, P1.args and P2.kwargs can't be used together; *args and **kwargs must come from the same ParamSpec.  ","version":"Next","tagName":"h2"},{"title":"invalid-self-type‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-self-type","content":" This error occurs when Self is used in a context Pyrefly does not currently support.  For example, Pyrefly does not currently allow Self for TypedDict, so the following code would error:  from typing import * class TD(TypedDict): x: Option[Self]   ","version":"Next","tagName":"h2"},{"title":"invalid-super-call‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-super-call","content":" super() has a few restrictions on how it is called.  super() can be called without arguments, but only when used inside a method of a class:  class Legal(Base1, Base2): def f(self) -&gt; None: super().f() def illegal(arg: SomeType) -&gt; None: super().f()   When the function is called with two arguments, like super(T, x), then T must be a type, and the second argument is either an object where isinstance(x, T) is true or a type where issubclass(x, T) is true.  ","version":"Next","tagName":"h2"},{"title":"invalid-syntax‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-syntax","content":" This error covers syntactical edge cases that are not flagged by the parser.  For example:  x: list[int] = [0, 2, 3] x[0]: int = 1   It's not a parse error for an assignment to have an annotation, but it is forbidden by the type checker to annotate assignment to a subscript like x[0].  ","version":"Next","tagName":"h2"},{"title":"invalid-type-var‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-type-var","content":" An error caused by incorrect usage or definition of a TypeVar. A few examples:  from typing import TypeVar # Old-style TypeVars must be assigned to a matching variable. Wrong = TypeVar(&quot;Name&quot;) # PEP 695-style TypeVars can be constrained, but there must be at least two: def only_one_constraint[T: (int,)](x: T) -&gt; T: ... # It's also illegal to mix the two styles together. T = TypeVar(&quot;T&quot;) def mixed[S](a: S, b: T) -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"invalid-type-var-tuple‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-type-var-tuple","content":" An error caused by incorrect usage or definition of a TypeVarTuple.  TypeVarTuple has similar error cases to TypeVar, but also a few of its own. For example:  from typing import TypeVarTuple Ts = TypeVarTuple(&quot;Ts&quot;) # TypeVarTuples must always be unpacked: bad: tuple[Ts] = (...) good: tuple[*Ts] = (...) # Only one TypeVarTuple is allowed in a list of type arguments: def two_tups[*Xs, *Ys](xs: tuple[*Xs], ys: tuple[*Ys]) -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"invalid-yield‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#invalid-yield","content":" This error arises when yield is used in a way that is not allowed. For example:  from typing import Generator for _ in range(1, 10): yield &quot;can't yield outside of a function!&quot; def bad_yield_from() -&gt; Generator[int, None, None]: # `yield from` can only be used with iterables. yield from 1   ","version":"Next","tagName":"h2"},{"title":"match-error‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#match-error","content":" This error is used in two cases.  The first is when there is an issue with a match statement. For example, Ex only has 2 fields but the case lists 3:  class Ex: __match_args__ = ('a', 'b') def __init__(self, a: int, b: str) -&gt; None: self.a = a self.b = b def do(x: Ex) -&gt; None: match x: case Ex(a, b, c): print(&quot;This is an error&quot;)   It is also used when __match_args__ is defined incorrectly. It must be a tuple of the names of the class's attributes as literal strings. For class Ex in the previous example, __match_args__ = ('a', 'c') would be an error because Ex.c does not exist.  ","version":"Next","tagName":"h2"},{"title":"missing-argument‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#missing-argument","content":" An error caused by calling a function without all the required arguments.  def takes_two(x: int, y: int) -&gt; int: return x + y takes_two(1)   ","version":"Next","tagName":"h2"},{"title":"missing-attribute‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#missing-attribute","content":" This error is raised when attempting to access an attribute that does not exist on the given object or module.  In the case of modules, attempting to import an nonexistent name will raise `missing-module-attribute instead.  import os from os import bacarat # missing-module-attribute os.jongleur() # missing-attribute   Note that objects with type Any will never raise this error.  ","version":"Next","tagName":"h2"},{"title":"missing-module-attribute‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#missing-module-attribute","content":" Arises when attempting to import a name that does not exist from a module.  This is distinct from import-error, which is used when the module being imported does not exist, and missing-attribute, when access attributes of the module.  import this_does_not_exist # import-error import os.bacarat # import-error from os import joker # missing-module-attribute os.perkeo # missing-attribute   In this example, os.bacarat is treated as a module name, so failing to find it results in an import-error.from os import joker does not tell us if joker is a module, class, function, etc., so it is treated as the more general missing-module-attribute.  ","version":"Next","tagName":"h2"},{"title":"no-access‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#no-access","content":" The no-access error indicates that an attribute exists, but it cannot be used in this way.  For example, classes do not have access to their instances' attributes:  class Ex: def __init__(self) -&gt; None: self.meaning: int = 42 del Ex.meaning # no-access   ","version":"Next","tagName":"h2"},{"title":"no-matching-overload‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#no-matching-overload","content":" This error is similar to the other bad function call errors, but specifically for cases where a function decorated with @overload is called with arguments that do not match any of the overloaded variations.  For example, neither of the signatures of f can take an argument of type float:  from typing import overload @overload def f(x: int) -&gt; int: ... @overload def f(x: str) -&gt; str: ... def f(x: int | str) -&gt; int | str: return x f(1.0)   ","version":"Next","tagName":"h2"},{"title":"not-a-type‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#not-a-type","content":" This indicates an attempt to use something that isn't a type where a type is expected. In most cases, a more specific error kind is used.  You may see this error around incorrect type aliases:  class A: ... # Not an alias, just a string! X = &quot;A&quot; x: X = ... # X is not a type alias, so this is illegal   ","version":"Next","tagName":"h2"},{"title":"not-callable‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#not-callable","content":" A straightforward error: something that is not a function was used as if it were a function.  One interesting place this error may occur is with decorators:  x = 1 @x # not-callable def foo() -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"not-iterable‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#not-iterable","content":" This is most likely to be seen in a for loop:  x = 1 # Or some other value for val in x: # not-iterable ...   ","version":"Next","tagName":"h2"},{"title":"parse-error‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#parse-error","content":" An error related to parsing or syntax. This covers a variety of cases, such as function calls with duplicate keyword args, some poorly defined functions, and so on.  ","version":"Next","tagName":"h2"},{"title":"read-only‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#read-only","content":" This error indicates that the attribute being accessed does exist but cannot be modified.  For example, a @property with no setter cannot be assigned to:  class Ex: @property def meaning(self) -&gt; int: return 42 x = Ex() x.meaning = 0   ","version":"Next","tagName":"h2"},{"title":"redundant-cast‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#redundant-cast","content":" This warning is raised when typing.cast() is used to cast a value to a type it is already compatible with. Such casts are unnecessary and can be removed to improve code clarity.  import typing x: int = 42 # This cast is redundant since x is already an int y = typing.cast(int, x) # redundant-cast # This is a valid cast since we're casting from a more general type obj: object = &quot;hello&quot; s = typing.cast(str, obj) # No warning - this is a valid cast   The redundant cast warning helps identify unnecessary type casts that don't provide any additional type safety benefits.  ","version":"Next","tagName":"h2"},{"title":"redundant-condition‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#redundant-condition","content":" This error is used to indicate a type that's equivalent to True or False is used as a boolean condition (e.g. an uncalled function)  def f() -&gt; bool: ... # This will throw error, as it's likely that the function needs to be invoked. if f: ... # This will throw error, as it's equivalent to `if True`. if &quot;abc&quot;: ...   ","version":"Next","tagName":"h2"},{"title":"reveal-type‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#reveal-type","content":" Pyrefly uses this error to communicate the output of the reveal_type function.  ","version":"Next","tagName":"h2"},{"title":"type-alias-error‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#type-alias-error","content":" An error related to the definition or usage of a typing.TypeAlias. Many of these cases are covered by invalid-annotation, so this error specifically handles illegal type alias values:  from typing import TypeAlias x = 2 Bad: TypeAlias = x   ","version":"Next","tagName":"h2"},{"title":"typed-dict-key-error‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#typed-dict-key-error","content":" This error arises when TypedDicts are used with incorrect keys, such as a key that does not exist in the TypedDict.  from typing import TypedDict class Ex(TypedDict): a: int b: str def test(x: Ex) -&gt; None: # These two keys don't exist x.nope x[&quot;wrong&quot;] # TypedDict keys must be strings! x[1]   ","version":"Next","tagName":"h2"},{"title":"unbound-name‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unbound-name","content":" This error corresponds to the runtime NameError, indicating that a variable is referenced but does not exist.  def do_things(stuff: list[int]) -&gt; str: ... do_thing([1, 2]) # typo! Or, unbound-name   ","version":"Next","tagName":"h2"},{"title":"unexpected-keyword‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unexpected-keyword","content":" A function was called with an extra keyword argument.  def two_args(a: int, b: int) -&gt; int: ... two_args(a=1, b=2, c=3)   ","version":"Next","tagName":"h2"},{"title":"unexpected-positional-argument‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unexpected-positional-argument","content":" A positional argument was passed for a keyword-only parameter.  def takes_kwonly(*, x: int) -&gt; int: ... takes_kwonly(1) # should be `takes_kwonly(x=1)`!   ","version":"Next","tagName":"h2"},{"title":"unknown-name‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unknown-name","content":" unknown-name occurs when attempting to load a name from another scope, but the name cannot be found.  def where() -&gt; None: # There is no spoon: unknown-name global spoon   ","version":"Next","tagName":"h2"},{"title":"unsupported‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unsupported","content":" This error indicates that pyrefly does not currently support a typing feature.  ","version":"Next","tagName":"h2"},{"title":"unsupported-operation‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unsupported-operation","content":" This error arises when attempting to perform an operation between values of two incompatible types.  if &quot;hello&quot; in 1: # int doesn't support `in`! ...   ","version":"Next","tagName":"h2"},{"title":"unused-coroutine‚Äã","type":1,"pageTitle":"Pyrefly Error Kinds","url":"/en/docs/error-kinds/#unused-coroutine","content":" If the result of an async function call is not awaited or used, we will raise an error.  async def foo(): return 1 async def bar(): foo() # error await foo() # ok x = foo() # ok  ","version":"Next","tagName":"h2"},{"title":"Pyrefly Frequently Asked Questions","type":0,"sectionRef":"#","url":"/en/docs/pyrefly-faq/","content":"","keywords":"","version":"Next"},{"title":"How do I pronounce Pyrefly?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#how-do-i-pronounce-pyrefly","content":" It's pronounced PIE-ur-fly, rhyming with &quot;firefly.&quot;  ","version":"Next","tagName":"h2"},{"title":"What is the relationship to Pyre?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#what-is-the-relationship-to-pyre","content":" Pyrefly is a ground-up rebuild that doesn‚Äôt share any core type checking code with Pyre. Not only is Pyrefly written in a new language (Rust instead of OCaml), but its design deviates in a major way from Pyre. Rust enables us to deliver substantial performance improvements and support multiple operating systems (including Windows). Beyond the core type checker itself, there are helper tooling and many lessons learned that we will take from Pyre and the community of Python type checking maintainers who have done tremendous work to get the state of type checking to where it is today.  ","version":"Next","tagName":"h2"},{"title":"Is Pyrefly a type checker or a language server?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#is-pyrefly-a-type-checker-or-a-language-server","content":" Yes üòâ  Pyrefly is both of these things, and you can use one without the other if you choose.  type checking: Pyrefly can be used as a standalone type checker - directly run in your terminal, added to your CI or integrated into your IDE via an extension (made possible by leveraging language server capabilities)language server: Pyrefly can be used as a standalone Python language server, integrated into your IDE with all the typical IDE features you would expect (hover, go-to-definition etc.). You can use it with or without type checking enabled.  ","version":"Next","tagName":"h2"},{"title":"Yet another Type Checker! Why not improve the ones adopted by the community already?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#yet-another-type-checker-why-not-improve-the-ones-adopted-by-the-community-already","content":" We are standing on the shoulders of giants. The contributions to Python typing by Mypy, Pyright, Pytype, Pyre and others have been invaluable. We borrowed concepts and learned from them as we rolled our own. Open source conformance matters to us a lot. While we might make some opinionated decisions, we'll adhere to the PEP process. Pyre was the only type checker that could scale for Meta‚Äôs needs and was starting to show its age, so we started with a ground-up rewrite aimed at usability and performance.  We built a custom engine for incremental computation and designed our type-checking algorithm based on years of experience in gradual typing theory and Rust expertise. By open-sourcing this technology we hope it can serve projects of any size well.  ","version":"Next","tagName":"h2"},{"title":"Why Rust?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#why-rust","content":" We would have preferred to write Pyrefly in Python, but we didn't think we could hit our ambitious performance goals using Python today (hopefully future work around free-threaded Python and JIT changes that). After ruling out Python, we wanted something that was safe, cross-platform, compiled to WASM (for a Playground experience). Rust and Go are probably the best choices for those goals, and our team at Meta had more experience with Rust.  ","version":"Next","tagName":"h2"},{"title":"Where do I report bugs?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#where-do-i-report-bugs","content":" Please open an issue on our GitHub page. You can leave feature requests there as well :) Our current goal is to get through our first major milestone, and after that we can look at bugs and features beyond the current roadmap.  ","version":"Next","tagName":"h2"},{"title":"Can I contribute to Pyrefly?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#can-i-contribute-to-pyrefly","content":" Please see the: contributing guidelines.  ","version":"Next","tagName":"h2"},{"title":"How do I know this project won't go unmaintained after a year?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#how-do-i-know-this-project-wont-go-unmaintained-after-a-year","content":" Great question. We have made a substantial investment in Pyrefly, use it internally and aligned open source maintainability as a key principle for starting this project in the first place. We‚Äôre in it for the long haul. Using it is the best way to encourage further investment from our leadership.  ","version":"Next","tagName":"h2"},{"title":"This is cool, I want to learn more about the technical details.‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#this-is-cool-i-want-to-learn-more-about-the-technical-details","content":" See our README.md for the high level design. We plan to add more detailed documentation along with announcements on https://engineering.fb.com  ","version":"Next","tagName":"h2"},{"title":"I don't like Python's Type System. Stop wasting your time.‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#i-dont-like-pythons-type-system-stop-wasting-your-time","content":" Tell us more - seriously! We want to hear your objections to typing. We hope that better tooling, improvements to the type system and well typed libraries will help provide make development easier. If all else fails our fast code navigation and inference algorithm might spark joy in your IDE, so give us a chance.  Curious about something else or just want to chat about bolting types onto Python, join us on Discord. ","version":"Next","tagName":"h2"},{"title":"Typing Features and PEPS","type":0,"sectionRef":"#","url":"/en/docs/python-features-and-peps/","content":"Typing Features and PEPS Typing Features and PEPS available in each Python Version. Feature (click PEP for details)\tWhat it adds / looks like\tIntroduced inPEP 484 -- Core type hints &amp; typing module\tdef add(a: int, b: int) -&gt; int:\t3.5 PEP 526 -- Variable annotations\tcount: int = 0\t3.6 PEP 563 -- from __future__ import annotations (lazy eval)\tAnnotations stored as strings\t3.7 (future‚Äëflag) PEP 544 -- Protocols (structural typing)\tclass Jsonable(Protocol): ...\t3.8 PEP 589 -- TypedDict\tclass User(TypedDict): ...\t3.8 PEP 586 -- Literal types\tdef log(level: Literal[&quot;info&quot;,&quot;warn&quot;]): ...\t3.8 PEP 591 -- Final qualifier\tTOKEN: Final[str] = &quot;...&quot;\t3.8 PEP 585 -- Built‚Äëin generics\tlist[int], dict[str, Any]\t3.9 PEP 593 -- Annotated\tx: Annotated[int, &quot;units=px&quot;]\t3.9 PEP 604 -- Union syntax\tint | None\t3.10 PEP 612 -- ParamSpec / Concatenate\tdecorator‚Äësafe generics\t3.10 PEP 613 -- TypeAlias qualifier\tVector: TypeAlias = list[float]\t3.10 PEP 647 -- TypeGuard for narrowing\tdef is_str(x) -&gt; TypeGuard[str]: ...\t3.10 PEP 655 -- Required / NotRequired for TypedDict\toptional vs. mandatory keys\t3.11 PEP 646 -- Variadic generics (TypeVarTuple, Unpack)\ttensor shapes, 2‚ÄëD arrays, ...\t3.11 PEP 673 -- Self type\tfluent APIs: def set(...) -&gt; Self:\t3.11 PEP 681 -- dataclass_transform helper\tlibraries like Pydantic, attrs\t3.11 PEP 695 -- Class‚Äëlevel generics syntax\tclass Box[T]: ...\t3.12 PEP 698 -- @override decorator\tflag intentional overrides\t3.13 PEP 649 -- New deferred‚Äëeval algorithm (replaces PEP 563)\tbecomes the default\t3.14","keywords":"","version":"Next"},{"title":"Python Typing 101","type":0,"sectionRef":"#","url":"/en/docs/python-typing-for-beginners/","content":"","keywords":"","version":"Next"},{"title":"1. What is a Type?‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#1-what-is-a-type","content":" A type is a classification that defines what operations can be performed on a piece of data, what values it can hold, and how it behaves in memory. Types are fundamental to programming because they help ensure that operations on data make sense.  For example:  An int (integer) type can be added, subtracted, or multipliedA str (string) type can be concatenated or splitA list type can be indexed, sliced, or iterated over  Note: These are just examples of common operations for each data type. Python's built-in types support many more operations that are not listed here.  Understanding types helps you predict how your code will behave and avoid runtime errors from trying to perform operations that don't make sense, such as dividing a string by a number.  ","version":"Next","tagName":"h2"},{"title":"2. What is a Type Hint in Python?‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#2-what-is-a-type-hint-in-python","content":" A type hint in Python is a way to indicate the expected data type of a variable, function parameter, or return value. It's a hint to other developers (and to tools like type checkers and IDEs) about what type of data should be used with a particular piece of code.  Type hints are not enforced at runtime by Python itself, but they can be used by third-party tools (like Pyrefly) to catch type-related errors before your code runs. They also serve as documentation, making it easier for others to understand how to use your code. Here's an example of a simple function with type hints:  def greet(name: str) -&gt; None: print(f&quot;Hello, {name}!&quot;)   In this example:  name: str indicates that the name parameter should be a string.-&gt; None specifies that the function doesn't return any value (similar to void in other languages).  ","version":"Next","tagName":"h2"},{"title":"3. Why Bother with Type Hints?‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#3-why-bother-with-type-hints","content":" Python is a dynamically typed language, which means you can write code without declaring types. However, this can lead to bugs or ambiguity in your code.  TL;DR  Catch bugs before running the code.Improve editor autocomplete &amp; refactors.Turn your code into living documentation.  # Without hints ‚Äì is &quot;times&quot; a str, int, or list? def repeat(text, times): return text * times # With hints ‚Äì intent is crystal clear. def repeat(text: str, times: int) -&gt; str: return text * times  In this example:  The first function lacks type hints, making it unclear what types text and times should be. The * operator works differently depending on types (string repetition, list repetition, or multiplication).The second function uses type hints to clearly indicate that text should be a string, times should be an integer, and the function returns a string.This clarity helps prevent bugs like accidentally passing a string for times or using the function incorrectly.  ","version":"Next","tagName":"h2"},{"title":"Can you spot the bug?‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#can-you-spot-the-bug","content":" class Rectangle: width: int height: int def __init__(self, width: int, height: int) -&gt; None: self.width = width self.height = height rect = Rectangle(width=100, height=50) area = rect.width * rect.hieght print(area)   In this example:  The bug is a typo in rect.hieght (should be rect.height).Without type hints, Python would only report this error at runtime when it tries to access the non-existent attribute.With type hints and a tool like Pyrefly, this error would be caught before running the code because the Rectangle class has defined attributes width and height, but not hieght.  Spelling is hard! Let's add the dataclass decorator to our class definition. This will generate a constructor for us, and also add a few other useful methods.  #Pyrefly will catch this spelling error before you run the code from dataclasses import dataclass @dataclass class Rectangle: width: int height: int rect = Rectangle(width=100, height=50) area = rect.width * rect.hieght  In this dataclass example:  The @dataclass decorator automatically generates methods like __init__, __repr__, and __eq__ based on the class attributes.Type hints are used to define the class attributes (width: int, height: int).The same spelling error exists (rect.hieght), but tools like Pyrefly can catch this before runtime because the dataclass clearly defines which attributes exist.This demonstrates how type hints combined with dataclasses provide both convenience and better error detection.  ","version":"Next","tagName":"h3"},{"title":"4. Primitive Types‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#4-primitive-types","content":" Since Python 3.9 you can use all the primitive types directly as annotations.  age: int = 30 height: float = 1.85 name: str = &quot;Tyler Typer&quot; is_admin: bool = False  In this primitive types example:  Each variable is annotated with its expected type (int, float, str, bool).The values assigned match their declared types.These annotations help document the code and allow type checkers to verify that operations on these variables are valid for their types.For example, a type checker would flag an error if you tried age + name since adding an integer and string isn't a valid operation.  You can also specify a parameter as optional by using Optional type, or now with the | None syntax.  # Optional typing example from typing import Optional middle_name: Optional[str] = None # classic nickname: str | None = None # 3.10+ shorthand  In this Optional type example:  Both variables can either be a string or None.Optional[str] is the traditional syntax (pre-Python 3.10).str | None is the newer union syntax introduced in Python 3.10.These annotations tell type checkers that the variable might be None, so they can warn you if you try to perform string operations without checking for None first.  ","version":"Next","tagName":"h2"},{"title":"5. Collections‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#5-collections","content":" ","version":"Next","tagName":"h2"},{"title":"Syntax Examples‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#syntaxexamples","content":" List of numbers list[int] scores: list[int] = [98, 87, 91]Tuple of two floats tuple[float, float] point: tuple[float, float] = (3.0, 4.0)Dict of str -&gt; int dict[str, int] inventory: dict[str, int] = {&quot;apples&quot;: 5}Set of strings set[str] authors: set[str] = {&quot;Bob&quot;, &quot;Eve&quot;}  Since Python 3.9 you can subscript built‚Äëins directly‚Äîno need for from typing import List.  ","version":"Next","tagName":"h3"},{"title":"6. Functions‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#6-functions","content":" # Simple function def add(a: int, b: int) -&gt; int: return a + b  In this basic function example:  Both parameters a and b are annotated as integers.The function is annotated to return an integer (-&gt; int).This tells type checkers that the function should only be called with integers and that the return value should only be used in contexts where an integer is expected.  Default values keep their annotation:  # Function with default value def greet(name: str, polite: bool = True) -&gt; str: return &quot;Hello!&quot; if polite else f&quot;Yo {name}&quot;  In this function with default values:  The name parameter must be a string.The polite parameter is a boolean with a default value of True.The function returns a string.Even though polite has a default value, it still has a type annotation to ensure that if it's explicitly provided, it must be a boolean.  Variable‚Äëlength arguments:  # Variable length functions from collections.abc import Callable Logger = Callable[[str], None] def debug(*msgs: str, log: Logger | None) -&gt; None: for m in msgs: if log is not None: log(m) else: print(m)  In this variable-length arguments example:  Logger is defined as a type alias for a callable that takes a string and returns nothing (None).*msgs: str indicates that the function accepts any number of string arguments.log: Logger | None means the log parameter can be either a Logger function or None.The function is annotated to return None.This demonstrates how to type complex function signatures with variable arguments and function parameters.  ","version":"Next","tagName":"h2"},{"title":"7. Get Type Hint Signals Directly in Your Editor‚Äã","type":1,"pageTitle":"Python Typing 101","url":"/en/docs/python-typing-for-beginners/#7-get-type-hint-signals-directly-in-your-editor","content":" You can download the Pyrefly extension for VSCode to get type hint signals directly in your IDE.  Next, install Pyrefly and check some code:  # Fast, zero‚Äëconfig pip install pyrefly pyrefly check ./my_sample.py # Check whole directories pyrefly check app/ tests/   Create a pyrefly.toml file to configure your project. Instructions here. ","version":"Next","tagName":"h2"},{"title":"Typing for Python Developers","type":0,"sectionRef":"#","url":"/en/docs/typing-for-python-developers/","content":"","keywords":"","version":"Next"},{"title":"Types with Inference‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#types-with-inference","content":" Static analyzers can often infer types from your code‚Äîno annotations required. Pyrefly takes this a step further.  # Basic Inference answer = 42 reveal_type(answer) # hover to reveal type fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] scores = {&quot;math&quot;: 95, &quot;science&quot;: 90} def greet(name): return f&quot;Hello, {name}!&quot; message = greet(&quot;World&quot;)  ","version":"Next","tagName":"h3"},{"title":"Where Inference Shines ‚ú®‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#where-inference-shines-","content":" Constant assignments (answer = 42 -&gt; int)List/tuple/dict literals with uniform elements (names = [&quot;A&quot;, &quot;B&quot;] -&gt; list[str])Return types if parameter types are annotated:  def add(a: int, b: int): # ‚úÖ param annotations return a + b # üîç return inferred -&gt; int  ","version":"Next","tagName":"h3"},{"title":"When to Add Hints‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#when-to-add-hints","content":" Public APIs (library or service boundaries)Mixed collections (list[int | str])Callable signatures (decorators, callbacks)  ","version":"Next","tagName":"h3"},{"title":"Define Types Inline‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#define-types-inline","content":" ","version":"Next","tagName":"h2"},{"title":"The Basics‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#the-basics","content":" Python's built-in types can be used to write many type hints.  # Example: Basic Types from typing import reveal_type age: int = 5 reveal_type(age) # revealed type: int age = &quot;oops&quot; name: str = &quot;John&quot; reveal_type(name) # revealed type: str numbers: list[int] = [1, 2, 3] reveal_type(numbers) # revealed type: list[int] names: list[str] = [&quot;John&quot;, &quot;Jane&quot;] reveal_type(names) # revealed type: list[str] person: dict[str, str] = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: &quot;30&quot;} reveal_type(person) # revealed type: dict[str, str] is_admin = True reveal_type(is_admin) # revealed type: Literal[True]  ","version":"Next","tagName":"h3"},{"title":"Functions‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#functions","content":" Defining the parameter and return types for a function doesn't just help prevent bugs, but it makes it easier to navigate in other files. You don't always need to define a return type - we'll do our best to infer it for you! We can't always get it right and an explicit return type will help your IDE navigate faster and more accurately.  # Example: Functions from typing import reveal_type def greet(name: str) -&gt; str: return f&quot;Hello, {name}!&quot; greet(&quot;Pyrefly&quot;) def whatDoesThisFunctionReturnAgain(a: int, b: int): return a + b reveal_type(whatDoesThisFunctionReturnAgain(2, 3)) # revealed type: int  ","version":"Next","tagName":"h3"},{"title":"Advanced Types‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#advanced-types","content":" ","version":"Next","tagName":"h2"},{"title":"Composing Types‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#composing-types","content":" The real power comes from composing smaller pieces into richer shapes.  ","version":"Next","tagName":"h3"},{"title":"Unions & Optional‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#unions--optional","content":" # Union and Optional Types from typing import Optional def to_int(data: str | bytes | None) -&gt; Optional[int]: if data is None: return None if isinstance(data, bytes): data = data.decode() return int(data)  ","version":"Next","tagName":"h3"},{"title":"Generics‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#generics","content":" Generics allow you to define reusable functions and classes that work with multiple types. This feature enables you to write more flexible and adaptable code.  Declaring Generic Classes:  # Example: Generic Classes from typing import reveal_type class C[T]: def __init__(self, x: T): self.x = x def box(self) -&gt; list[T]: return [self.x] c = C(0) reveal_type(c.box()) # revealed type: list[int]  Declaring Type Statements:  # Example: Type Statements type ListOrSet[T:int] = list[T] | set[T]  ParamSpec and TypeVarTuple:  # Example: ParamSpec and TypeVarTuple class ChildClass[T, *Ts, **P]: ...  ","version":"Next","tagName":"h3"},{"title":"Variance Inference in Generics‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#variance-inference-in-generics","content":" When working with generics, a key question is: if one type is a subtype of another, does the subtyping relationship carry over to generic types? For example, if int is a subtype of float, is A[int] also a subtype of A[float]?  This behavior is governed by variance:  Covariant types preserve the direction of subtyping (A[int] is a subtype of A[float]).Contravariant types reverse it.Invariant types require an exact match.  Before PEP 695, variance had to be declared manually and was often confusing. Pyrefly infers the variance automatically based on how each type parameter is used - in method arguments, return values, attributes, and base classes.  Example 1: Covariance from Immutable Attributes (Final)  # Example 1: Variance Inference from typing import Final class ShouldBeCovariant[T]: x: Final[T] def __init__(self, value: T): self.x = value x1: ShouldBeCovariant[float] = ShouldBeCovariant[int](1) # OK x2: ShouldBeCovariant[int] = ShouldBeCovariant[float](1.0) # ERROR!  How Variance is Inferred:  The attribute x is annotated as Final[T], making it immutable after initialization.Because T appears only in this read-only position, it is safe to infer T as covariant.This means: You can assign ShouldBeCovariant[int] to a variable expecting ShouldBeCovariant[float] (since int is a subtype of float).But the reverse is not allowed (ShouldBeCovariant[float] to ShouldBeCovariant[int]), which triggers a type error.  Example 2: General Variance Inference from Method and Base Class Usage  # Example 2: Variance Inference class ClassA[T1, T2, T3](list[T1]): def method1(self, a: T2) -&gt; None: ... def method2(self) -&gt; T3: ... def func_a(p1: ClassA[float, int, int], p2: ClassA[int, float, float]): v1: ClassA[int, int, int] = p1 # ERROR! v2: ClassA[float, float, int] = p1 # ERROR! v3: ClassA[float, int, float] = p1 # OK v4: ClassA[int, int, int] = p2 # ERROR! v5: ClassA[int, int, float] = p2 # OK  How Variance is Inferred:  T1 appears in the base class list[T1]. Since list is mutable, T1 is invariant.T2 is used as the type of a method parameter (a: T2) so T2 contravariant.T3 is the return type of a method (def method2() -&gt; T3) so T3 is covariant.This means: v1 fails due to mismatched T1 (invariant).v2 fails because T2 expects a supertype, but gets a subtype.v4 fails because T3 expects a subtype, but gets a supertype.  ","version":"Next","tagName":"h3"},{"title":"Structural Types and Protocols‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#structural-types-and-protocols","content":" Python also employs a structural type system, often referred to as &quot;duck typing.&quot; This concept is based on the idea that if two objects have the same shape or attributes, they can be treated as being of the same type.  ","version":"Next","tagName":"h2"},{"title":"Dataclasses‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#dataclasses","content":" Dataclasses allow you to create type-safe data structures while minimizing boilerplate.  # Example: Dataclasses from dataclasses import dataclass @dataclass class Point: x: float y: float Point(x=0.0, y=0.0) # OK Point(x=0.0, y=&quot;oops&quot;) # ERROR!  ","version":"Next","tagName":"h3"},{"title":"TypedDict‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#typeddict","content":" Typed dictionaries enable you to define dictionaries with specific key-value types. This feature lets you bring type safety to ad-hoc dictionary structures without major refactoring.  # Example: TypedDict from typing import TypedDict class Movie(TypedDict): name: str year: int good_movie: Movie = {&quot;name&quot;: &quot;Toy Story&quot;, &quot;year&quot;: 1995} # OK bad_movie: Movie = {&quot;name&quot;: &quot;The Room&quot;, &quot;year&quot;: &quot;2003&quot;} # ERROR!  ","version":"Next","tagName":"h3"},{"title":"Overloads‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#overloads","content":" Overloads allow you to define multiple function signatures for a single function. Like generics, this feature helps you write more flexible and adaptable code.  # Example: Overloads from typing import overload, reveal_type @overload def f(x: int) -&gt; int: ... @overload def f(x: str) -&gt; str: ... def f(x: int | str) -&gt; int | str: return x reveal_type(f(0)) # revealed type: int reveal_type(f(&quot;&quot;)) # revealed type: str  ","version":"Next","tagName":"h3"},{"title":"Protocols‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#protocols","content":" Protocols allows you to define interfaces without explicit inheritance. This feature helps you write more modular and composable code.  # Example: Structural Typing with Protocols from typing import Iterable, Protocol class Writer(Protocol): def write(self) -&gt; None: ... class GoodWorld: def write(self) -&gt; None: print(&quot;Hello world!&quot;) class BadWorld: pass def f(writer: Writer): pass f(GoodWorld()) # OK f(BadWorld()) # ERROR!  ","version":"Next","tagName":"h3"},{"title":"Typing Features and PEPS available in each Python Version‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#typing-features-and-peps-available-in-each-python-version","content":" See the full list of features available in the Python type system here.  ","version":"Next","tagName":"h2"},{"title":"Key Highlights Summary:‚Äã","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#key-highlights-summary","content":" Inference: Python's static analyzers can infer types from your code, reducing the need for explicit annotations. This feature enhances code readability and helps catch bugs early.Defining Types: You can define types inline using Python's built-in types, which aids in documentation and improves IDE support.Advanced Types: The guide covers advanced concepts like composing types, using unions and optionals, generics, protocols, and structural types like dataclasses and TypedDict.Practical Examples: The guide includes examples of functions, generic classes, structural typing with protocols, and more, demonstrating how to apply these concepts in real-world scenarios. ","version":"Next","tagName":"h3"}]