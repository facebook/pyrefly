---
title: IDE Supported Features

description: Supported features for Pyrefly's IDE extension
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

# IDE Supported Features

Pyrefly’s language server powers a complete editing experience while **fully disabling Pylance**, ensuring no interference between checkers.

> Each feature below links to the [official LSP specification](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/) and shows what’s currently supported by Pyrefly.

---

### [Go to definition](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_definition)

Jump to where a symbol was originally defined with a click or <kbd>F12</kbd>. If there is both a `.pyi` and `.py` file, we will jump to the `.py`.
<video
  src="/videos/go-to-definition.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Go to type definition](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_typeDefinition)

Navigate to the underlying type of any expression. If the expression is a type, we will navigate to the `.pyi` file if both a `.py` and `.pyi` exist.
<video
  src="/videos/go-to-type-definition.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Go to declaration](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_declaration)

Navigate to where the type was defined, but stop at imports.
<video
  src="/videos/go-to-declaration.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Go to implementation](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_implementation)

On a method, navigate to all reimplementations.
<video
  src="/videos/go-to-implementation.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---

### [Move/rename file](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didRename)

When moving or renaming a file, Pyrefly will do it's best to rename all references to it.
<video
  src="/videos/move-file.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---

### [Find references](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_references)

List all usages of a symbol across your codebase.
<video
  src="/videos/find-all-references.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Document symbols](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_documentSymbol)

See an outline of all top-level items in the current file.
<video
  src="/videos/document-symbols.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Workspace symbols](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_symbol)

Search globally for functions, classes, and variables.
<video
  src="/videos/workspace-symbols.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Hover](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_hover)

See type info and docstrings when hovering over code.
<video
  src="/videos/hover.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Document highlights](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_documentHighlight)

Highlights all other instances of the symbol under your cursor.
<video
  src="/videos/document-highlights.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Signature help](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_signatureHelp)

Live function signatures as you type, with parameter hints.
<video
  src="/videos/signature-help.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Completion](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_completion)

Autocomplete suggestions for project-specific symbols and imports.
<video
  src="/videos/autocomplete.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Rename](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_rename)

Safely rename symbols project-wide.
<video
  src="/videos/rename.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

<!-- ### [Call hierarchy](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#callHierarchy_prepare)

Explore callers and callees of a method or function.
![Call hierarchy](../gifs/call-hierarchy.gif)

---
 -->

### [Diagnostics](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_publishDiagnostics)

Type errors and warnings from Pyrefly’s checker appear in the diagnostics pane ("Problems" pane in VSCode).
<video
  src="/videos/diagnostics.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Semantic tokens](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_semanticTokens)

Rich syntax highlighting based on token type and origin.
<video
  src="/videos/semantic-highlighting.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Inlay hints](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_inlayHint)

Inline hints for types, parameter names, and return values.

:::info
We reuse Pyright's `python.analysis.inlayHints.<>` settings for backwards compatibility. If you have or had Pyright, check these settings if inlay hints do not appear.
:::

You can turn inlay hints on or off using the [VSCode Setting](https://code.visualstudio.com/docs/editing/editingevolved#_inlay-hints) `editor.inlayHints.enabled`.


Inlay hints can be double clicked to insert them as an annotation.
<video
  src="/videos/double-click-inlay-hint.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

Go-to-definition can be used on a type in an inlay hint to jump its definition. This works even if the type isn't explicitly imported by the current file.
<video
  src="/videos/cmd-click-inlay-hint.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

---

### [Notebook support](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookDocument)

Pyrefly provides language services for Jupyter notebooks directly in VS Code and also in Jupyter Lab.

In Jupyter Lab, once you install the [jupyterlab-lsp](https://jupyterlab-lsp.readthedocs.io/en/latest/Installation.html) extension, and Pyrefly will appear on the list of automatically-detected language servers.

Notebook support is experimental. Please report any bugs on our Github.

---
### [Call Hierarchy](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_prepareCallHierarchy)

See all incoming functions calls to a particular function, as well as all outgoing function calls from a function. Call Hierarchy provides a full picture of
how a particular function is used within a call stack.

<video
  src="/videos/call-hierarchy.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---
### [Type Hierarchy](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_prepareTypeHierarchy)

See all subclasses and superclasses of a selected class.

<video
  src="/videos/type-hierarchy.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---
### Refactor: Pull Member Up and Push Member Down

Pull a method from a subclass to a superclass, or push a method from a superclass to a subclass.

Pull Member Up
<video
  src="/videos/pull-up-refactor.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

Push Member Down
<video
  src="/videos/push-down-refactor.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---
### Refactor: Convert to Package and Convert to Module

Convert to Package takes .py file and moves it to a package directory with all logic moved into an __init__.py file.

<video
  src="/videos/convert-to-package.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

Convert to Module takes an existing package with all logic defined in its __init__.py and creates a named .py file from it.

<video
  src="/videos/convert-to-module.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---
### Refactor: Move function to top level

Takes a function nested within another function or statement and moves it to the top level of the module.

<video
  src="/videos/top-level-refactor.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---
### Refactor: Introduce Parameter

Adds a new parameter to a function definition and update all call sites to pass the new parameter.

<video
  src="/videos/refactor-introduce-parameter.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---
### Refactor: Inline Variable

Removes redundant variables by replacing them with their value.

<video
  src="/videos/refactor-inline-variable.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---
### Refactor: Extract to Field

Declare a new field on a class with the value of the selected expression.

<video
  src="/videos/refactor-extract-to-field.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---
### Refactor: Extract to Variable

Declare a new variable with the value of the selected expression.

<video
  src="/videos/refactor-extract-to-variable.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---
### Refactor: Invert Boolean

Flips the value of a boolean and updates all usages to work with new value.

<video
  src="/videos/refactor-invert-boolean.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>
---

## Planned features

See [planned features and request your own](https://github.com/facebook/pyrefly/issues/344) on GitHub.


---

---
title: IDE Installation

description: How to add Pyrefly Language Server and Typechecking to your IDE
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

# Add Pyrefly to your IDE
Pyrefly seamlessly integrates into IDEs with our [VSCode](https://marketplace.visualstudio.com/items?itemName=meta.pyrefly) and [OpenVSX](https://open-vsx.org/extension/meta/pyrefly) extensions. For other editors like vim/emacs, see [other editors](#other-editors).

To see what features are supported by the IDE extension, see the [Supported Features page](../IDE-features).

## Quick start

1. Install the Pyrefly extension from the [VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=meta.pyrefly) or [Open VSX](https://open-vsx.org/extension/meta/pyrefly).
2. Open any Python file and the extension will activate automatically.

:::tip
Not seeing inlay hints in VS Code? Try setting `editor.inlayHints.enabled` to `true` in your VS Code settings.
:::

:::tip
Want type error squiggles to show up in your editor by default? Try setting `python.pyrefly.displayTypeErrors` to `"force-on"` in your editor settings, create a `pyrefly.toml` file in your project root, or add a `[tool.pyrefly]` section to your `pyproject.toml` (can be empty).
:::

## Customization

By default, Pyrefly should work in the IDE with no configuration necessary. But to ensure your project is set up properly, see [configurations](../configuration).

The following configuration options are IDE-specific and exposed as VSCode settings:
- Disable all language services
  - `python.pyrefly.disableLanguageServices` [boolean: false]: By default, Pyrefly will provide both type errors and other language features like go-to definition, intellisense, hover, etc. Set `disableLanguageServices` to `true` to keep type errors from Pyrefly unchanged but use VSCode's Python extension for everything else.
- Disable certain language services
  - `python.pyrefly.disabledLanguageServices` [json: {}]: a config to disable certain lsp methods from pyrefly. For example, if you want go-to definition but not find-references.
- Disable type errors
  - `python.pyrefly.displayTypeErrors` [enum: default, force-on, force-off, error-missing-imports]: If `'default'`, Pyrefly will only provide type checking diagnostics in the IDE if your file is covered by a [Pyrefly configuration](../configuration). If `'force-off'`, Pyrefly will never provide type check diagnostics in the IDE. If `'force-on'`, Pyrefly will always provide type check diagnostics in the IDE. If `'error-missing-imports'`, Pyrefly will only show errors for missing imports and missing sources (`missing-import`, `missing-source`, and `missing-source-for-stubs`). Note that syntax errors (`invalid-syntax` and `parse-error`) are shown by default in every mode besides `force-off`.
- Specify a custom Pyrefly Binary (lspPath)
  - `pyrefly.lspPath` [string: '']: If your platform is not supported, you can build pyrefly from source and specify the binary path with the `lspPath` config.
- Use a specific interpreter
  - If the [`Python`](https://marketplace.visualstudio.com/items?itemName=ms-python.python) VSCode extension is installed, [selecting an interpreter](https://code.visualstudio.com/docs/python/environments) will override the interpreter and settings Pyrefly uses to type check your project, even if one is specified in your Pyrefly configuration.
  - `python.defaultInterpreterPath` will override the default interpreter selected by VSCode for your workspace.
- Control hover tooltip links
  - `python.analysis.showHoverGoToLinks` [boolean: true]: Controls whether hover tooltips include "Go to definition" and "Go to type definition" navigation links. Set to `false` for cleaner tooltips with only type information.
- Control comment section folding
  - `pyrefly.commentFoldingRanges` [boolean: false]: Controls whether comment section folding ranges are included in the editor. When `true`, comments following the pattern `# Section Name ----` (with 4+ trailing dashes) create collapsible regions, similar to R's code section convention. Set to `true` to enable this feature.

When used with non-VSCode editors, these options can also be configured by sending them via `initializationOptions` in the LSP [initialization](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initialize) request.

Below is an example of a value that can be passed for `initializationOptions`:
```json
{
  "pythonPath": "/usr/bin/python3",
  "commentFoldingRanges": true,
  "pyrefly": {
    "displayTypeErrors": "default",
    "disableLanguageServices": false,
    "extraPaths": ["/path/to/extra/modules"],
    "analysis": {
      "diagnosticMode": "workspace",
      "importFormat": "absolute",
      "inlayHints": {
        "callArgumentNames": "off",
        "functionReturnTypes": true,
        "pytestParameters": false,
        "variableTypes": true
      },
      "showHoverGoToLinks": true
    },
    "disabledLanguageServices": {
      "definition": false,
      "declaration": false,
      "typeDefinition": false,
      "codeAction": false,
      "completion": false,
      "documentHighlight": false,
      "references": false,
      "rename": false,
      "signatureHelp": false,
      "hover": false,
      "inlayHint": false,
      "documentSymbol": false,
      "semanticTokens": false,
      "implementation": false
    }
  }
}
```

## Issues?

If you experience issues with the Pyrefly extension, please create an [issue](https://github.com/facebook/pyrefly/issues) on github.

## Other Editors
Support for other editors is community-driven. If you would like to set this up, please contribute.

### Antigravity, Windsurf, Cursor and Kiro

You can use Pyrefly in your favorite AI editor that supports [OpenVSX](https://open-vsx.org/extension/meta/pyrefly) extensions. Search for "Pyrefly" in the extension marketplace and install it. Similar to VSCode, Pyrefly will automatically activate when you open a Python file.

To avoid conflicts, you should disable other Python language servers by either setting "Language Server: None" in the extension settings or by disabling the Pyright or BasedPyright extensions.

<video
  src="/videos/openvsx.mp4"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

### Jetbrains / Pycharm
PyCharm users can enable native Pyrefly support in the settings:
1. Go to **Python | Tools | Pyrefly** in the Settings dialog.
2. Select the **Enable** checkbox.
3. In the Execution mode setting, select how PyCharm should search for the executable:

    **Interpreter** mode: PyCharm searches for an executable installed in your interpreter. To install the Pyrefly package for the selected interpreter, click *Install Pyrefly*.

    **Path** mode: PyCharm searches for an executable in `$PATH`. If the executable is not found, you can specify the path by clicking the  Browse... icon.

4. Select which options should be enabled.

For more information, refer to [PyCharm documentation](https://www.jetbrains.com/help/pycharm/lsp-tools.html#pyrefly).

### Neovim

Pyrefly supports native Neovim support through `lspconfig` on Neovim 0.11+. Install and setup Pyrefly using the settings below.

The recommended way to set up Pyrefly in **Neovim 0.11+** is:
1. Install or update the [`neovim/nvim-lspconfig`](https://github.com/neovim/nvim-lspconfig), [`mason-org/mason.nvim`](https://github.com/mason-org/mason.nvim), and [`mason-org/mason-lspconfig.nvim`](https://github.com/mason-org/mason-lspconfig.nvim) plugins with your plugin manager of choice.
2. Add the following to your Neovim `init.lua`:
```lua
require("mason").setup()
require("mason-lspconfig").setup()
```
3. In Neovim, run `:MasonInstall pyrefly` or add `pyrefly` to your `ensure_installed` options:
```lua
require("mason-lspconfig").setup {
  ensure_installed = { "pyrefly" },
}
```

<details>
    <summary>Alternative setups and configurations</summary>

    While the above section describes the fastest way to set up Pyrefly, you may already have a setup or prefer to use other approaches for your lspconfig. Below we describe alternatives to both Pyrefly installation and configuration.

    :::note
    We don't provide instructions for setting up Neovim with versions prior to Neovim 0.11, though Pyrefly can work with them through [`neovim/nvim-lspconfig`](https://github.com/neovim/nvim-lspconfig).
    :::

    <details>
        <summary>Install Pyrefly for Neovim</summary>

        There are two methods we currently support for installing Pyrefly for Neovim:
        1. (recommended) Install the `mason-org/mason.nvim` plugin, which handles installing language services and configuring them easily.
        2. Use a system installation.

        <details>
            <summary>mason.nvim</summary>

            [mason.nvim](https://github.com/mason-org/mason.nvim) is our recommended approach, since it makes Pyrefly and other language servers, linters, and utilities easily available to Neovim.

            :::note
            Installing a binary with Mason will take precedence over other system installations. It might be worth using system installations (including installations in virtual environments) if you need to switch between different versions of Pyrefly for different projects.
            :::

            Install Mason using your Neovim plugin manager of choice, and make sure you call its setup function to make it available.

            To install Pyrefly, run `:MasonInstall pyrefly` in Neovim, and it will be installed! You can install a specific version of Pyrefly with `:MasonInstall pyrefly@<version>`, and manage Mason installations (including per-language-server-specific settings!) with `:Mason`.
        </details>

        <details>
            <summary>System Installations</summary>

            Pyrefly can also work with Neovim's `lspconfig` when using a system installation. This will work as long as the Pyrefly binary you want to use is available on your `$PATH`, which you can check by making sure commands like `pyrefly --help` succeed. If an installation is available on your `$PATH`, continue on to [configure](#configure-pyrefly-for-neovim) below.

            To install Pyrefly, you can use the package manager of your choice. We support `uv`, `pip`, `Cargo`, and anything else that can interface with PyPI (see [Installation](./installation.mdx) for more info).

            :::note
            If you're installing Pyrefly into a virtual environment, please be aware that Pyrefly will only work within Neovim if the virtual environment is activated when you start Neovim.
            :::

            Before moving on, double check that you can access Pyrefly on your `$PATH`. If you can, then continue with [configure](#configure-pyrefly-for-neovim).

            If Pyrefly is not available on your `$PATH`, you can try the following:
            - If you're using a virtual environment, try `source .venv/bin/activate` to ensure your venv is running, then see if `pyrefly` is available.
            - If you're using `uv`, you can ensure `uv`-installed tools are available on your path by running `uv tool update-shell`.
            - Configure `lspconfig` to use a specific executable/command by updating your Pyrefly-specific lspconfig settings. To do this, override the `cmd` configuration option with your command in the configuration section below.
        </details>

    </details>
    <details>
        <summary> Configure Pyrefly for Neovim</summary>

        This section describes how to tell Neovim how Pyrefly can be run, as well as how to override those settings.

        You have two options on how to do this:
        1. (recommended) Install or update the [`neovim/nvim-lspconfig`](https://github.com/neovim/nvim-lspconfig) plugin to get Pyrefly's (and other language servers') default configs. You can override specific settings if you'd like.
        2. Setup your language server manually without installing extra plugins.

        <details>
            <summary>Configs with `neovim/nvim-lspconfig` plugin</summary>

            [`neovim/nvim-lspconfig`](https://github.com/neovim/nvim-lspconfig) is a Neovim plugin acting as a repository of language server settings (a repository of language server settings) installed and updated to get Pyrefly's default configuration.

            We also recommend installing or updating the [mason-org/mason-lspconfig.nvim](https://github.com/mason-org/mason-lspconfig.nvim) plugin if you're using Mason, which provides other nice functionality when using Mason with `lspconfig`. If you install `mason-org/mason-lspconfig.nvim`, be sure to source it in your Neovim config.

            To override specific settings, see `:h vim.lsp.config`. See `:h vim.lsp.Config` and `:h vim.lsp.ClientConfig` for values you can override, and the [`nvim-lspconfig` Pyrefly config](https://github.com/neovim/nvim-lspconfig/blob/master/lsp/pyrefly.lua) for default values.

            Example overriding `cmd` and `filetypes`
            ```lua
            vim.lsp.config('pyrefly', {
                -- example of how to run `uv` installed Pyrefly without adding to your path
                cmd = { 'uvx', 'pyrefly', 'lsp' }
            })
            ```
        </details>

        <details>
            <summary>No-plugin Configs</summary>

            You have the option to setup your language server without
            `neovim/nvim-lspconfig`. Simply copy/modify the Pyrefly defaults
            from
            [`nvim-lspconfig`](https://github.com/neovim/nvim-lspconfig/blob/master/lsp/pyrefly.lua)
            in a block like below.

            **NOTE: This should be in a file under `nvim/lsp/pyrefly.lua`

            ```lua
            ---@type vim.lsp.Config
            return {
              cmd = { "pyrefly", "lsp" },
            }
            ```
        </details>

        :::tip
        [This Youtube tutorial](https://youtu.be/IZnhl121yo0?si=VINhYDEySX48_8GY) explains setting up a language server in more depth and with a more organized setup, so check it out if you want to learn more.
        :::

        :::info
        Want type error squiggles to show up in your editor by default? You can create a `pyrefly.toml` in your project root, add a `[tool.pyrefly]` section in your `pyproject.toml`, or add the following to the config object passed into `vim.lsp.config`.

        ```
        {
            settings = {
                python = {
                    pyrefly = {
                        displayTypeError = 'force-on'
                    }
                }
            }
        }
        ```
        :::


    </details>

    <details>
        <summary>Enable Pyrefly for Neovim</summary>

        If you've installed Pyrefly with Mason and have `mason-org/mason-lspconfig.nvim` installed, then your language server should just work! You can check by opening a file your language server should cover and running `:checkhealth lsp` to see if it's started. You may need to restart Neovim for any changes made above to take effect.

        Otherwise, to make sure your language servers are activated, be sure to enable them with the syntax below.

        ```lua
        vim.lsp.enable({"pyrefly"})
        ```

        :::tip
        If you're using `init.vim`, you can use a [lua heredoc](https://neovim.io/doc/user/lua.html#%3Alua-heredoc) to execute lua and enable your config.
        :::
    </details>
</details>

### Vim/Neovim + coc.nvim

Ensure the pyrefly is on `$PATH`, add following snippet to your `coc-settings.json`:

```json
"languageserver": {
  "pyrefly": {
    "command": "pyrefly",
    "args": ["lsp"],
    "filetypes": ["python"],
    "rootPatterns": ["pyrefly.toml", "pyproject.toml", ".git"],
  }
},
```

:::tip
Type errors aren't shown unless a configuration exists. To always display type errors with coc.nvim, add the following `initializationOptions` to your configuration:
```json
"languageserver": {
  "pyrefly": {
    "command": "pyrefly",
    "args": ["lsp"],
    "filetypes": ["python"],
    "rootPatterns": ["pyrefly.toml", "pyproject.toml", ".git"],
    "initializationOptions": {
      "pyrefly": {
        "displayTypeErrors": "force-on"
      }
    }
  }
}
```
Use `"default"` to only show type errors when a configuration exists, `"force-off"` to never show them, or `"error-missing-imports"` to only show import-related errors - this can help you determine if your Python interpreter is set correctly and all packages are installed.
:::

### Vim + ALE
Pull the latest version of ALE and add the following lines to your configuration
to enable Pyrefly in Vim with ALE:
```
let g:ale_linters = {
    ...
  \ 'python': ['pyrefly'],
    ...
  \ }
```

### Emacs

There are several emacs packages that implement the language server protocol; the `eglot` package
is built into recent versions of emacs. You can tell `eglot` to use `pyrefly` (which we assume
is on your `$PATH`) with the following configuration:
```
(add-to-list 'eglot-server-programs
  `((python-ts-mode python-mode) . ("pyrefly" "lsp")))
```

If you are using `use-package`, this command would run inside of the `:config` block; a minimal
example would look like this:
```
(use-package eglot
  :ensure t
  :hook ((python-mode python-ts-mode) . eglot-ensure)
  :config
  (add-to-list 'eglot-server-programs
    `((python-ts-mode python-mode) . ("pyrefly" "lsp"))))
```

### Helix

Ensure that pyrefly is on `$PATH` (If you got Pyrefly using `pip install pyrefly`, it should already be on your path).
Add this snippet to your `languages.toml` file

```toml
[language-server.pyrefly]
command = "pyrefly"
args = ["lsp"]

[[language]]
name = "python"
language-servers = ["pyrefly"]
```

### Sublime

See the documentation [here](https://lsp.sublimetext.io/language_servers/#pyrefly).

### Positron

Positron comes with Pyrefly out of the box. See the documentation [here](https://positron.posit.co/guide-python.html#settings).

### Jupyter Lab

Pyrefly may be used in Jupyter Lab through the [jupyterlab-lsp](https://jupyterlab-lsp.readthedocs.io/en/latest/Installation.html) extension.

### Zed

Zed users can install the Pyrefly extension from [here](https://zed.dev/extensions/pyrefly) or by visiting the extensions marketplace:

<video
  src="/videos/zed.mov"
  width="720"
  muted
  loop
  autoPlay
  playsInline
  preload="metadata"
/>

Here's an example of a Zed config with Pyrefly integration:

```json
{
  "lsp": {
    "pyrefly": {
      "binary": {
        "path": ".venv/bin/pyrefly",
        "arguments": ["lsp"]
      }
    }
  },
  "languages": {
    "Python": {
      "language_servers": ["pyrefly"],
    }
  }
}
```


---

---
title: Infer

description: Automatically add type annotations to your code with the Pyrefly infer feature.
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

# Pyrefly Infer

Manually adding type annotations to your code can be tedius and time-consuming. Pyrefly can help with this task by automatically adding type annotations to your code.

This feature is currently under active development, and the following sections will be updated as the feature matures. We currently recommend manually reviewing the changes created by `pyrefly infer`

## Usage

To use the infer feature, run the following command in your project directory:

```
pyrefly infer path/to/file.py
# or
pyrefly infer path/to/directory/
```

We recommend running it in small batches to make reviewing and merging changes easier. Flags can be used to turn on / off adding annotations for parameters, return types, and containers.

It is common that new annotations will expose new type errors. See our error suppression guides to learn how to automate silencing these errors.


---

---
title: Configuration
slug: /configuration

description: Configure Pyrefly settings and options
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

# Pyrefly Configuration

Pyrefly has a basic configuration that can (or will) allow you to customize your
Pyrefly runs without having to specify all of your arguments on the command
line.

NOTE: this is early in its development, so the options listed here are subject
to change in name, usage, type, quantity, and structure.

Configurations can be specified in a [TOML file](https://toml.io/en/) at the root of
your project (or elsewhere, as long as the path-based config options point to the right place) named
`pyrefly.toml`, with all configuration options in the top-level of the document.
You can also specify a configuration in a `pyproject.toml` under a `[tool.pyrefly]`
section. Other config names can be used when explicitly passing in the config file
name with the `--config`/`-c` flag, but they will not be automatically found by
[Configuration Finding](#configuration-finding).

Both absolute and config-relative paths are supported.

:::info
Want type error squiggles to show up in your editor by default? Try setting `python.pyrefly.displayTypeErrors` to `"force-on"` in your editor settings, create a `pyrefly.toml` file in your project root, or add a `[tool.pyrefly]` section to your `pyproject.toml` (can be empty).
:::

## Simple Configuration Example

Here's an example of a simple config. To see more complex examples,
including in a `pyproject.toml`, look at
[Example Configurations](#example-configurations), which show Pyrefly's default
config, as well as other ways you can set your configuration.

```toml
# set the directory Pyrefly will search for files to type check
project-includes = [
    "a", "b/c/d", "e"
]

# manually set the `sys.platform` Pyrefly will assume when type checking
python-platform = "linux"

# a table mapping error codes to an `is-enabled` boolean
[errors]
# disable `bad-assignment` errors
bad-assignment = false
# disable `bad-return` errors
bad-return = false
```

## Precedence in Options

[Configuration options](#configuration-options) are selected in the following order

1. CLI flags
    - Examples: `--project-excludes <value>`, `--python-version <value>`
2. Configuration options
    - Examples: (in a `pyrefly.toml`) `project-excludes = <value>`, `python-version = <value>`
3. Pyrefly defaults
    - See [Default `pyrefly.toml`](#default-pyreflytoml) for the default values used

## Type Checking Modes

Pyrefly has two different modes it can run in when type checking your project, which
correspond to different but useful ways we expect most people to interact with Pyrefly:

- **Project** mode: attempt to load a config, falling back to Pyrefly's default config when
  none can be found, and type check using that one config. This involves getting the
  [`project-includes`](#project-includes) and [`project-excludes`](#project-excludes) from the file, expanding the patterns,
  and type checking on those files.
    - Project mode is used whenever no files are provided with the CLI invocation.
- **Per-file** or **Single-file** mode: when given [`FILES...`](#project-includes) (and optionally [`--project-excludes`](#project-excludes))
  during a CLI invocation, expand the patterns and find the relevant config file for each
  file listed. `project-includes` and `project-excludes` are ignored from the config file,
  but it is used for all remaining config options.

## Configuration Finding

In both project checking mode and single-file checking mode (see [Type Checking Modes](#type-checking-modes)
for more info), we attempt to find a _project root_ from which to check each file, both for reading
config options and for import resolution. The project root is typically the directory containing the
configuration file. More precisely:

1. If a configuration file is provided with `-c`/`--config`, we use the directory the file is located in as the directory to check.
2. If no configuration file is passed, we perform an upward file search from the 'start location' to the filesystem root,
   looking in each directory for any of the following files: `pyrefly.toml`, `pyproject.toml`,
   `setup.py`, `mypy.ini`, and `pyrightconfig.json`. If we find one, we use the directory it's found in as the containing directory.
3. If no configuration file is found, we will still attempt to resolve imports by walking up the tree looking for a matching import. For example: when
   importing `from a.b.c import q`, if our project structure
   looks like `/x/y/z/a/b/c`, we can walk up the components of `a.b.c` to find a root at
   `/x/y/z`.

Note that only `pyrefly.toml` and `pyproject.toml` are parsed for config options, but we look for
additional files that mark the root of a project to aid import resolution.

For project checking mode, the 'start location' is current working directory. For single-file checking mode,
the start location is the directory containing each file to be type checked, and
we find the config for each file matched by the pattern provided.

If a `pyrefly.toml` is found, it is parsed and used for type checking, and will
return an error to the user on invalid types, syntax, values, or unknown config options.

If a `pyproject.toml` is found, Pyrefly will use the `[tool.pyrefly]`
section if it exists, otherwise it will assume a default config.
The same errors will be returned as when loading a `pyrefly.toml` if
the config is invalid.

### Providing a Config in Single-File Mode

Providing `-c`/`--config` in single-file checking mode disables the upward file search for config
files. All options are read from the provided config file except `project-includes` and
`project-excludes`, which are ignored.

## Configuration Options

The following section lists all recognized options that can be specified in a config
file or `pyproject.toml` Pyrefly config section.

### `project-includes`

The glob patterns used to describe which files to type
check, typically understood as user-space files.

This does not specify
[Import Resolution](./import-resolution.mdx) priority or the path an
import should be resolved from. See [`search-path`](#search-path) instead.

- Type: list of [filesystem glob patterns](#filesystem-globbing)
- Default: `["**/*.py*"]`
- Flag equivalent: `FILES...` argument
- Equivalent configs: `include` in Pyright, `files`/`modules`/`packages` in
  mypy
- Notes:
    - When overridden by passing in `FILES...`, we do not consult the
      relevant config file for what to use for `project-excludes`.
      If `project-excludes` should not use the default value, override it with the flag as
      well. This is because
      if multiple configs are loaded that conflict with `project-includes`, determining
      how to resolve checkable files gets complicated, and might become confusing to
      anyone attempting a type check if they're unaware of all the configs that will be
      used in the type check. Also, we get into a chicken-and-egg problem, where we
      don't know which files to exclude until we load all the configs we'll need,
      which requires loading all files, and imposes a large performance burden.
    - When a `project-includes` pattern does not match any files, we will return
      an error.
    - If you get an error about no matches for a directory when passing a glob as a CLI
      argument, try wrapping the glob in quotes to prevent eager shell glob expansion.

### `project-excludes`

The glob patterns used to describe which files to avoid
type checking as way to filter files that match `project-includes`,
but we don't want to type check.

The default value is appended to your `project-excludes` unless `disable-project-excludes-heuristics`
is set. See [`disable-project-excludes-heuristics`](#disable-project-excludes-heuristics) to fully replace
or remove `project-excludes`.

- Type: list of [filesystem glob patterns](#filesystem-globbing)
- Default: `["**/node_modules", "**/__pycache__", "**/venv/**", "**/.[!/.]*/**"]` +
  anything in your `site-package-path` (even from the interpreter) unless it would
  exclude items in your [`search-path`](#search-path).
- Flag equivalent: `--project-excludes`
- Equivalent configs: `exclude` in Pyright and mypy
- Notes:
    - While not explicitly part of `project-excludes`, there are several patterns that are
      filtered out of type checked files at our glob-implementation layer.
        - Dotfiles (any files that begin with a dot (`.<stuff>`)
        - Any files that don't end in `.py` or `.pyi`
        - Your [`site-package-path`](#site-package-path) (including paths queried from
          the interpreter)
    - It is an error if no files are returned from any `project-includes` because
      they are filtered out by `project-excludes` entries. We differentiate between
      an error from a `project-includes` that doesn't match any files, and an error
      from all `project-includes` getting filtered by `project-excludes`.
    - When overridden by passing in `FILES...`, we do not consult the
      relevant config file for what to use for `project-excludes`.
      If `project-excludes` should not use the default value, override it with the flag as
      well. See reasoning in [`project-includes` notes](#project-includes).
    - Your [`site-package-path`](#site-package-path) is added to your `project-excludes`
      automatically. If you are trying to perform type checking on a dependency in your
      `site-package-path` (i.e. `cd <site-package-path>/some_dependency && pyrefly check`),
      we recommend you pull and set up your dependency from GitHub, but you can achieve
      this on files in your `site-package-path` by setting `site-package-path = []` in
      your config.

### `disable-project-excludes-heuristics`

By default, Pyrefly includes several items in your [`project-excludes`](#project-excludes)
(see `project-excludes` for the default values). These items are path patterns we've
determined rarely have files that should be type checked, but can require a very long
time to crawl while enumerating files, or contain third-party code that you likely
don't care about errors in. When specifying `project-excludes`, we always append
these defaults to whatever is specified by CLI or in your configuration.

Sometimes, these preselected settings can interfere with your project's setup.
`disable-project-excludes-heuristics` lets you start from scratch, setting that default to `[]`,
so you can fully specify your `project-excludes` in case we get it wrong.

- Type: `bool`
- Default: `false`
- Flag equivalent: `--disable-project-excludes-heuristics`

### `search-path`

A file path describing the roots from which imports should be
found and imported from (including modules in [`project-includes`](#project-includes)). This takes
the [highest precedence in import order](./import-resolution.mdx#absolute-imports),
before `typeshed` and [`site-package-path`](#site-package-path). When a `project-includes`
type checked file is imported by another type checked file, we check all search roots to
determine how to import it.

- Type: list of directories specifying the root
- Default: import root
- Flag equivalent: `--search-path`
- Equivalent configs: `extraPaths` in Pyright, `mypy_path` in mypy
- Notes:
    - We automatically apply some heuristics to improve your experience, especially
      when no configuration is provided. See
      [`disable-search-path-heuristics`](#disable-search-path-heuristics) to disable
      this behavior, and [Search Path Heuristics](#search-path-heuristics) for the
      additional paths we add to your `search-path`.
    - Libraries should not be listed here, since they may override `typeshed`
      values for your whole project, and have different import semantics with
      respect to typing. See
      [Import Resolution](./import-resolution.mdx)
      for more information about how modules are imported.

### `disable-search-path-heuristics`

Disable any search path heuristics/additional search path behavior that Pyrefly will
attempt to do for you. This can be useful if Pyrefly is picking up the wrong import
paths for your project, for example, if you have multiple projects in the same
directory or use a monorepo setup with the import root outside of the directory
your configuration is defined in.

See [Search Path Heuristics](#search-path-heuristics) for more information on the
search paths that are automatically added, and are affected by this flag. For more
information on import resultion in general see the
[import resolution docs](import-resolution.mdx).

- Type: bool
- Default: false
- Flag equivalent: `--disable-search-path-heuristics`
- Equivalent configs: none
- Notes
    - To see what search path we find for your a given file in your project, or
      your project overall, you can run `pyrefly dump-config [<file>...]`.

#### **Search Path Heuristics**

Pyrefly adds extra search paths to your configuration behind-the-scenes to handle
the most common ways of setting up and configuring your project, on top of any
[`search-path`](#search-path) entries you may pass in through the CLI or
set in your config.

The two heuristics that are currently supported are:

1. Adding your import root to the end of your search path. Your import root is
   a `src/` directory in the same directory as a config file, the parent directory
   containing your config file if there's an `__init__.py` or `__init__.pyi` present
   _or_ the config file's directory itself if none of the previously mentioned directories
   or files can be found.
   See [Configuration Finding](#configuration-finding) for more information on
   what we'll find as a config file.
2. If no config can be found, each directory from the given file to `/` will be
   added as a fallback search path.

See more on [how Pyrefly does import resolution](import-resolution.mdx).

### `site-package-path`

A file path describing a root from which imports should
be found and imported from. This takes the lowest priority in import
resolution, after [`search-path`](#search-path) and `typeshed`.

See more on [how Pyrefly does import resolution](import-resolution.mdx).

- Type: list of directories
- Default: `./typings` + the result from [Environment Autoconfiguration](#environment-autoconfiguration), or
  `[]` if the Python interpreter cannot be queried
- Flag equivalent: `--site-package-path`
- Equivalent configs: none
- Notes:
    - The queried interpreter's site package paths will always be included in addition to any user-specified value,
      unless environment auto-configuration is turned off.
    - Ideally, this should not be set manually, unless you're using a venv, running one-off tests,
      testing specific behavior, or having trouble with [Environment Autoconfiguration](#environment-autoconfiguration).
      Setting this explicitly, especially when not using a venv, will make it difficult for your configuration
      to be reused between different systems and platforms.
    - If you're running into problems with editiable installations in your project,
      please read up on [editable installs with static analysis tools](import-resolution.mdx#editable-installs).

### `python-platform`

The value used with conditions based on type checking
against
[`sys.platform`](https://docs.python.org/3/library/sys.html#sys.platform)
values.

- Type: string
- Default: result from [Environment Autoconfiguration](#environment-autoconfiguration), or
  "linux" if the Python interpreter cannot be queried
- Flag equivalent: `--python-platform`
- Equivalent configs: `pythonPlatform` in Pyright, `platform` in mypy

### `python-version`

The value used with conditions based on type checking
against
[`sys.version`](https://docs.python.org/3/library/sys.html#sys.version)
values. The format should be `<major>[.<minor>[.<micro>]]`, where minor and
micro can be omitted to take the default positional value.

- Type: string of the format `<major>[.<minor>[.<micro>]]`
- Default: result from [Environment Autoconfiguration](#environment-autoconfiguration), or
  `3.13.0` if the Python interpreter cannot be queried
- Flag equivalent: `--python-version`
- Equivalent configs: `pythonVersion` in Pyright, `python_version` in mypy

### `conda-environment`

The name of the Conda environment to query when attempting to autoconfigure
Python environment values (`site-package-path`, `python-platform`, `python-version`).
See the [Environment Autoconfiguration section](#environment-autoconfiguration) for more
information. We query Conda with `conda info --envs`, then find the environment's interpreter in Environment Autoconfirugration.

We will query Conda for information about this environment, even when it's not sourced,
unless a Python environment (venv, Conda) is activated or `--python-interpreter-path` or
`--conda-environment` are passed in through the CLI.

**`conda-environment`, `fallback-python-interpreter-name`, `conda-environment`,
and `skip-interpreter-query` are mutually exclusive with each other.**

- Type: string of existing Conda environment name
- Default: none
- Flag equivalent: `--conda-environment`
- Equivalent configs: none
- Notes:
    - This enables the use of a non-local but customizable global environment without having to hard-code a path, which is not preferable on a shared project.

### `python-interpreter-path`

The Python interpreter to query when attempting to autoconfigure
Python environment values (`site-package-path`, `python-platform`, `python-version`).
See the [Environment Autoconfiguration section](#environment-autoconfiguration) for more information.

**`conda-environment`, `fallback-python-interpreter-name`, `conda-environment`,
and `skip-interpreter-query` are mutually exclusive with each other.**

- Type: path to executable
- Default: `$(which python3)`, then `$(which python)`, or none
- Flag equivalent: `--python-interpreter-path`
- Equivalent configs: `python_executable` in mypy
- Notes:
    - This executes the value present in the `python-interpreter-path` field without any checks. It could
      be a security risk if your `python-interpreter-path` is an arbitrary executable.
    - If you don't have a Python interpreter installed on your machine, we'll output an
      error letting you that we couldn't appropriately configure your environment.
      Configure `skip-interpreter-query` to skip the check and avoid the error.

NOTE: Ideally, this should not be set manually, unless you're using a venv, running one-off tests,
testing specific behavior, or having trouble with [Environment Autoconfiguration](#environment-autoconfiguration).
Setting this explicitly, especially when not using a venv, will make it difficult for your configuration
to be reused between different systems and platforms.

### `fallback-python-interpreter-name`

The Python interpreter, available on your `$PATH`, to use. Pyrefly will perform
`which <your command>`, and automatically fill in `python-interpreter-path` for you with
the found path. Pyrefly will automatically search for `python3` and `python` on your
path when this option and [`python-interpreter-path`](#python-interpreter-path) are unset if
[`skip-interpreter-query = false`](#skip-interpreter-query),
so this should primarily be used when you have a non-standard Python executable you want to
use.

**`conda-environment`, `fallback-python-interpreter-name`, `conda-environment`,
and `skip-interpreter-query` are mutually exclusive with each other.**

- Type: string of command to use
- Default: `python3`, then `python`, or none
- Flag equivalent: `--fallback-python-interpreter-name`
- Notes:
    - This executes the value present in the `fallback-python-interpreter-name` field without
      any checks. It could be a security risk if your `fallback-python-interpreter-name` is an
      arbitrary executable.
    - If you don't have a Python interpreter installed on your machine, we'll output an
      error letting you that we couldn't appropriately configure your environment.
      Configure `skip-interpreter-query` to skip the check and avoid the error.

### `skip-interpreter-query`

Skip querying any interpreters and do not do any
[Environment Autoconfiguration](#environment-autoconfiguration). This means that
Pyrefly will take hard-coded defaults for [`python-version`](#python-version`)
and [`python-platform`](#python-platform), and will use an empty
[`site-package-path`](#site-package-path). It's likely you'll want to override
these to match the environment you'll be running in.

**`conda-environment`, `fallback-python-interpreter-name`, `conda-environment`,
and `skip-interpreter-query` are mutually exclusive with each other.**

- Type: bool
- Default: `false`
- Flag equivalent: `--skip-interpreter-query`

### `typeshed-path`

Override the version of typeshed that's being used for type checking. The provided
path should point to the root of typeshed.

[Typeshed](https://github.com/python/typeshed) contains the type information for Python's
standard library, which Pyrefly uses for type checking and resolving both the most basic
types (like `object`, `str`, ...) and types/type signatures from stdlib modules.

- Type: path to typeshed
- Default: none (resolves to bundled typeshed)
- Flag equivalent: `--typeshed-path`

### `baseline`

Path to a baseline JSON file for comparing type errors. Errors matching the baseline
are suppressed, so only newly-introduced errors are reported. This is useful when
introducing type checking to a project for the first time, or when rolling out
changes that would otherwise produce many new errors at once.

To generate (or re-generate) the baseline file, run:

```
pyrefly check --baseline="<path to baseline file>" --update-baseline
```

See the [Error Suppressions docs](./error-suppressions.mdx#baseline-files-experimental) for
more details on how baseline files work.

- Type: path to a JSON file
- Default: none (no baseline)
- Flag equivalent: `--baseline`
- Notes:
    - `baseline` is a **project-level setting** and cannot be overridden in
      [`sub-config`](#sub-configs) sections.
    - Errors suppressed by the baseline file are still shown in the IDE.
    - Errors are matched with the baseline by file, error code, and column number.

### `errors`

Configure the severity for each kind of error that Pyrefly emits: `error`, `warn`, `ignore`.

:::info
Want type error squiggles to show up in your editor by default? Try setting `python.pyrefly.displayTypeErrors` to `"force-on"` in your editor settings, create a `pyrefly.toml` file in your project root, or add a `[tool.pyrefly]` section to your `pyproject.toml` (can be empty).
:::

- Type: Table of [error code](./error-kinds.mdx) to boolean representing enabled status
- Default: `errors = {}`/`[errors]`
- Flag equivalent: `--error`, `--warn`, `--ignore`
- Equivalent configs:
  [type check rule overrides](https://microsoft.github.io/pyright/#/configuration?id=type-check-rule-overrides)
  and [type evaluation settings](https://microsoft.github.io/pyright/#/configuration?id=type-evaluation-settings)
  in Pyright,
  [`enable_error_code`](https://mypy.readthedocs.io/en/stable/config_file.html#confval-enable_error_code) and
  [`disable_error_code`](https://mypy.readthedocs.io/en/stable/config_file.html#confval-disable_error_code)
  in mypy
- Notes:
    - Setting `<error-code> = true` means the error will be shown at default
      severity (or severity `ERROR` if the error is off by default). Setting
      `<error-code> = false` will disable the error for type checking.
    - If you want to disable type errors in IDE mode, you can also set
      [`disable-type-errors-in-ide`](#disable-type-errors-in-ide), which will
      automatically disable _all_ type errors and Pyrefly diagnostics in the IDE.

### `disable-type-errors-in-ide`

Disables type errors from showing up when running Pyrefly in an IDE. This is primarily
used when Pyrefly is acting in a language-server-only mode, but some kind of
manual configuration is necessary for it to work properly, or when you would
_only_ want to see type errors on CLI/CI runs.

- Type: `bool`
- Default: `false`
- Flag equivalent: none
- Notes: if you want to disable errors on CLI/CI runs as well, or if you're looking
  to turn on/off specific errors, you may be looking for the [`errors`](#errors) config
  option instead.

### `skip-lsp-config-indexing`

Disables automatic project indexing when running Pyrefly as a language server.
Enabling this may speed up LSP startup and reduce resource usage on large projects,
at the cost of some language server features that rely on a full project index.

- Type: `bool`
- Default: `false`
- Flag equivalent: none

### `replace-imports-with-any`

Instruct Pyrefly to unconditionally replace the given [`ModuleGlob`](#module-globbing)s
with `typing.Any` and ignore import errors for the module. For example,
with `from x.y import z` in a file, adding `x.*`, `*.y`, or `x.y` to this config will
silence those import errors and replace the module with `typing.Any`. If the module
can be found, its type information will still be replaced with `typing.Any`.

This is different from [`ignore-missing-imports`](#ignore-missing-imports), which only
replaces the import with `typing.Any` if it can't be found.

- Type: list of regex
- Default: `[]`
- Flag equivalent: `--replace-imports-with-any`
- Equivalent configs: `follow_imports = skip` in mypy

### `ignore-missing-imports`

Instruct Pyrefly to replace the given [`ModuleGlob`](#module-globbing)s
with `typing.Any` and ignore import errors for the module _only when the module
can't be found_.

For example, with `from x.y import z` in a file, adding `x.*`, `*.y`, or `x.y` to
this config will silence those import errors and replace the module with `typing.Any`
if `x.y` can't be found. If `x.y` can be found, then `z`'s type will be used.

This is different from [`replace-imports-with-any`](#replace-imports-with-any), which
will always, unconditionally replace the import with `typing.Any`.

- Type: list of regex
- Default: `[]`
- Flag equivalent: `--ignore-missing-imports`
- Equivalent configs: `ignore_missing_imports` in mypy
- Notes:
    - `errors = {missing-import = false}` (TOML inline table for `errors`) has similar behavior in Pyrefly, but ignores
      _all_ import errors instead of import errors from specific modules.
    - When a `.pyc` file is encountered and no source/stub files are available, Pyrefly automatically treats module as `typing.Any`.
      This behavior ensures that compiled Python files without available source code do not cause import errors and are handled permissively.

### `ignore-errors-in-generated-code`

Whether to ignore type errors in generated code. If enabled, generated files
will be treated as if they are included in `project-excludes`.
The generated code status is determined by checking if the file contents contain
the substring '<span>&#64;</span>generated'.

- Type: bool
- Default: `false`
- Flag equivalent: `--ignore-errors-in-generated-code`
- Equivalent configs: none

### `infer-with-first-use`

Whether to infer type variables not determined by a call or constructor based on their first usage.
This includes empty containers like `[]` and `{}`.

The default behavior is similar to Mypy - the type of the variable is inferred based on the first usage.

```python
x = []
x.append(1)  # x is list[int]
x.append("2")  # error!
```

Setting this to false will make Pyrefly infer `Any` for unsolved type variables, which behaves like Pyright.

```python
x = []  # x is list[Any]
x.append(1)  # ok
x.append("2")  # ok
```

- Type: bool
- Default: `true`
- Flag equivalent: `--infer-with-first-use`

### `untyped-def-behavior`

How should Pyrefly treat function definitions with no parameter or return type annotations?

By default, Pyrefly uses the `"check-and-infer-return-type"` behavior and will
check all function bodies, inferring the return type.

:::info
To provide inferred return types with `check-and-infer-return-type`, especially for
site-package paths (third-party packages), Pyrefly may need to load and analyze
more modules than you might otherwise see from mypy.

This may result in increased type check durations or an output showing more modules
analyzed than you expect. If this behavior is not preferred, you should set
`untyped-def-behavior` to `skip-and-infer-return-any` in your config or pass it in
as a flag.
:::

If this option is set to `"check-and-infer-return-any"`, then Pyrefly will still
check the function body but will treat the return type as `Any`.

If this option is set to `"skip-and-infer-return-any"`, Pyrefly will again treat
the return type as `Any`, but will also skip checking the function body. In this
case, Pyrefly will also infer `Any` as the type of any attributes inferred based
on this function body. This behavior is what PEP 484 specifies, although we do
not recommend it for most users today; since Pyrefly will not analyze the bodies
of untyped functions, language server functionality like showing types on hover
and finding definitions will not be available there.

:::info
`skip-and-infer-return-any` is mypy's default inference behavior, and how we will
attempt to migrate your existing mypy configuration when running `pyrefly init`.
See [Migrating from Mypy](migrating-from-mypy.mdx#mypy-config-migration) for more information on config migration.
:::

- Type: one of `"check-and-infer-return-type"`, `"check-and-infer-return-any"`,
  `"skip-and-infer-return-any"`
- Default: `"check-and-infer-return-type"`
- Flag equivalent: `--untyped-def-behavior`
- Equivalent configs:
    - The `"check-and-infer-return-type"` behavior emulates Pyright's default
      behavior.
    - The `"skip-and-infer-return-any"` behavior emulates mypy's default behavior.
    - The `"check-and-infer-return-any"` behavior emulates mypy's
      `check_untyped_defs` flag.

### `use-ignore-files`

Whether to allow Pyrefly to use ignore files in your project and automatically
add excluded files and directories to your [`project-excludes`](#project-excludes).
Similar to `project-excludes`, when explicitly specifying files to check, ignore files
are not used.

Pyrefly automatically searches for ignore files such as `.gitignore`, `.ignore`,
and `.git/info/excludes` in an upward search from your project root. Only the first of each
type of ignore file will be used, so if you have a `.gitignore` and `.git/info/excludes`
available, in different directories, Pyrefly will use both of them. Pyrefly will not
use global ignore files.

When multiple ignore files are found, Pyrefly checks them for excludes matches when
determining the files to type check in the order of `.gitignore`, `.ignore`, and
`.git/info/excludes`, taking the result of the first ignore file that has a match (either
allowlist or denylist). Regular
[`.gitignore`-style allowlist/denylist matching rules](https://git-scm.com/docs/gitignore) apply.

- Type: `bool`
- Default: `true`
- Flag equivalent: `--use-ignore-files`

### `build-system`

Pyrefly supports integrating into build systems to discover targets to type
check and their dependencies. It currently natively supports
[Buck2](https://buck2.build), as well as arbitrary build systems via custom
queries.

**Note that support for build systems is currently unstable, and breakage may
occur without notice. Support will likely be lower priority than other issues
for a while.**

#### Buck2

To configure Pyrefly to use Buck2 as a build system, add the following to your
`pyrefly.toml`:

```toml
[build-system]
type = "buck"
# Optional: The isolation dir for Buck2 to use.
isolation-dir = "pyrefly"
# Optional: Extra flags passed to Buck2.
extras = ["--verbose", "4"]
```

Behind the scenes, Pyrefly will run the
`prelude//python/sourcedb/pyrefly.bxl:main` [BXL
script](https://buck2.build/docs/bxl/) to get the necessary information about
the targets to type check.

Here is a description of the supported optional options:

**`isolation-dir`**

Name of the isolation dir to use when running the BXL query (see `buck2 --help`
or [Buck's documentation](https://buck2.build/docs/concepts/isolation_dir/) for
more information about isolation dirs).

Type: string
Default: none (Buck's own default is `v2`)

**`extras`**

Extra command line arguments passed to `buck2` when running the query.

- Type: list of strings
- Default: `[]`

#### Custom queries

Arbitrary build systems can be integrated using the `custom` type:

```toml
[build-system]
type = "custom"
command = ["some", "command", "..."]
```

Here is a description of the supported options:.

**`command`**

The command executed to query the build system about available targets.

Pyrefly will call this in the form `<command...> @<argfile>`, where `<argfile>`
has the format:

```text
--
<arg-flag>
<arg>
...
```

`<arg-flag>` is either `--file` or `--target`, depending on the type of
`<arg>`, and `<arg>` is an absolute path to a file or a build system's target.

The command should output a JSON file with the following structure:

```json
{
    "root": "/path/to/this/repository",
    "db": {
        "//colorama:py-stubs": {
            "srcs": {
                "colorama": [
                    "colorama/__init__.pyi"
                ]
            },
            "deps": [],
            "buildfile_path": "colorama/BUCK",
            "python_version": "3.12",
            "python_platform": "linux"
        },
        "//colorama:py": {
            "srcs": {
                "colorama": [
                    "colorama/__init__.py"
                ]
            },
            "deps": ["//colorama:py-stubs"],
            "buildfile_path": "colorama/BUCK",
            "python_version": "3.12",
            "python_platform": "linux"
        },
        "//colorama:colorama": {
            "alias": "//colorama:py"
        }
    }
}
```

Where:

- `root` is the absolute path the root of the repository.
- `db` is a map from target names to either:
    - library target definitions (e.g. `//colorama:py` and `//colorama:py-stubs` here)
    - target aliases (e.g. `//colorama:colorama` here)

For reference, the command invoked as part of the Buck2 integration is:

```sh
buck2 [--isolation-dir <isolation_dir>] bxl --reuse-current-config [<extras>...] prelude//python/sourcedb/pyrefly.bxl:main @<argfile>
```

- Type: list of strings
- Default: none (the option is required)

**`repo_root`**

Path to the root of the repository.

- Type: path
- Default: none

### `permissive-ignores`

Should Pyrefly ignore errors based on annotations from other tools, e.g. `# pyre-ignore` or `# mypy: ignore`?
By default, respects `# pyrefly: ignore` and `# type: ignore`.
Enabling this option is equivalent to passing the names of all tools to `enabled-ignores`.

- Type: `bool`
- Default: `false`
- Flag equivalent: `--permissive-ignores`

### `enabled-ignores`

What set of tools should Pyrefly respect ignore directives from?
Passing the names of all tools is equivalent to enabling `permissive-ignores`.

- Type: list of tools
- Default: `["type", "pyrefly"]`
- Flag equivalent: `--enabled-ignores`

### `sub-config`

Override specific config values for matched paths in your project. See
[SubConfigs](#sub-configs) for more information on the structure
and values that can be overridden here.

- Type: [TOML array of tables](https://toml.io/en/v1.0.0#array-of-tables) with a [SubConfig structure](#subconfigs)
- Default: `[]`
- Flag equivalent: none
- Equivalent configs: `executionEnvironments` in Pyright, per-module config options in mypy

### `recursion-depth-limit`

:::warning
This is a debugging option for investigating stack overflow issues. You should only use
this if Pyrefly is crashing with a stack overflow. If you encounter such a crash, please
[open an issue](https://github.com/facebook/pyrefly/issues).
:::

Maximum recursion depth before triggering overflow protection. When set to a non-zero value,
Pyrefly will detect when type checking recursion exceeds this limit and handle it according
to [`recursion-overflow-handler`](#recursion-overflow-handler).

- Type: integer
- Default: `0` (disabled)
- Flag equivalent: `--recursion-depth-limit`

### `recursion-overflow-handler`

:::warning
This is a debugging option. See [`recursion-depth-limit`](#recursion-depth-limit) above.
:::

How to handle when the recursion depth limit is exceeded:

- `"break-with-placeholder"`: Return a placeholder type and emit an internal error. Safe for IDE use.
- `"panic-with-debug-info"`: Dump debug information to stderr and panic. For debugging stack overflow issues.

- Type: one of `"break-with-placeholder"`, `"panic-with-debug-info"`
- Default: `"break-with-placeholder"`
- Flag equivalent: `--recursion-overflow-handler`

## Configuration Details

This section describes some of the configuration options, behaviors, or types in more depth, when
there are details shared between multiple config options or the information is more than what
can fit under a single config option description.

### Environment Autoconfiguration

Unless `skip-interpreter-query` is set, we'll attempt to query a Python interpreter to
determine your [`python-platform`](#python-platform) or
[`python-version`](#python-version) if they're unset. We also get a
[`site-package-path`](#site-package-path) from your interpreter to determine which
packages you have installed and append those to the end of any `site-package-path`
you've configured yourself, either through CLI flags or a config file.

We look for an interpreter with the following logic:

1. Use [`python-interpreter-path`](#python-interpreter-path),
   [`fallback-python-interpreter-name](#fallback-python-interpreter-name), or
   [`conda-environment`](#conda-environment) if any are set by a flag.
   More than one cannot be set in flags at the same time.
2. Determine if there's an active `venv` or `conda` environment. If both are active at
   the same time, we take `venv` over `conda`.
3. Use [`python-interpreter-path`](#python-interpreter-path),
   [`fallback-python-interpreter-name](#fallback-python-interpreter-name), or
   [`conda-environment`](#conda-environment) if either are set in a config file.
   Both cannot be set in a config at the same time.
4. Find a `venv` at the root of the project by searching for something that looks like a
   Python interpreter (matches `python(\d(\.\d+)?)?(.exe)?` regex), and looking
   for a `pyvenv.cfg` file in known locations. If we can't determine the root of your
   project with a config file or other well-known root marker file (e.g. `setup.py`,
   `pyrightconfig.json`, `mypy.ini`), this step is skipped.
5. Query `$(which python3)` and `$(which python)` (platform independent) to use
   a system-installed interpreter.
6. Fall back to Pyrefly's default values for any unspecified config options.

The config options we query the interpreter for are:

- `python-platform`: `sys.platform`
- `python-version`: `sys.version_info[:3]`
- `site-package-path`: `site.getsitepackages() + [site.getusersitepackages()]`

:::info
You can run `pyrefly dump-config` and pass in your file or configuration like you would
with `pyrefly check` to see what Pyrefly finds for your Python interpreter and
`site-package-path`, along with other useful config-debugging features.
:::

### Filesystem Globbing

We use a standard Unix-style glob, which allows for wildcard matching when specifying a fileset. It is similar
to regex, but more restricted given the subset of allowed syntax for paths on a filesystem. We currently only
allow matching files with a `.py`, `.pyi`, or `.pyw` suffix.

The globs provided are relative to the config, if one is found, or the current working directory otherwise.
Absolute path globs can also be provided, though this is generally not recommended, since it may not
be compatible with other systems type checking your project.

- We recognize the following wildcards:
    - `*` matches zero or more characters in a single directory component
    - `**` matches the current and any sub directories/files in those sub directories
    - `?` matches any one character
    - `[<pattern>]` matches any character or character range between the brackets (character range separated by `-`)
    - `[!<pattern>]` excludes any character or character range between the brackets and after the `!`
    - Note: `[]` can be used to match `?`, `*`, `[`, `]` literally (e.g. `[?]`), although these are invalid as part of a Python path.

We also support non-wildcard paths, so a relative (or absolute) path like `src/` will match all Python files under `src/`
or `src/my_file.py` will match `src/my_file.py` exactly.

Any directories matched will also have their `.py` and `.pyi` files recursively matched. `src/*` will match all files and
directories under `src/`, so therefore, we will recursively match everything under `src/`.

Examples:

- `src/**/*.py`: only match `.py` files under `src/`
- `src`, `src/`, `src/*`, `src/**`, and `src/**/*`: match all `.py` and `.pyi` files under `src/
- `?.py` and `[A-z].py`: match any file that looks like `<letter>.py`
- `src/path/to/my/file.py`: only match `src/path/to/my/file.py`
- `src/**/tests`, `src/**/tests/`, `src/**/tests/**`, and `src/**/tests/**/*`: match all `.py` and `.pyi` files in `src/`
  under a directory named `tests`

### Module Globbing

In some config options, we've added globbing for module paths. This is different from both path globs and regex,
in the sense that we're performing a match on a Python dotted import, such as `this.is.any.module`.
The only wildcard we recognize is `*`, which represents zero or more segments of a module path, unless it starts a glob,
in which case it must match one or more segments. The wildcard must be surrounded
by `.`, unless it is at the start or end of a module glob.

Examples:

- `this.is.a.module` would be equivalent to a regex like `^this\.is\.a\.module`. It will only match imports that look like
  `this.is.a.module`.
- `this.is.*.module` would become `^this\.is(\..+)*\.module$`. It would match:
    - `this.is.module`
    - `this.is.a.module`
    - `this.is.a.really.long.path.to.a.module`
- `*.my.module` would be equivalent to a regex like `^.+\.my\.module$`.
    - It would match:
        - `this.is.my.module`
        - `heres.my.module`
    - It will not match:
        - `my.module`
- `this.is.*` would be equivalent to a regex like `^this\.is(\..+)*`. It would match:
    - `this.is.my.module`
    - `this.is`

### `Sub-Configs`

`Sub-Configs` are a method for overriding one or more config options for specific files based on
filepath glob matching. Only certain config options are allowed to be overridden, and a need
to override other configs means you likely need to use a separate config file for your subdirectory.
You can have as many SubConfigs as you want in a project, and even multiple separate SubConfigs
that can apply to a given file when the `matches` glob pattern matches.

#### **SubConfig Allowed Overrides**

We currently allow the following config options to be overridden in a SubConfig:

- `errors`
- `replace-imports-with-any`
- `untyped-def-behavior`
- `ignore-errors-in-generated-code`

All SubConfig overrides _replace_ the values appearing in the 'root' or top-level of the
Pyrefly configuration.

Any configs that change the list of files we're type checking, Python environment, or where we look
for imports cannot be included in SubConfigs. Some other configs we also do not include because
we think they make it difficult to reason about your project type checks, but you can
[open an issue](https://github.com/facebook/pyrefly/issues) or make a pull request if you disagree
and would like to see the option supported.

#### **SubConfig Table Structure**

A SubConfig has two or more entries:

- a `matches` key, with a [Filesystem Glob](#filesystem-globbing) detailing which files the config
  applies to.
- at least one of the [SubConfig allowed overrides](#subconfig-allowed-overrides)

#### **SubConfig Option Selection**

Since you can have more than one SubConfig matching a file, we need to define a resolution order
to determine which SubConfig's option should be selected. Pyrefly does this by filtering
SubConfigs whose `matches` does not match the given file, then takes the first non-null
value that can be found in the order the SubConfigs appear in your configuration.

If no SubConfigs match, or there are no non-null config options present, then we take
the value in the 'root'/top-level Pyrefly config (or Pyrefly default if no value is specified).

#### **SubConfig Example**

For the following config, this how options would be resolved.

```toml
replace-imports-with-any = [
  "sympy.*",
  "*.series",
]
ignore-errors-in-generated-code = true

# disable `bad-assignment` and `invalid-argument` for the whole project
[errors]
bad-assignment = false
invalid-argument = false

[[sub-config]]
# apply this to `sub/project/tests/file.py`
matches = "sub/project/tests/file.py"

# any unittest imports will by typed as `typing.Any`
replace-imports-with-any = ["unittest.*"]

[[sub-config]]
# apply this config to all files in `sub/project`
matches = "sub/project/**"

# enable `assert-type` errors in `sub/project`
[sub-config.errors]
assert-type = true

[[sub-config]]
# apply this config to all files in `sub`
matches = "sub/**`

# disable `assert-type` errors in `sub`
[sub-config.errors]
assert-type = false

[[sub-config]]
# apply this config to all files under `tests` dirs in `sub/`
matches = "sub/**/tests/**"

# any pytest imports will be typed as `typing.Any`
replace-imports-with-any = ["pytest.*"]
```

- `sub/project/tests/file.py`
    - `replace-imports-with-any`: `["unittest.*"]`
    - `errors`: `{assert-type = true}`
    - `ignore-errors-in-generated-code`: `true`
- `sub/project/tests/another_file.py`
    - `replace-imports-with-any`: `["pytest.*"]`
    - `errors`: `{assert-type = true}`
    - `ignore-errors-in-generated-code`: `true`
- `sub/project/non_test_file.py`
    - `replace-imports-with-any`: `["sympy.*", "*.series"]`
    - `errors`: `{assert-type = true}`
    - `ignore-errors-in-generated-code`: `true`
- `sub/sub_file.py`
    - `replace-imports-with-any`: `["sympy.*", "*.series"]`
    - `errors`: `{assert-type = false}`
    - `ignore-errors-in-generated-code`: `true`
- `top_level_file.py`
    - `replace-imports-with-any`: `["sympy.*", "*.series"]`
    - `errors`: `{assert-type = true, bad-assignment = false, invalid-argument = false}`
    - `ignore-errors-in-generated-code`: `true`

### Conda and Venv Support

We plan on adding extra automatic support for [Conda](https://github.com/facebook/pyrefly/issues/2)
and [Venv](https://github.com/facebook/pyrefly/issues/1) at some point soon, but we haven't made
it around to doing this yet. If you would like to import packages from these in the meantime,
you can follow the following steps.

### Venv

If you have a venv set up locally, you can get Pyrefly working with it by having your venv sourced
in your shell (`source .venv/bin/activate`), and we will automatically pick up your installed packages. To pick
up your packages even when your environment isn't sourced, you can add `.venv/bin/python3` (or
`<path_to_venv>/bin/python3`) to your Pyrefly configuration under
[`python-interpreter-path`](#python-interpreter-path) or pass it in with the `--python-interpreter-path` flag.

### Conda

If you have conda set up locally, you can get Pyrefly working with it by having your Conda environment
sourced in your shell (`conda activate <environment>`), and we will automatically pick up your installed packages.
To pick up your packages even when your environment isn't sourced, you can query your environment's install
location with `conda env list`, and add `<conda_environment_path>/bin/python3` to your Pyrefly configuration
under [`python-interpreter-path`](#python-interpreter-path) or pass it in with the `--python-interpreter-path` flag.

## Example Configurations

This section displays an example config showing the usage of all config options listed above to make creating
your own easier, and to give you an easy place to start.

### Default `pyrefly.toml`

This is a configuration with the Pyrefly defaults. If you have an
interpreter installed, some of these values may be overridden.

```toml
###### configuring what to type check and where to import from

# check all Python files under the containing directory
project-includes = ["**/*.py*"]
# exclude some uninteresting files
project-excludes = ["**/node_modules", "**/__pycache__", "**/*venv/**", "**/.[!/.]*/**"]
# perform an upward search for `.gitignore`, `.ignore`, and `.git/info/exclude`, and
# add those to `project-excludes` automatically
use-ignore-files = true
# import project files from "."
search-path = ["."]
# let Pyrefly try to guess your search path
disable-search-path-heuristics = false
# do not include any third-party packages (except those provided by an interpreter)
site-package-path = []

###### configuring your python environment

# assume we're running on linux, regardless of the actual current platform
python-platform = "linux"
# assume the Python version we're using is 3.13, without querying an interpreter
python-version = "3.13"
# is Pyrefly disallowed from querying for an interpreter to automatically determine your
# `python-platform`, `python-version`, and extra entries to `site-package-path`?
skip-interpreter-query = false
# query the default Python interpreter on your system, if installed and `python_platform`,
# `python-version`, or `site-package-path` are unset.
# python-interpreter-path = null # this is commented out because there are no `null` values in TOML

#### configuring your type check settings

# wildcards for which Pyrefly will unconditionally replace the import with `typing.Any`
replace-imports-with-any = []
# wildcards for which Pyrefly will replace the import with `typing.Any` if it can't be found
ignore-missing-imports = []
# should Pyrefly skip type checking if we find a generated file?
ignore-errors-in-generated-code = false
# what should Pyrefly do when it encounters a function that is untyped?
untyped-def-behavior = "check-and-infer-return-type"
# can Pyrefly recognize ignore directives other than `# pyrefly: ignore` and `# type: ignore`
permissive-ignores = false

[errors]
# this is an empty table, meaning all errors are enabled by default

# no `[[sub-config]]` entries are included, since there are none by default
```

### Example `pyrefly.toml`

```toml
project-includes = ["src"]
project-excludes = ["**/.[!/.]*", "**/tests"]
search-path = ["src"]
site-package-path = ["venv/lib/python3.12/site-packages"]

python-platform = "linux"
python-version = "3.12"
python-interpreter-path = "venv/bin/python3"

replace-imports-with-any = [
  "sympy.*",
  "*.series",
]
ignore-errors-in-generated-code = true

# disable `bad-assignment` and `invalid-argument` for the whole project
[errors]
bad-assignment = false
invalid-argument = false

[[sub-config]]
# apply this to `sub/project/tests/file.py`
matches = "sub/project/tests/file.py"

# any unittest imports will by typed as `typing.Any`
replace-imports-with-any = ["unittest.*"]

[[sub-config]]
# apply this config to all files in `sub/project`
matches = "sub/project/**"

# enable `assert-type` errors in `sub/project`
[sub-config.errors]
assert-type = true
```

### Example `pyproject.toml`

```toml
...

# Pyrefly header
[tool.pyrefly]

#### configuring what to type check and where to import from
project-includes = ["src"]
project-excludes = ["**/.[!/.]*", "**/tests"]
search-path = ["src"]
site-package-path = ["venv/lib/python3.12/site-packages"]

#### configuring your python environment
python-platform = "linux"
python-version = "3.12"
python-interpreter-path = "venv/bin/python3"

#### configuring your type check settings
replace-imports-with-any = [
  "sympy.*",
  "*.series",
]

ignore-errors-in-generated-code = true

[tool.pyrefly.errors]
bad-assignment = false
invalid-argument = false

[[tool.pyrefly.sub-config]]
# apply this config to all files in `sub/project`
matches = "sub/project/**"

# enable `assert-type` errors in `sub/project`
[tool.pyrefly.sub-config.errors]
assert-type = true

[[tool.pyrefly.sub-config]]
# apply this config to all files in `sub`
matches = "sub/**`

# disable `assert-type` errors in `sub/project`
[tool.pyrefly.sub-config.errors]
assert-type = false

# other non-Pyrefly configs
...
```

## Exit Codes

| Code | Meaning |
|------|---------|
| 0    | Success - command completed without issues |
| 1    | User error - command completed but problems (e.g., type errors) were found |
| 3    | Infrastructure error - an error in the environment prevented the command from completing |
| 101  | Panic - Pyrefly encountered an internal error and crashed |


---

---
title: Experimental Django Support
description: Pyrefly experimental support for Django ORM.
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

# Experimental Django Support

Pyrefly includes **experimental support** for [Django](https://www.djangoproject.com/), a popular Python web framework. This feature aims to provide improved static type checking for Django's Object-Relational Mapping (ORM) system, which is used to interact with databases.

> **Note:** This support is experimental and currently covers a subset of Django's ORM features. The implementation is actively evolving based on feedback and development. We currently support Django models, fields, and basic relationships.

### Feedback

We welcome your feedback and suggestions. Please share your thoughts and ideas by opening an issue on [GitHub](https://github.com/facebook/pyrefly/issues).

---

## What is Django?

Django is a high-level Python web framework. One of its core components is the Object-Relational Mapping (ORM) system, which allows developers to interact with databases using Python classes (models) instead of writing SQL queries directly.

Django models define the structure of your database tables, and Django automatically handles the creation and management of the underlying database schema.

---

## Getting Started with Django and Pyrefly

To use Pyrefly with Django, follow these steps:

### 1. Install django-stubs and set up a virtual environment

```bash
# Install django-stubs
pip install django-stubs

# Create and activate a virtual environment
python3 -m venv .venv
source .venv/bin/activate
```

### 2. Install pyrefly (version 0.42.0 or later)

```bash
pip install pyrefly
```

That's it! Pyrefly will automatically recognize Django constructs and provide appropriate type checking.

---

## How Pyrefly Supports Django

Pyrefly provides type inference for Django's ORM without requiring any plugins or manual configuration. It:

- Recognizes Django model classes that inherit from `models.Model`
- Understands Django field types (`CharField`, `IntegerField`, `ForeignKey`, etc.)
- Infers types for auto-generated fields (like `id` and `pk`)
- Handles relationships between models (`ForeignKey`, `ManyToManyField`)
- Provides special enum support
- Provides immediate feedback when the code has type errors
- Does **not** require a plugin or manual config — support is built-in and automatic

---

## Supported Features with Examples

The following examples showcase which Django features are currently supported by Pyrefly. This is a subset of Django's full feature set, but covers the most common use cases.

### Auto-Generated Fields

Django automatically adds certain fields to every model, even if you don't define them explicitly.

#### Primary Key: `id` Field

By default, Django automatically adds an `id` field to serve as the primary key (unless you define a custom primary key):

```python
from django.db import models

class Reporter(models.Model):
    full_name = models.CharField(max_length=70)
    # Django auto-adds: id = models.AutoField(primary_key=True)

reporter = Reporter()
reveal_type(reporter.id)  # Pyrefly infers: int
```

#### Custom Primary Keys

If you define a field with `primary_key=True`, Django will not add the `id` field. Pyrefly correctly infers the type of custom primary keys:

```python
from django.db import models

class Reporter(models.Model):
    uuid = models.UUIDField(primary_key=True)
    full_name = models.CharField(max_length=70)

reporter = Reporter()
reveal_type(reporter.uuid)  # Pyrefly infers: UUID
reveal_type(reporter.pk)  # Pyrefly infers: UUID (pk aliases the custom primary key)
```

#### ForeignKey `_id` Suffix Fields

For every `ForeignKey` field named `X`, Django automatically creates a field named `X_id` that stores the ID of the related object:

```python
class Article(models.Model):
    reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE)
    # Django auto-adds: reporter_id: int

article = Article()
reveal_type(article.reporter_id)  # Pyrefly infers: int
```

### ForeignKey Relationships

A `ForeignKey` creates a many-to-one relationship where each instance of one model relates to an instance of another model.

```python
from django.db import models

class Reporter(models.Model):
    full_name = models.CharField(max_length=70)

class Article(models.Model):
    reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE)
```

#### Basic Forward Access

Accessing a `ForeignKey` field returns an instance of the related model:

```python
article = Article()
reveal_type(article.reporter)  # Pyrefly infers: Reporter
```

#### Chained Access

You can access fields on the related model:

```python
reveal_type(article.reporter.full_name)  # Pyrefly infers: str
```

#### Nullable ForeignKeys

If a `ForeignKey` has `null=True`, Pyrefly reflects this in the inferred type:

```python
class Article(models.Model):
    reporter = models.ForeignKey(Reporter, null=True, on_delete=models.CASCADE)

article = Article()
reveal_type(article.reporter)  # Pyrefly infers: Reporter | None
```

### ManyToManyField Relationships

A `ManyToManyField` creates a many-to-many relationship where instances of one model can be related to multiple instances of another model.

```python
class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=200)
    authors = models.ManyToManyField(Author, related_name='books')
```

#### Forward Managers

Accessing a `ManyToManyField` returns a manager object that provides methods to interact with the related objects:

```python
book = Book()
reveal_type(book.authors)  # Pyrefly infers: ManyRelatedManager[Author, Model]
reveal_type(book.authors.all())  # Pyrefly infers: QuerySet[Author, Author]
```

The manager provides methods like `.add()`, `.remove()`, `.clear()`, and `.all()` to manage the relationship.

---

### Django Model Enums

Pyrefly supports Django's model choices using `Choices`, `IntegerChoices`, and `TextChoices`. These provide type-safe enumerations for model fields.

```python
from django.db import models

class Vehicle(models.IntegerChoices):
    CAR = 1, "Car"
    TRUCK = 2, "Truck"
    MOTORCYCLE = 3, "Motorcycle"

class Product(models.Model):
    vehicle_type = models.IntegerField(choices=Vehicle.choices)

# Pyrefly correctly infers enum types
reveal_type(Vehicle.CAR.value)  # Pyrefly infers: int
reveal_type(Vehicle.CAR.label)  # Pyrefly infers: str
reveal_type(Vehicle.values)  # Pyrefly infers: list[int]
reveal_type(Vehicle.choices)  # Pyrefly infers: list[tuple[int, str]]
```

Pyrefly also supports `TextChoices` and the base `Choices` class with various value types including `enum.auto()` for automatic value generation.

---

## Differences from Mypy

Mypy uses a plugin (`mypy-django-plugin`) that provides very detailed type information by accessing runtime Django internals and performing multiple passes over the code. Pyrefly takes a different approach by following the type stubs directly without runtime introspection.

### Type Representation Differences

In some cases, such as `ManyToManyField` relationships, Mypy and Pyrefly infer different types:

**Example:**

```python
from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=200)
    authors = models.ManyToManyField(Author, related_name="books")

class Article(models.Model):
    headline = models.CharField(max_length=200)
    authors = models.ManyToManyField(Author, related_name="articles")

# What types do the managers have?
book = Book()
article = Article()
```

Mypy (with django plugin):
- `book.authors` has type: `Author_ManyRelatedManager[Book_authors]`
- `article.authors` has type: `Author_ManyRelatedManager[Article_authors]`
- These are **different types** (different class name, different type parameter)
- Mypy will **reject** assigning one to the other

Pyrefly (following stubs):
- `book.authors` has type: `ManyRelatedManager[Author, Model]`
- `article.authors` has type: `ManyRelatedManager[Author, Model]`
- These are the **same type**
- Pyrefly will **accept** assigning one to the other

---

## Features Not Yet Supported

These are some of the Django features are **not yet supported** in this experimental release:

### Reverse Relationships

Django automatically creates reverse relationships for `ForeignKey` and `ManyToManyField`. For example:

```python
class Reporter(models.Model):
    full_name = models.CharField(max_length=70)

class Article(models.Model):
    reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE)

# Not yet supported:
reporter = Reporter()
reveal_type(reporter.article_set)  # Expected: RelatedManager[Article]
```

### Advanced QuerySet Operations

While basic `.all()` operations are supported, more complex QuerySet operations may not have complete type inference.

Those are not the only unsupported features, so if there are specific features you would like to see, please request them by opening a github issue and adding the Django label to it.


---

---
title: Pyrefly Error Kinds

description: Pyrefly error categories and suppression codes
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

# Pyrefly Error Kinds

An _error kind_ categorizes an error by the part of the typing specification
that an error is related to. Every error has exactly one kind.

The main use of error kinds is as short names ("slugs") that can be used in
error suppression comments.

Diagnostics have several possible severity levels, which can be [configured](../configuration#errors) in `pyrefly.toml` or via CLI:
- ignore: the diagnostic is not emitted and does not cause a nonzero exit in the CLI
- info: the diagnostic shows up blue in the IDE and does not cause a nonzero exit in the CLI
- warn: the diagnostic shows up yellow in the IDE and causes a nonzero exit in the CLI
- error: the diagnostic shows up red in the IDE and causes a nonzero exit in the CLI

The default severity for diagnostics is `error` unless otherwise noted. Diagnostics with default severity `ignore` must be explicitly enabled to be emitted.

## abstract-method-call

This error is raised when code attempts to invoke a method decorated with
`@abstractmethod`. Abstract methods have no implementation, so calling them is
always invalid, even if the signature would otherwise match.

```python
from abc import ABC, abstractmethod

class Base(ABC):
    @classmethod
    @abstractmethod
    def build(cls) -> "Base": ...

Base.build()
# Cannot call abstract method `Base.build` [abstract-method-call]
```

## annotation-mismatch

This error indicates a mismatch between multiple annotations for a single
variable. This is relatively uncommon, but it can happen in if-statements:

```python
if some_cond:
    x: int = 1
else:
    x: str = "two" # Inconsistent type annotations for x: str, int [annotation-mismatch]
```

It can be helpful to annotate the variable before branch, especially if there is
a useful default value for it. For example:

```python
x: str = "default"
if some_cond:
  x = "actual value"
```

## assert-type

An `assert-type` error is raised when a `typing.assert_type()` call fails.

This error kind should never be suppressed, since that rather defeats the point
of of `typing.assert_type()`.

## bad-argument-count

This error arises when a function is called with the wrong number of arguments.

```python
def takes_three(one: int, two: int, three: int) -> complex:
  ...

take_three(3, 2)  # Expected 1 more positional argument [bad-argument-count]
```

Note that `missing-argument` will be raised if pyrefly can identify that
specific arguments are missing. As such, this error is more likely to appear
when too many args are supplied, rather than too few.

This example shows both kinds of errors:

```python
from typing import Callable
def apply(f: Callable[[int, int], int]) -> int:
    return f(1)  # Expected 1 more positional argument [bad-argument-count]
apply() # Missing argument `f` in function `apply` [missing-argument]
```

## bad-argument-type

This error indicates that the function was called with an argument of the wrong
type.

```python
def example(x: int) -> None:
  ...
example("one")  # Argument `Literal['two']` is not assignable to parameter `x` with type `int` in function `example` [bad-argument-type]
```

This can also happen with `*args` and `**kwargs`:

```python
def bad_args(*args: int) -> None:
  ...

bad_args(1, "two")  # Argument `Literal['two']` is not assignable to parameter with type `int` in function `bad_args` [bad-argument-type]
```

```python
def bad_kwargs(**kwargs: int) -> None:
  ...

bad_args(x=1, y="two")  # Keyword argument `y` with type `Literal['two']` is not assignable to kwargs type `int` in function `bad_kwargs` [bad-argument-type]
```

## bad-assignment

The most common cause of this error is attempting to assign a value that conflicts with the variable's type annotation.

```python
x: str = 1 # `Literal[1]` is not assignable to `str` [bad-assignment]
```

However, it can occur in several other situations.

Here, `x` is marked as `Final`, so assigning a new value to it is an error.

```python
from typing import Final
x: Final = 1
x = 2 # `x` is marked final [bad-assignment]
```

In another case, attempting to annotate an assignment to an instance attribute raises this error.

```python
class A:
    x: int
a = A()
a.x: int = 2  # Type cannot be declared in assignment to non-self attribute `a.x` [bad-assignment]
```

## bad-class-definition

This error indicates that there is something wrong with the class definition.
It tends to be a bit rarer, since most issues would be tagged with other error kinds, such as
`annotation-mismatch` or one of the function errors.
inheritance has its own complexities, so it has its own error kind called `invalid-inheritance`.

One place you may see it is dynamic class generation:

```python
from enum import Enum
Ex = Enum("Ex", [("Red", 1), ("Blue", 2), ("Red", 3)])  # Duplicate field `Red` [bad-class-definition]
```

However, it is best practice to use the class syntax if possible, which doesn't treat duplicate names as an error.

## bad-context-manager

This error occurs when a type that cannot be used as a context manager appears in a `with` statement.

```python
class A:
    def __enter__(self): ...
with A(): ...  # `A` is missing an `__exit__` method!
```

## bad-dunder-all

This error occurs when `__all__` is explicitly defined for a module but contains an entry that cannot be found in the module's definitions, wildcard imports, or submodules (for `__init__.py` files).

```python
__all__ = ["x", "y"]  # Name `y` is listed in `__all__` but is not defined in the module
x = 5
```

To fix this error, either define the missing name or remove it from `__all__`:

```python
__all__ = ["x", "y"]
x = 5
y = 10  # Now `y` is defined
```

## bad-function-definition

Like `bad-class-definition`, this error kind is uncommon because other error kinds are used for more specific issues.
For example, argument order is enforced by the parser, so `def f(x: int = 1, y: str)` is a `parse-error`.

## bad-index

Attempting to access a container with an incorrect index.
This only occurs when Pyrefly can statically verify that the index is incorrect, such as with a fixed-length tuple.

```python
def add_three(x: tuple[int, int]) -> int:
  return x[0] + x[1] + x[2]
```

Pyrefly also knows the keys of `TypedDict`s, but those have their own error kind.

## bad-instantiation

This error occurs when attempting to instantiate a class that cannot be instantiated, such as a protocol:

```python
from typing import Protocol
class C(Protocol): ...
C()  # bad-instantiation
```

## bad-keyword-argument

bad-keyword-argument pops up when a keyword argument is given multiple values:

```python
def f(x: int) -> None:
  pass
f(x=1, x=2)
```

However, this is often accompanied by a `parse-error` for the same issue.

## bad-match

This error is used in two cases.

The first is when there is an issue with a `match` statement. For example, `Ex` only has 2 fields but the `case` lists 3:

```python
class Ex:
  __match_args__ = ('a', 'b')
  def __init__(self, a: int, b: str) -> None:
    self.a = a
    self.b = b

def do(x: Ex) -> None:
  match x:
    case Ex(a, b, c):
      print("This is an error")
```

It is also used when `__match_args__` is defined incorrectly. It must be a tuple of the names of the class's attributes as literal strings.
For class `Ex` in the previous example, `__match_args__ = ('a', 'c')` would be an error because `Ex.c` does not exist.

## bad-override

When a subclass overrides a field or method of its base class, care must be taken that the override won't cause problems.

Some of these are obvious:

```python
class Base:
  def f(self, a: int) -> None:
    pass

class NoArg(Base):
  def f(self) -> None:
    pass

class WrongType(Base):
  def f(self, a: str) -> None:
    pass

def uses_f(b: Base) -> None:
  b.f(1)
```

These errors are rather obvious: `uses_f` will fail if given a `NoArg` or `WrongType` instance, because those methods don't expect an `int` argument!

The guiding idea here is the [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle), the idea that a subclass can stand in for a base class at any point without breaking the program.

This can be a little subtle at first blush. Consider:

```python
class Base:
  def f(self, a: int) -> None:
    pass

class Sub(Base):
  def f(self, a: float) -> None:
    pass
```

Is this OK? Yes! `int` is treated as a subclass of `float`, or to put it another way, a function that accepts `float` can accept every `int`.
That means everywhere that we call `Base.f` can safely call `Sub.f`.

The opposite case, where `Base.f` takes `float` and `Sub.f` takes `int`, is an error because `Sub.f` cannot accept every `float` value.

Note that bad overrides caused by inconsistent parameter names are separately reported as [bad-param-name-override](#bad-param-name-override).

## bad-param-name-override

Arises when a subclass overrides a method of its base class while changing the name of a positional parameter.
This is a type of [bad override](#bad-override) but has a separate error kind so that it can be selectively disabled if desired.
Changing the name of a parameter breaks callers that pass in an argument by name:

```python
class Base:
  def f(self, a: int) -> None:
    pass

class Sub(Base):
  def f(self, b: int) -> None:
    pass

def f(base: Base):
  base.f(a=0)

f(Sub())  # oops!
```

## bad-raise

In a `raise` statement of the form `raise x from y`, `x` must be an exception, and `y` must be an exception or `None`.

```python
def bad_raise() -> None:
  raise Exception()  # ok
  raise 1  # error
  raise Exception() from None # ok
  raise Exception() from Exception() # ok
  raise Exception() from 1 # error
```

## bad-return

Arises when a function does not return a value that is compatible with the function's return type annotation.

```python
def bad_return() -> None:
  return 1
```

Real-world examples are often less obvious, of course, due to complex control flow and type relationships.

This error is also raised for generator functions:

```python
from typing import Generator
# Generator has 3 types: the yield, send, and return types.
def bad_gen() -> Generator[int, None, str]:
  yield 1
  return 2  # should be a str!
```

## bad-specialization

"Specialization" refers to instantiating a generic type with a concrete type.
For example, `list` is a generic type, and `list[int]` is that type specialized with `int`.

Each generic type has an expected number of type vars, and each type var can be bound or constrained.
Attempting to use specialize a generic type in a way that violates these specifications will result in a `bad-specialization` error:

```python
x: list[int, str]
```

## bad-typed-dict

This error is reported when a `TypedDict` definition includes an unsupported keyword argument.
According to the typing specification, the only keyword argument allowed in a `TypedDict`'s
base class list is `total`.

```python
from typing import TypedDict

# This is an error because `foo` is not a valid keyword.
class InvalidTD(TypedDict, foo=1):
    x: int

# This is valid.
class ValidTD(TypedDict, total=False):
    x: int
```

## bad-typed-dict-key

This error arises when `TypedDict`s are used with incorrect keys, such as a key that does not exist in the `TypedDict`.

```python
from typing import TypedDict

class Ex(TypedDict):
    a: int
    b: str

def test(x: Ex) -> None:
    # These two keys don't exist
    x.nope
    x["wrong"]
    # TypedDict keys must be strings!
    x[1]
```

## bad-unpacking

An error caused by unpacking, such as attempting to unpack a list, tuple, or iterable into the wrong number of variables.

```python
def two_elems() -> tuple[int, str]:
  return (1, "two")

a, b, c = two_elems()
```

Note that pyrefly can only report this error if it knows how many elements the thing being unpacked has.

```python
# A bare `tuple` could have any number of elements
def two_elems() -> tuple:
  return (1, "two")

a, b, c = two_elems()
```

## deprecated

This warning occurs on usage of a deprecated class or function.

The default severity of this diagnostic is `warn`.

```python
from warnings import deprecated
@deprecated("deprecated")
def f(): ...
f()  # deprecated!
```

## implicit-abstract-class

Pyrefly emits this error when a class defines abstract members but is not declared abstract (for example, it does not inherit from `abc.ABC` or use `abc.ABCMeta`). Such classes cannot be instantiated because they have unimplemented abstract methods. Add `ABC` as a base class, adjust the metaclass, or provide concrete implementations to resolve the issue.

The default severity of this diagnostic is `ignore`.

## implicit-any

This error is emitted when Pyrefly infers an implicit `Any` type in your code for type variables or generic parameters that cannot be determined. This is common in gradually-typed code, but reduces type safety so we provide this error for users that want to enforce fully-typed codebases.

Typically, it can be fixed by providing explicit type arguments or default values for type variables.

The default severity of this diagnostic is `ignore`.

```python
# this only errors when first-use inference is disabled
x = []  # error: infers list[Any]
```

## implicit-import

A module exists, but was not imported. At runtime, if something has made this import
before your code, it will work. But relies on whatever did the import to continue doing it.

```python
import importlib
importlib.util.find_spec("os")  # error, `importlib.util` was not imported
```

## implicitly-defined-attribute

An attribute was implicitly defined by assignment to `self` in a method that we
do not recognize as always executing. We recognize constructors and some test
setup methods; we will emit an error for any attributes defined by assignment
in other methods.

The default severity of this diagnostic is `ignore`.

```python
class C:
    def __init__(self):
        self.x = 0  # no error, `__init__` always executes
    def f(self):
        self.y = 0  # error, `y` may be undefined if `f` does not execute
```

## inconsistent-inheritance

When a class inherits from multiple base classes, the inherited fields must be consistent.

Example:
```python
class A:
    f: str
class B:
    f: int
class C(A, B): ...  # error, the field `f` is inconsistent
```

## inconsistent-overload

The signature of a function overload is inconsistent with the implementation.
See the [typing specification](https://typing.python.org/en/latest/spec/overload.html#implementation-consistency)
for details on the consistency checks Pyrefly performs.

Example:
```python
from typing import overload
@overload
def f(x: int) -> int: ...
@overload
def f(x: str) -> str: ...  # error, overload accepts `str` but implementation only accepts `int`
def f(x: int) -> int | str:
    return x
```

## internal-error

Ideally you'll never see this one. If you do, please consider [filing a bug](https://github.com/facebook/pyrefly/issues).

## invalid-annotation

There are several reasons why an annotation may be invalid. The most common case is misusing a typing special form, such as `typing.Final`, `typing.ClassVar`, `typing.ParamSpec`, and so on.

```python
from typing import *

# Final must have a value
a: Final
# ClassVar can only be used in a class body
b: ClassVar[int] = 1
```

The error messages will explain how the special form is being misused. Consult the [typing docs](https://docs.python.org/3/library/typing.html) and [typing spec](https://typing.python.org/en/latest/spec/) for more information.

## invalid-argument

This error is used to indicate an issue with an argument to special typing-related functions.

For example, `typing.NewType` is a handy special form for creating types that are distinct from a base type.


```python
from typing import *

# The first arg must match the name!
Mismatch = NewType("Wrong Name", int)

# NewTypes cannot be used in isinstance.
UserId = NewType("UserId", int)
if isinstance(1, UserId):
  ...
```

## invalid-decorator

This error indicates that a decorator was used incorrectly. For example, using `@typing.final` on a non-method function.

```python
from typing import final
@final
def f() -> None:
  pass
```

## invalid-inheritance

An error caused by incorrect inheritance in a class or type definition.
This can pop up in quite a few cases:
- Trying to subclass something that isn't a class.
- Subclassing a type that does not support it, such as a `NewType` or a `Final` class.
- Attempting to mix `Protocol`s with non-`Protocol` base classes.
- Trying to make a generic enum.
- Trying to give a `TypedDict` a metaclass.

And so on!

## invalid-literal

`typing.Literal` only allows a [limited set](https://typing.python.org/en/latest/spec/literal.html#legal-parameters-for-literal-at-type-check-time) of types as parameters.
Attempting to use `Literal` with anything else is an error.

```python
from typing import Literal

# These are legal
Literal[1.0]
Literal['a', 'b', 'c']
# This is not
class A:
  ...
Literal[A()]
```

## invalid-overload

The `@overload` decorator requires that the decorated function has at least two overloaded signatures and a base implementation.

```python
from typing import *

@overload
def no_base(x: int) -> None:
  pass

@overload
def no_base(x: str) -> int:
  pass
```

```python
@overload
def just_one(x: int) -> None:
  pass

def just_one(x: str) -> None:
  ...
```

## invalid-param-spec

This error is reported when `typing.ParamSpec` is defined incorrectly or misused. For example:

```python
from typing import *

P = ParamSpec("Name Must Match!")

P1 = ParamSpec("P1")
P2 = ParamSpec("P2")

def f(x, *args: P1.args, **kwargs: P2.kwargs) -> None:
  pass
```

Here, `P1.args` and `P2.kwargs` can't be used together; `*args` and `**kwargs` must come from the same `ParamSpec`.

## invalid-pattern

This error is reported when a pattern is invalid at runtime. For example, enum members are values,
so they must be matched as value patterns (without `()`), not class patterns:

```python
from enum import Enum

class Color(Enum):
  RED = "red"

def describe(color: Color) -> None:
  match color:
    case Color.RED():  # Invalid pattern: use `Color.RED` (without parentheses)
      pass
```

## invalid-self-type

This error occurs when `Self` is used in a context Pyrefly does not currently support.

For example, Pyrefly does not currently allow `Self` for `TypedDict`, so the
following code would error:
```python
from typing import *

class TD(TypedDict):
    x: Option[Self]
```

## invalid-super-call

`super()` has [a few restrictions](https://docs.python.org/3/library/functions.html#super) on how it is called.

`super()` can be called without arguments, but only when used inside a method of a class:

```python
class Legal(Base1, Base2):
  def f(self) -> None:
    super().f()

def illegal(arg: SomeType) -> None:
  super().f()
```

When the function is called with two arguments, like `super(T, x)`, then `T` must be a type, and the second argument is either an object where `isinstance(x, T)` is true
or a type where `issubclass(x, T)` is true.

## invalid-syntax

This error covers syntactical edge cases that are not flagged by the parser.

For example:

```python
x: list[int] = [0, 2, 3]
x[0]: int = 1
```

It's not a parse error for an assignment to have an annotation, but it is forbidden by the type checker to annotate assignment to a subscript like `x[0]`.

## invalid-type-alias

An error related to the definition or usage of a `typing.TypeAlias`. Many of these cases are covered by [`invalid-annotation`](#invalid-annotation), so this error
specifically handles illegal type alias values:

```python
from typing import TypeAlias
x = 2
Bad: TypeAlias = x
```

## invalid-type-var

An error caused by incorrect usage or definition of a TypeVar. A few examples:

```python
from typing import TypeVar
# Old-style TypeVars must be assigned to a matching variable.
Wrong = TypeVar("Name")

# PEP 695-style TypeVars can be constrained, but there must be at least two:
def only_one_constraint[T: (int,)](x: T) -> T:
  ...

# It's also illegal to mix the two styles together.
T = TypeVar("T")
def mixed[S](a: S, b: T) -> None:
  ...
```

## invalid-type-var-tuple

An error caused by incorrect usage or definition of a TypeVarTuple.

TypeVarTuple has similar error cases to [TypeVar](#invalid-type-var), but also a few of its own. For example:

```python
from typing import TypeVarTuple

Ts = TypeVarTuple("Ts")

# TypeVarTuples must always be unpacked:
bad: tuple[Ts] = (...)
good: tuple[*Ts] = (...)

# Only one TypeVarTuple is allowed in a list of type arguments:
def two_tups[*Xs, *Ys](xs: tuple[*Xs], ys: tuple[*Ys]) -> None:
  ...
```

## invalid-variance

An error caused by a type variable being used in a position incompatible with its declared variance.

For example, a covariant type variable cannot be used in a contravariant position (such as a method parameter), and a contravariant type variable cannot be used in a covariant position (such as a return type).

```python
from typing import TypeVar, Generic

T_co = TypeVar("T_co", covariant=True)
T_contra = TypeVar("T_contra", contravariant=True)

class BadCovariant(Generic[T_co]):
    # Error: covariant type variable used in contravariant position
    def set_value(self, value: T_co) -> None: ...

class BadContravariant(Generic[T_contra]):
    # Error: contravariant type variable used in covariant position
    def get_value(self) -> T_contra: ...
```

## invalid-yield

This error arises when `yield` is used in a way that is not allowed. For example:

```python
from typing import Generator

for _ in range(1, 10):
  yield "can't yield outside of a function!"

def bad_yield_from() -> Generator[int, None, None]:
  # `yield from` can only be used with iterables.
  yield from 1
```

## missing-argument

An error caused by calling a function without all the required arguments.

```python
def takes_two(x: int, y: int) -> int:
  return x + y

takes_two(1)
```

## missing-attribute

This error is raised when attempting to access an attribute that does not exist on the given object or module.

In the case of modules, attempting to import an nonexistent name will raise [`missing-module-attribute](#missing-module-attribute) instead.

```python
import os
from os import bacarat  # missing-module-attribute
os.jongleur()  # missing-attribute
```

Note that objects with type `Any` will never raise this error.

## missing-import

A module could not be found.

The error message will include which paths were searched, such as the site package paths.
You may be missing a dependency, or you may need to inform Pyrefly where the module lives. See [Configuration](configuration.mdx) for further information.

## missing-module-attribute

Arises when attempting to import a name that does not exist from a module.

This is distinct from [`missing-import`](#missing-import), which is used when the module being imported does not exist, and [`missing-attribute`](#missing-attribute), when access attributes of the module.

```python
import this_does_not_exist  # missing-import
import os.bacarat  # missing-import
from os import joker  # missing-module-attribute
os.perkeo  # missing-attribute
```

In this example, `os.bacarat` is treated as a module name, so failing to find it results in an `missing-import`.
`from os import joker` does not tell us if `joker` is a module, class, function, etc., so it is treated as the more general `missing-module-attribute`.

## missing-override-decorator

A method overrides a parent class method but does not have the `@override` decorator.

This error supports strict override enforcement as specified in the [typing spec](https://typing.python.org/en/latest/spec/class-compat.html#strict-enforcement-per-project). When enabled, it requires all overriding methods to be explicitly marked with `@typing.override`.

```python
from typing import override

class Base:
    def foo(self) -> None: ...

class Derived(Base):
    def foo(self) -> None: ...  # missing-override-decorator

    @override
    def foo(self) -> None: ...  # OK
```

The default severity of this diagnostic is `ignore`. To enable strict override enforcement, set the severity to `error` in your configuration:

```toml
[tool.pyrefly]
errors = { missing-override-decorator = "error" }
```

## missing-source

Pyrefly was able to find a stubs package but no corresponding source package. For example, this can
happen if you install the `types-requests` package but forget to install `requests`.

The default severity of this diagnostic is `ignore`.

## missing-source-for-stubs

Pyrefly has bundled stubs for a package, but no corresponding source package was found.

## no-access

The `no-access` error indicates that an attribute exists, but it cannot be used in this way.

For example, classes do not have access to their instances' attributes:

```python
class Ex:
  def __init__(self) -> None:
    self.meaning: int = 42

del Ex.meaning  # no-access
```

## no-matching-overload

This error is similar to the other bad function call errors, but specifically for cases where a function decorated with `@overload` is called with arguments that do not match any of the overloaded variations.

For example, neither of the signatures of `f` can take an argument of type `float`:

```python
from typing import overload

@overload
def f(x: int) -> int:
    ...

@overload
def f(x: str) -> str:
    ...

def f(x: int | str) -> int | str:
    return x

f(1.0)
```

## non-exhaustive-match

Pyrefly warns when a `match` statement over an `Enum` attempts to enumerate the members
but forgets at least one case. Add the missing members or a default arm.

```python
from enum import Enum

class Color(Enum):
  RED = "red"
  BLUE = "blue"

def describe(color: Color) -> str:
  match color:  # non-exhaustive-match
    case Color.RED:
      return "danger"
```

## not-a-type

This indicates an attempt to use something that isn't a type where a type is expected.
In most cases, a more specific error kind is used.

You may see this error around incorrect type aliases:

```python
class A:
  ...
# Not an alias, just a string!
X = "A"
x: X = ...  # X is not a type alias, so this is illegal
```

## not-async

`not-async` is reported when attempting to `await` on something that is not
awaitable. This may indicate that a function should have been marked `async` but
wasn't.

```python
def some_func() -> None:
  ...

await some_func() # Expression is not awaitable [not-async]
```

This will also arise if the context manager used in an `async with` statement
has `__aenter__` and `__aexit__` methods that are not marked `async`.

The fix is to use an `async` function in the `await`. This may mean making the
function `async` or finding an existing `async` function to use instead.

## not-callable

A straightforward error: something that is not a function was used as if it were a function.

One interesting place this error may occur is with decorators:

```python
x = 1

@x  # not-callable
def foo() -> None:
  ...
```

## not-iterable

This is most likely to be seen in a `for` loop:

```python
x = 1  # Or some other value
for val in x:  # not-iterable
  ...
```

## not-required-key-access

This warning indicates that a [`TypedDict`](https://typing.python.org/en/latest/spec/typeddict.html)
key marked `NotRequired` (or inherited from a `total=False` TypedDict) is being accessed without
first ensuring that the key is present. Even if the value type is non-optional, the key itself may
not exist at runtime, so Pyrefly encourages guarding the access with an `in` check or a `.get()`
call.

The default severity of this diagnostic is `ignore`.

```python
from typing import NotRequired, TypedDict

class Movie(TypedDict):
    title: str
    year: NotRequired[int]

def describe(movie: Movie) -> int:
    return movie["year"]  # not-required-key-access

def safe_describe(movie: Movie) -> int:
    if "year" in movie:
        return movie["year"]  # OK: key presence established
    raise ValueError("Missing year")
```

## open-unpacking

This error is reported on an attempt to unpack an
[open](https://typing.python.org/en/latest/spec/glossary.html#term-open) TypedDict that potentially
has items incompatible with the TypedDict it is being unpacked into.

The default severity of this diagnostic is `ignore`.

Example:
```python
from typing import TypedDict

class OpenTypedDict(TypedDict):
    x: int

class UnpackingTarget(TypedDict):
    x: int
    y: str

def f(o: OpenTypedDict) -> UnpackingTarget:
    # Error: `o` could be an instance of a subclass of `OpenTypedDict` with an
    # item `y` with an incompatible type.
    return {"y": "", **o}
```

To fix this error, close the open TypedDict to indicate it does not contain any unknown items:
```python
class OpenTypedDict(TypedDict, closed=True): ...
```

Note: In Python versions before 3.15, import `TypedDict` from `typing_extensions` rather than
`typing` to use the `closed` feature.

## parse-error

An error related to parsing or syntax. This covers a variety of cases, such as function calls with duplicate keyword args, some poorly defined functions, and so on.

## protocol-implicitly-defined-attribute

Protocols must declare the attributes they require directly in the class body. Assigning to a new `self` attribute inside a protocol method introduces a member that implementations of the protocol would never be required to provide.

Add an annotated attribute (or property) to the protocol, or remove the assignment.

```python
from typing import Protocol

class Template(Protocol):
    name: str

    def method(self) -> None:
        self.temp: list[int] = []  # protocol-implicitly-defined-attribute
```

## read-only

This error indicates that the attribute being accessed does exist but cannot be modified.

For example, a `@property` with no setter cannot be assigned to:

```python
class Ex:
    @property
    def meaning(self) -> int:
        return 42

x = Ex()
x.meaning = 0
```

## redefinition

Pyrefly reports this error when a name that already has an annotation in the current scope is annotated again with a different type. Re-annotating the same variable can lead to confusing types; prefer introducing a new name instead.

```python
def f(x: int) -> None:
    x: str = str(x)  # redefinition
```

## redundant-cast

This warning is raised when `typing.cast()` is used to cast a value to a type it is already compatible with. Such casts are unnecessary and can be removed to improve code clarity.

The default severity of this diagnostic is `warn`.

```python
import typing

x: int = 42
# This cast is redundant since x is already an int
y = typing.cast(int, x)  # redundant-cast

# This is a valid cast since we're casting from a more general type
obj: object = "hello"
s = typing.cast(str, obj)  # No warning - this is a valid cast
```

The redundant cast warning helps identify unnecessary type casts that don't provide any additional type safety benefits.

## redundant-condition

This error is used to indicate a type that's equivalent to True or False is used as a boolean condition (e.g. an uncalled function)

```python
def f() -> bool:
  ...

# This will throw error, as it's likely that the function needs to be invoked.
if f:
  ...
# This will throw error, as it's equivalent to `if True`.
if "abc":
  ...
```

## reveal-type

Pyrefly uses this diagnostic to communicate the output of the [`reveal_type`](https://typing.python.org/en/latest/spec/directives.html#reveal-type) function.

The default severity of this diagnostic is `info`.

## unannotated-attribute

This error is raised when a class attribute is missing a type annotation and is initialized with the `None` literal. Without an explicit annotation, Pyrefly infers the type as `Any | None`, which reduces type safety. To fix it, add an explicit type annotation to the attribute.

The default severity of this diagnostic is `ignore`.

```python
class MyClass:
    # error: This expression is implicitly inferred to be `Any | None`. Please provide an explicit type annotation.
    value = None

# Fixed version:
class MyClass:
    value: int | None = None
```

## unannotated-parameter

This error is raised when a function parameter is missing a type annotation. This helps enforce fully-typed codebases by ensuring all parameters have explicit types. To fix it, add a type annotation to the parameter.

Note: The `self` and `cls` parameters are excluded from this check as they are implicitly typed.

The default severity of this diagnostic is `ignore`.

```python
def process_data(x: int, y):  # error: `process_data` is missing an annotation for parameter `y`
    return x + y

# Fixed version:
def process_data(x: int, y: int) -> int:
    return x + y
```

## unannotated-return

This error is raised when a function is missing a return type annotation. This helps enforce fully-typed codebases by ensuring all functions declare their return types explicitly. To fix it, add a return type annotation to the function.

The default severity of this diagnostic is `ignore`.

```python
def calculate_sum(x: int, y: int):  # error: `calculate_sum` is missing a return annotation
    return x + y

# Fixed version:
def calculate_sum(x: int, y: int) -> int:
    return x + y
```

## unbound-name

This error corresponds to the runtime `NameError`, indicating that a variable is referenced but does not exist.

```python
def do_things(stuff: list[int]) -> str:
  ...

do_thing([1, 2])  # typo! Or, unbound-name
```

## unexpected-keyword

A function was called with an extra keyword argument.

```python
def two_args(a: int, b: int) -> int:
  ...

two_args(a=1, b=2, c=3)
```

## unexpected-positional-argument

A positional argument was passed for a keyword-only parameter.

```python
def takes_kwonly(*, x: int) -> int:
  ...

takes_kwonly(1)  # should be `takes_kwonly(x=1)`!
```

## unknown-name

`unknown-name` occurs when attempting to load a name from another scope, but the name cannot be found.

```python
def where() -> None:
  # There is no spoon: unknown-name
  global spoon
```

## unnecessary-comparison

This warning is raised when an identity comparison (`is` or `is not`) is made between
literals whose comparison result is statically known.

The default severity of this diagnostic is `warn`.

```python
def test0() -> None:
    # Different literals are always different objects
    if 1 is 2:  # unnecessary-comparison: always False
        pass
    # Same singletons are always the same object
    if True is not False:  # unnecessary-comparison: always True
        pass

def test1(x: object) -> None:
    # Comparing an instance to a class is always False
    if x is int:  # unnecessary-comparison: did you mean isinstance(x, int)?
        pass
```

This check is relatively conservative and only warns on limited cases where the comparison is highly likely to be redundant.

## unreachable

This error is raised when a `return` or `yield` can never be reached because it comes
after a statement that always exits the current flow, such as `return`, `raise`, `break`, or `continue`.

```python
def example():
    return 1
    return 2  # This `return` statement is unreachable [unreachable]

def generator():
    return
    yield 1  # This `yield` expression is unreachable [unreachable]

def loop_example():
    while True:
        break
        return 1  # This `return` statement is unreachable [unreachable]
```

Note that `yield` statements can follow other `yield` statements without error, since generators
can produce multiple values:

```python
def valid_generator():
    yield 1
    yield 2  # This is valid
```

## unsafe-overlap

Protocols decorated with `@runtime_checkable` may be used in `isinstance` and `issubclass` checks, but the runtime will only checks that all the required attributes are present, without looking at their types.

This error occurs when the object you're checking against the protocol has all the required attributes, but their types are not compatible.

In the example below, `C` should not match with `P`, but the `isinstance` check will succeed at runtime.

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class P(Protocol):
    x: int

class C:
    x: str

c = C()
if isinstance(c, P):
    pass
```

## unsupported

This error indicates that pyrefly does not currently support a typing feature.

## unsupported-delete

This error occurs when attempting to `del` something that cannot be deleted.

Besides obvious things like built-in values (you can't `del True`!), some object attributes are protected from deletion.
For example, read-only and required `TypedDict` fields cannot be deleted.

## unsupported-operation

This error arises when attempting to perform an operation between values of two incompatible types.

```python
if "hello" in 1:  # int doesn't support `in`!
  ...
```

## untyped-import

Type information for some third-party libraries is shipped in a stubs package separate from the
library's source code. This error is emitted when we detect that a library is being used without
the recommended stubs package being installed.

The default severity of this diagnostic is `ignore`.

## unused-coroutine

If the result of an async function call is not awaited or used, we will raise an error.

```python
async def foo():
    return 1

async def bar():
    foo()  # error
    await foo()  # ok
    x = foo()  # ok
```

## unused-ignore

This error is raised when a `# pyrefly: ignore` comment is not used to suppress an error, and can be safely removed.

The default severity of this diagnostic is `ignore`.

## variance-mismatch

The inferred variance of a type variable does not match its declared variance. This warning is raised for protocols where the way a type variable is used implies a different variance than what was declared. For example, if a protocol only uses `T` in covariant positions but `T` is declared as invariant, this warning suggests declaring `T` as covariant.

The default severity of this diagnostic is `warn`.

```python
from typing import Protocol, TypeVar

T = TypeVar("T")

class A(Protocol[T]):  # variance-mismatch: Type variable `T` in class `A` is declared as invariant, but could be covariant based on its usage
    def f(self) -> T: ...
```


---

---
title: Pyrefly Error Suppressions

description: Learn how to suppress type check errors in Pyrefly with code comments and baseline files.
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

import CodeSnippet from '@site/src/sandbox/CodeSnippet'

## Error Suppression Comments

The Python type system allows you to suppress errors with a comment. This feature can be helpful in many scenarios. For example, after enabling a type checker, suppressions can allow you to get a clean type check signal without having to stop and fix every pre-existing error in your code.

There are multiple ways to do this in Pyrefly.

```python
def foo() -> int:
  # pyrefly: ignore
  return "this is a type error"
```

You can also put the comment on the same line as the error.

```python
def foo() -> int:
  return "this is a type error" # pyrefly: ignore
```

You can also target specific error types:

```python
def foo() -> int:
  return "this is a type error" # pyrefly: ignore[bad-return]
```

We respect the specification and allow `type: ignore` to be used:

```python
def foo() -> int:
  return "this is a type error" # type: ignore
```


We also have a special comment that will ignore all errors in a file.


<pre>
  <CodeSnippet
  sampleFilename="why_hints.py"
  isCodeSnippet={true}
  codeSample={`# pyrefly: ignore-errors

from typing import *

def test(x: int):
    return f"{x}"

def bar() -> int:
    # this error won't be reported
    return ""
`}
  />
</pre>

Pyrefly can automatically suppress all type errors in your project by running:

```
pyrefly suppress
```

This is equivalent to `pyrefly check --suppress-errors`.

## Baseline Files (Experimental)

Pyrefly also supports storing errors in a baseline file. Any errors matching the baseline will be ignored and only new errors will be reported.
This is useful when introducing type checking to a project for the first time, or when rolling out changes that require many suppression comments.
This feature is inspired by tools like [basedpyright](https://docs.basedpyright.com/latest/benefits-over-pyright/baseline/) and [Android Studio](https://developer.android.com/studio/write/lint#snapshot).

To generate (or re-generate) the baseline file:

```
pyrefly check --baseline="<path to baseline file>" --update-baseline
```

To check your project using a baseline file and report only newly-introduced errors, you can either use the CLI flag:

```
pyrefly check --baseline="<path to baseline file>"
```

Or specify the baseline in your configuration file (`pyrefly.toml` or `pyproject.toml`):

```toml
# pyrefly.toml
baseline = "baseline.json"
```

```toml
# pyproject.toml
[tool.pyrefly]
baseline = "baseline.json"
```

When the baseline is specified in the configuration file, you don't need to pass the `--baseline` flag on every invocation. The CLI flag takes precedence if both are specified.

Note that `baseline` is a **project-level setting** and cannot be overridden in [`sub-config`](./configuration.mdx#sub-configs) sections. If you need different baseline files for different parts of your codebase, consider using separate Pyrefly configuration files.

Errors are matched with the baseline by looking at file, error code, and column number.
Note that errors suppressed by the baseline file are still shown in the IDE.
This feature is experimental, so please submit any feedback or requests you have on our Github repo.

## Upgrading Pyrefly (And other changes that introduce new type errors)

Upgrading the version of Pyrefly you're using, or a third party library you depend on can surface new type errors in your code. Fixing them all at once is often not realistic. We've written scripts to help you temporarily silence them.

```
# step 1
pyrefly suppress
```

```
# step 2
<run your formatter of choice>
```

```
# step 3
pyrefly suppress --remove-unused
```
Repeat the steps above until you get a clean formatting run and a clean type check.

This will add ` # pyrefly: ignore` comments to your code that will enable you to silence errors, and come back and fix them at a later date. This can make the process of upgrading a large codebase much more manageable.

:::note
`pyrefly suppress` is equivalent to `pyrefly check --suppress-errors`, and `pyrefly suppress --remove-unused` is equivalent to `pyrefly check --remove-unused-ignores`.
:::


---

---
title: Import Resolution
slug: /import-resolution

description: How imports in a given file are found by Pyrefly and their bindings are resolved, including files that are being type checked
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

# Import Resolution

This doc describes how imports in a given file are found within Pyrefly while performing
a type check or resolving IDE language support operations.

NOTE: see the [Configuration documentation](./configuration.mdx) for more info on
the config options referenced below.

## Relative Imports

If the import is relative (starting with one or more dots), the import is
resolved relative to the path of the file importing it. A single dot at the
beginning of the import (e.g. `.file.to.import`) represents the current
directory, and more dots (e.g. `..other.file`) will continue to walk upward.

## Absolute Imports

For absolute imports, Pyrefly searches for a match in each of the following groups. The
matching process is explained in the next paragraph.

1. Try to import from the search path. See the [search path section](#search-path) for more information.
2. Try to import from `typeshed`.
3. Try to import from the fallback search path. See the [fallback search path section](#fallback-search-path) for
more information on the contents of the search path.
4. Try to import from the site package path. See the
[site package path section](#site-package-path) for more information on the contents
of the site package path.
5. Return an import error.

When searching for a match in one of the above groups, Pyrefly performs the following process
over two passes, one looking for stub *packages*, and the other looking for source *packages*. See
[Stub Files vs Source Files](#stub-files-vs-source-files) for more information.

1. Attempt to match each part of the name to directories in the group, selecting the first
match that is found.
2. If the result is a `.pyi` file or regular package (directory with an
`__init__.py`/`__init__.pyi` file), return the result. Otherwise, keep searching and
attempt to find a `.pyi` file or regular package.

### Search Path

The search path ([see `search-path` in configuration docs](configuration.mdx#search-path))
consists of several entries representing project files.

1. Search path from CLI args.
2. Search path from config files.
3. If [`disable-search-path-heuristics`](configuration.mdx#disable-search-path-heuristics)
   is not set, Pyrefly appends an import root directory to the search path.

The import root is:
1. `src/` if there's a `src/` directory in the same directory as the config file.
2. The parent directory (`..`) if there's an `__init__.py` or `__init__.pyi` in the same
   directory as the config file.
3. Otherwise, the directory containing the config file.

### Fallback Search Path

The fallback search path is a heuristic automatically constructed by Pyrefly to attempt to
find project files when there's no config file marking the project root, and Pyrefly
is unable to determine from other heuristics where an import root might be.
It is only constructed when
[`disable-search-path-heuristics`](configuration.mdx#disable-search-path-heuristics)
is not set.

The fallback search path consists of each directory from the directory containing
a given file to the root of your filesystem. For example, if you have the following setup:

```
/
|- projects/
   |- project_a/
   |  |- b/
   |  |  |- c.py
   |  |- d.py
   |- project_e/
      |- f.py
```

`c.py`'s fallback search path would be `['/projects/project_a/b', '/projects/project_a',
'/projects', '/']`
- `d.py` could be importable with the paths `d`, `project_a.d`, or `projects.project_a.d`.
- `f.py` could be importable with the paths `project_e.f` or `projects.project_e.f`.

`e.py`'s fallback search path would be `['/projects/project_a', '/projects', '/']`
- `c.py` could be importable with the paths `b.c`, `project_a.b.c`, or `projects.project_a.b.c`
- `f.py` could be importable with the paths `project_e.f` or `projects.project_e.f`

`f.py`'s fallback search path would be `['/projects/project_e', '/projects', '/']`
- `c.py` could be importable with the paths `project_a.b.c` or `projects.project_a.b.c`
- `d.py` could be importable with the paths `project_a.d` or `projects.project_a.d`

### Site Package Path

The site package path
([see `site-package-path` in configuration docs](configuration.mdx#site-package-path))
consists of several entries representing third-party packages.

1. Site package path from a config file (if no CLI override is present) or CLI args.
2. A site package path queried from a Python interpreter, if one could be found.
   See [Environment Autoconfiguration](configuration.mdx#environment-autoconfiguration)
   for more information on finding interpreters.

## Stub Files vs Source Files

A
[stub file](https://typing.python.org/en/latest/spec/distributing.html#stub-files)
is any file that ends with a `.pyi` file suffix. They have many uses, including
adding typing to non-Python extension code, distributing typing information
separate from implementation, or overriding an implementation with more accurate
typing information.

A stub package is a second package corresponding to a regular package, with `-stubs`
appended to its name. A `-stubs` package should only include stub files (`.pyi`),
which override any `.py` or `.pyi` files in the non-stubs package. These are preferred
when available, since they contain the interfaces a library exposes to developers. An
example of this includes the popular library [`pandas`](https://github.com/pandas-dev/pandas),
and its stub package, [`pandas-stubs`](https://github.com/pandas-dev/pandas-stubs).

When importing from a non-stubs package, Pyrefly loads typing information from
imports by first searching for a relevant `-stubs` package, then by looking at
the non-stubs package's `.pyi` files, then falls back to a `.py` file. See
[Absolute Imports](#absolute-imports) for details on when non-stubs packages
are allowed to be used for types, and how you can override that behavior.

## Bundled Third Party Stubs

Pyrefly bundles stubs for several popular third party libraries along with its binary which are
used for type checking and IDE features. These bundled stubs have special import resolution rules which differ
from how installed stubs might be treated. The decision tree below describes the scenarios in which third party stubs
are used.


```
- Pyrefly config file present?
   - Yes
      - Is the package installed?
         - Yes
            - Are stubs installed by user?
               - Yes
                  Installed stubs are used.
               - No
                  UntypedImport error.
         - No
            MissingImport error.
   - No
      - Is the package installed?
         - Yes
            Bundled stubs used.
         - No
            MissingSourceForStubs error.
```

## Editable Installs

When using static analysis tools with an editable install, the editable install should be configured to use `.pth`
files that contain file paths (`/project/src/module`) rather than executable lines (started with `import`) that
install import hooks. See [setuptools doc](https://setuptools.pypa.io/en/latest/userguide/development_mode.html)
and [PEP 660](https://peps.python.org/pep-0660/) for more information.

Import hooks can provide an editable installation that offers a more accurate representation of the actual installation
environment. However, since resolving module locations through an import hook
**requires executing Python code at runtime**, they are incompatible with Pyrefly and other static analysis tools that
operate without code execution. Consequently, when an editable install is configured to use import hooks, Pyrefly
will be unable to automatically locate and analyze the corresponding source files, resulting in incomplete type checking and
code analysis.

Setuptools build system uses import hooks by default for editable installations. To ensure compatibility between
setuptools-based editable installs and Pyrefly, setuptools must be configured to use path-based `.pth` files instead.
This configuration should be performed through the build frontend (such as `pip`) by specifying the appropriate
options during installation or in the project's configuration files.

### uv with setuptools

When using [uv](https://docs.astral.sh/uv/) with setuptools, uv can be
[configured](https://docs.astral.sh/uv/reference/settings/#config-settings) to avoid import hooks.

NOTE: The `uv_build` backend always uses path-based `.pth` files.

### pip with setuptools
When using `pip` with setuptools-based projects, there are two ways to avoid import hooks:
[compat mode](https://setuptools.pypa.io/en/latest/userguide/development_mode.html#legacy-behavior)
and [strict mode](https://setuptools.pypa.io/en/latest/userguide/development_mode.html#strict-editable-installs).

### Hatch / Hatchling

[Hatchling](https://hatch.pypa.io/1.9/config/build/) uses path-based `.pth` files by default.
It will only use import hooks if you set [`dev-mode-exact` to true](https://hatch.pypa.io/latest/config/build/#dev-mode).

### PDM

[PDM](https://backend.pdm-project.org/) uses path-based `.pth` files by default.
It will only use import hooks if you set
[`editable-backend` to "editables"](https://backend.pdm-project.org/build_config/#choose-the-editable-build-format).

### Poetry / Poetry-core
[Poetry-core](https://github.com/python-poetry/poetry-core) backend always uses path-based `.pth` files.

## Debugging Import Issues

Pyrefly has a `dump-config` command that dumps the import-related config options it is using for
each file it is checking. To use it, simply replace `check` with `dump-config` in your
command-line invocation.


---

---
title: Introduction
description: Guides and references for all you need to know about Pyrefly type checker and IDE extension.
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

import CodeSnippet from '@site/src/sandbox/CodeSnippet'

Pyrefly is a fast type checker and language server for Python with powerful IDE features. It analyzes your Python code to help you catch type-related errors before your code runs, making your applications more reliable and easier to maintain. Pyrefly supports both IDE integration and CLI usage, giving you flexibility in how you incorporate type checking into your workflow.

## Benefits of Type Checking

Adding type annotations to your Python code and using a type checker like Pyrefly provides several important benefits:

- **Catch bugs early** - Identify type-related errors during development rather than at runtime
- **Improve code quality** - Type annotations serve as living documentation, making your code more readable and self-documenting
- **Enhance developer experience** - Get better IDE support with accurate autocomplete, refactoring tools, and inline documentation
- **Safer refactoring** - Make large-scale changes with confidence, knowing the type checker will catch incompatible type usage
- **Better collaboration** - Types create clear contracts between different parts of your codebase, making it easier for teams to work together

## Try Pyrefly

Here's a simple example showing how Pyrefly can catch type errors:

<CodeSnippet
  sampleFilename="getting_started.py"
  codeSample={`# Example: Basic Type Checking

def greet(name: str) -> str:
    return "Hello, " + name

# This works fine since both "World" is a string and greet expects a string
message = greet("World")

# Pyrefly catches this error before runtime due to a type misatch between 42 and "str"
# Error: Argument of type 'int' is not assignable to parameter of type 'str'
error_message = greet(42)
`}
/>

In this example, Pyrefly flags the second call to `greet()` because we're passing an integer (`42`) where a string is expected, helping you catch this issue before your code runs. To learn more about Python typing and how to use it effectively:

- If you're new to Python, check out our [Python Typing for Beginners](python-typing-for-beginners) guide.
- If you're familiar with Python but new to typing, see our [Typing for Python Developers](typing-for-python-developers) guide.


---

---
title: Installation
description: How to install Pyrefly
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

Pyrefly is available on [PyPI](https://pypi.org/project/pyrefly/) with a new release every Monday. We often release more frequently when shipping new features and bug fixes.

## Install

You can use `uv`, `poetry`, `pip`, `pixi` or `conda` to install Pyrefly. The following commands show you how to install Pyrefly and run 2 basic commands: `init` and `check`.

* `pyrefly init` will update your `pyproject.toml` file (or create a `pyrefly.toml` file) in your project directory, including some basic configuration. It will also attempt to [migrate](../migrating-to-pyrefly) your existing type checker configuration.
* `pyrefly check --summarize-errors` will run the Pyrefly type checker on your project, providing a list of type errors and a summary of error types. The `--summarize-errors` flag is optional, remove it if you don't want summary stats.
* `pyrefly suppress` will mark all existing errors as ignored, allowing you to start with a clean check. (You can also use `pyrefly check --suppress-errors`.)


Simply `cd` into your project directory and run:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="pip" label="Pip" default>
    ```
    pip install pyrefly
    pyrefly init
    pyrefly check --summarize-errors
    ```
  </TabItem>
  <TabItem value="conda" label="Conda">
    ```
    conda install -c conda-forge pyrefly
    pyrefly init
    pyrefly check --summarize-errors
    ```
  </TabItem>
  <TabItem value="uv" label="uv">
    ```
    uvx pyrefly init
    uvx pyrefly check --summarize-errors
    ```
  </TabItem>
  <TabItem value="poetry" label="Poetry">
    ```
    poetry add --group dev pyrefly
    poetry run pyrefly init
    poetry run pyrefly check --summarize-errors
    ```
  </TabItem>
  <TabItem value="pixi" label="Pixi">
    ```
    pixi add pyrefly
    pixi run pyrefly init
    pixi run pyrefly check --summarize-errors
    ```
  </TabItem>
</Tabs>

## Configure

You can set up a basic configuration file to type-check your project. You can add configuration options to a `pyproject.toml` file or create a `pyrefly.toml` file in your project directory. All [configuration options are documented here](../configuration).

```
[tool.pyrefly]
search_path = [
    "example_directory/..."
]
```

Then, run `pyrefly check` again, and the tool will use your configuration options.

The tool may return a list of type errors; this is perfectly normal. You have a few options at this point:

1. Use `# pyrefly: ignore` comments to silence the errors. This will get your project to a clean type-checking state, and you can reduce the number of errors as you go. We've included a command that can do this for you:

```
pyrefly suppress
```

2. Use extra configuration options to silence specific categories of errors or exclude files with more errors than average.

----

## Upgrading Pyrefly

Upgrading the version of Pyrefly you're using or a third-party library you depend on can reveal new type errors in your code. Fixing them all at once is often unrealistic. We've written scripts to help you temporarily silence them.

```
# Step 1
pyrefly suppress
```

```
# Step 2
<run your formatter of choice>
```

```
# Step 3
pyrefly suppress --remove-unused
```

Repeat these steps until you achieve a clean formatting run and a clean type check.

This will add `# pyrefly: ignore` comments to your code, enabling you to silence errors and return to fix them later. This can make the process of upgrading a large codebase much more manageable.

----

## Add Pyrefly to CI

After your project passes type checks without errors, you can prevent new bugs from being introduced. Enforce this through CI (Continuous Integration) to prevent other maintainers from merging code with errors. Here is an example for GitHub.

Save your workflow in the following path within your repository:

```
.github/workflows/typecheck.yml
```

GitHub automatically detects `.yml` files within `.github/workflows/` and sets up the defined workflows.

```
name: Pyrefly Type Check

on:
  pull_request:
    branches: [main]
  workflow_dispatch:  # Allows manual triggering from the GitHub UI

jobs:
  typecheck:
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5

      # Install Python dependencies and create environment
      - name: Install dependencies and run type checking
        run: |
          python -m venv .venv
          source .venv/bin/activate
          python -m pip install --upgrade pip
          # Install your dependencies; adjust the following lines as needed
          pip install -r requirements-dev.txt

      - name: Install Pyrefly
        run: pip install pyrefly

        - name: Run Pyrefly Type Checker
          run: pyrefly check
```

### Inline PR Annotations

Pyrefly can emit errors as [GitHub Actions workflow commands](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions) so that type errors appear inline when reviewing pull requests.

To enable this, pass `--output-format=github`:

```
        - name: Run Pyrefly Type Checker
          run: pyrefly check --output-format=github
```

### A few notes about this setup:

- Building your environment and installing dependencies will enhance type safety by checking the types of imports. *This is not required, but encouraged!*
- Simply drop in `pyrefly check` to existing workflows that build and test your environment.

```
        - name: Run Pyrefly Type Checker
          run: pyrefly check
```

- Your `pyrefly.toml` or Pyrefly configs in your `pyproject.toml` will be automatically detected. Learn how to [configure Pyrefly here](../configuration).

----

## Pre-commit

Pyrefly provides a [pre-commit hook](https://pre-commit.com/) so you can automatically type check files before they are committed.

We maintain a dedicated repository for this integration here: [facebook/pyrefly-pre-commit](https://github.com/facebook/pyrefly-pre-commit)

That repository contains:

- A pre-commit hook
- Installation instructions
- Example configuration snippets for your project and CI

To get started, follow the setup steps in the repo’s [README](https://github.com/facebook/pyrefly-pre-commit#readme).


---

---
title: Migrating from Mypy

description: How to switch your type checker configuration from Mypy to Pyrefly
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

## Running Pyrefly

Like mypy, pyrefly can be given a list of files to check:

```sh
$ pyrefly check file1.py file2.py
```

The easiest way to run pyrefly on all files in a project is to run it from the project root:

```sh
$ cd your/project
$ pyrefly check
```

Pyrefly is designed to have sensible defaults, and you may not need to configure it at all.
However, projects with existing mypy configs may want to configure pyrefly to suit their own needs.

## Mypy Config Migration

To make it as easy as possible to get started with pyrefly, we've provided a script for automatically migrating a mypy config to pyrefly.

```sh
$ pyrefly init path/to/your/project
```

This will search for an existing `mypy.ini` or `pyproject.toml` with a `tool.mypy` section, and then transform it into a `pyrefly.toml` (or `[tool.pyrefly]` section) while preserving as many options as possible. See `init --help` for more options.

We do recommend checking the resulting config for errors. While there is some overlap between mypy's config options and pyrefly's config options, it's not always possible to cleanly translate one config option to another.

If you'd rather start fresh with a hand-written config, please see the [pyrefly configuration docs](configuration.mdx).
If you run into any issues with config migration, please [let us know](https://github.com/facebook/pyrefly/issues)!

### Config options

The following config options make Pyrefly behave more like Mypy:

```toml
# By default, mypy does not check unannotated function bodies. The following flag will configure Pyrefly to match mypy's behavior:
untyped_def_behavior = "skip-and-infer-return-any"
```
```toml
# If mypy is configured with `--check-untyped-defs` or `--strict` it will check function bodies where the function signature is unannotated.
# The following flag will enable this behavior:
untyped_def_behavior = "check-and-infer-return-any"
```

```toml
# Direct Pyrefly to respect `# mypy: ignore` and `# mypy: ignore-errors` comments
permissive-ignores = true
```

### Config Migration Details

`files`, `modules`, and `packages` are combined into `project_includes`. This should work exactly the same for `files` and `packages`. Mypy doesn't recurse into `modules`, but pyrefly will.

Pyrefly makes an effort to transform the `exclude` regex into a list of filepath globs for `project_excludes`. This should excel on simple regexes, such as `some/file.py|exclude_dir/`, which becomes `["**/some/file.py", "**/exclude_dir/"]`.

The `ignore_missing_imports` per-module config option is turned into a list of modules. For example:

```ini
[mypy-some.*.module]
ignore_missing_imports = True
```

Becomes:

```toml
replace_imports_with_any = ["some.*.module"]
```

Mypy's `follow_imports = "skip"` is handled the same way.

Pyrefly does support mypy's [module name pattern syntax](https://mypy.readthedocs.io/en/stable/config_file.html#config-file-format): see [Module Globbing](configuration.mdx#module-globbing) in the configuration docs.

Mypy's `follow_untyped_imports` option is allowed to be global or per-module. The pyrefly equivalent, `use_untyped_imports`, is only global. This setting defaults to `true` unless
the `follow_untyped_imports` is disabled in the `[mypy]` section of the migrated config.

### Mypy Error Codes and Pyrefly Error Kinds

Pyrefly maps Mypy's [error codes](https://mypy.readthedocs.io/en/stable/error_code_list.html) to equivalent pyrefly [error kinds](error-kinds.mdx).
While not every error code has an equivalent error kind, we make an effort to ensure that pyrefly suppresses the same errors that mypy does.

This may lead to overly broad error suppressions, and you may want to consider removing some error kinds from the disable list.
You can also use a [SubConfig](configuration.mdx#sub_config) to selectively silence errors in specific files,
or see [Silencing Errors](#silencing-errors) for how to suppress errors at the source.

See [Error Kind Mapping](#error-kind-mapping) for a table showing the relationship between type check diagnostic settings and error kinds.

### Per-Module configs

Mypy's per-module configs let you change a wide range of configuration options for modules matching a module wildcard.
Pyrefly's [SubConfigs](configuration.mdx#sub_config) are a similar mechanism that let you configure pyrefly's behavior for files matching a filepath glob.
However, they support significantly fewer options, and only `disable_error_code` and `enable_error_code` will be migrated over to the pyrefly config.

## Silencing Errors

Like mypy, pyrefly has ways to silence specific error codes. Full details can be found in the [Error Suppression docs](error-suppressions.mdx)

To silence an error on a specific line, add a disable comment above that line. You can either suppress all errors on that line:

```
# pyrefly: ignore
x: str = 1
```

Or target a specific error type:

```
# pyrefly: ignore[bad-assignment]
x: str = 1
```

To suppress all instances of an error, disable that error in the config:

```
[errors]
missing-import = false
```

This is equivalent to mypy's `disable_error_code`, though of course the [error codes](error-kinds.mdx) are different!

### Error Kind Mapping


This table shows the mapping between mypy's [error codes](https://mypy.readthedocs.io/en/stable/error_code_list.html) and pyrefly's [error kinds](error-kinds.mdx).

This table will be expanded as more diagnostics are supported.

| Mypy | Pyrefly |
| ------- | ------- |
| attr-defined | missing-attribute |
| union-attr | missing-attribute |


---

---
title: Migrating from Pyright

description: How to switch your type checker configuration from Pyright to Pyrefly
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

## Running Pyrefly

Like pyright, pyrefly can be given a list of files to check:

```sh
$ pyrefly check file1.py file2.py
```

The easiest way to run pyrefly on all files in a project is to run it from the project root:

```sh
$ cd your/project
$ pyrefly check
```

Pyrefly doesn't need a config file to start checking your code. Its sensible defaults are designed to work well for most projects.
However, projects with existing pyright configs may want to configure pyrefly to suit their own needs.

## Pyright Config Migration

To make it as easy as possible to get started with pyrefly, we've provided a script for automatically migrating a pyright config to pyrefly.

```sh
$ pyrefly init path/to/your/project
```

This will search for an existing `pyrightconfig.json` or `pyproject.toml` with a `tool.pyright` section, and then transform it into a `pyrefly.toml` (or `[tool.pyrefly]` section) while preserving as many options as possible. See `init --help` for more options.

There is a significant overlap between pyright's and pyrefly's configuration options, so migration is pretty straightforward. However, it may be worth checking the generated config for errors, just in case.

If you'd rather start fresh with a hand-written config, please see the [pyrefly configuration docs](configuration.mdx).
If you run into any issues with config migration, please [let us know](https://github.com/facebook/pyrefly/issues)!

## Config Migration Details

When it comes to listing files, pyright uses just paths, while pyrefly supports glob patterns. Thankfully, paths are a subset of glob patterns, so pyrefly can just use the paths as-is. You could consider manually simplifying the paths into glob patterns, but it's not necessary.

Pyright supports four platforms: Windows, Linux, Darwin (macOS), and All. Since pyrefly only supports Python's [supported platforms](https://docs.python.org/3/library/sys.html#sys.platform), we choose to treat "All" as "linux".

### Type Check Diagnostic Settings and Error Kinds

Pyrefly maps pyright's [type check diagnostics settings](https://microsoft.github.io/pyright/#/configuration?id=type-check-diagnostics-settings) to equivalent pyrefly [error kinds](error-kinds.mdx).
While not every diagnostic setting has an equivalent error kind, we make an effort to ensure that pyrefly suppresses the same errors that pyright does.

This may lead to overly broad error suppressions, and you may want to consider removing some error kinds from the disable list.
You can also use a [SubConfig](configuration.mdx#sub_config) to selectively silence errors in specific files,
or see [Silencing Errors](#silencing-errors) for how to suppress errors at the source.

See [Error Kind Mapping](#error-kind-mapping) for a table showing the relationship between type check diagnostic settings and error kinds.

### Execution Environments

Pyright's [execution environments](https://microsoft.github.io/pyright/#/configuration?id=execution-environment-options) let you customize the Python version, platform, module search paths, and diagnostic settings for some part of your project.
Pyrefly's [SubConfigs](configuration.mdx#sub_config) are a similar mechanism that let you configure pyrefly's behavior for files matching a filepath glob.
However, subconfigs do not support changing the Python version, platform, or module search paths.

Diagnostic settings are carried over to the equivalent subconfig, using the mapping mentioned [above](#type-check-diagnostic-settings-and-error-kinds).

### Extending Builtins

Pyright automatically imports any builtins defined in `__builtins__.pyi` at the project root or in a custom stubs directory specified by `stubPath` (defaulting to `./typings`).

Pyrefly supports this behavior - the directory for `stubPath` should be added to your Pyrefly config's `site-package-path`.

## Silencing Errors

Like pyright, pyrefly has ways to silence specific error codes. Full details can be found in the [Error Suppression docs](error-suppressions.mdx).

To silence an error on a specific line, add a disable comment above that line. You can either suppress all errors on that line:

```
# pyrefly: ignore
x: str = 1
```

Or target a specific error type:

```
# pyrefly: ignore[bad-assignment]
x: str = 1
```

To suppress all instances of an error, disable that error in the config:

```
[errors]
missing-import = false
```

This is similar to pyright's [type check rule overrides](https://microsoft.github.io/pyright/#/configuration?id=type-check-rule-overrides), though of course the [error codes](error-kinds.mdx) are different!

You can also use:

```toml
permissive-ignores = true
```

To allow `pyright: ignore` comments to be used by Pyrefly.

## Error Kind Mapping

This table shows the mapping between pyright's [type check diagnostics settings](https://microsoft.github.io/pyright/#/configuration?id=type-check-diagnostics-settings)
and pyrefly's [error kinds](error-kinds.mdx).

This table will be expanded as more diagnostics are supported.

| Pyright | Pyrefly |
| ------- | ------- |
| reportMissingImports | missing-import |
| reportMissingModuleSource | missing-import |


---

---
title: Migration Guides
description: How to switch from another type checker to Pyrefly
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

Welcome to the Pyrefly migration guide. This section provides resources to help you transition from other type checkers to Pyrefly.

## Migration Guides

- [Migrating from Mypy](migrating-from-mypy.mdx) - Guide for transitioning from Mypy to Pyrefly
- [Migrating from Pyright](migrating-from-pyright.mdx) - Guide for transitioning from Pyright to Pyrefly

Choose the appropriate guide based on your current type checker to get started with your migration to Pyrefly.


---

---
title: Pydantic Lax Mode Type Conversions
description: Complete reference of how Pyrefly converts types in Pydantic lax mode.
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

# Pydantic Lax Mode Type Conversions

This page provides a complete reference for how Pyrefly converts types when working with Pydantic models in **lax mode** (the default). For background on how lax mode works, see the [main Pydantic documentation](../pydantic).

**Note:** Types without a specific conversion rule (e.g., `Callable`, `Any`, custom classes) are converted to `Any`.

---

## Atomic Type Conversions

Named unions are used for atomic types to keep type signatures concise.

| Input Type | Named Union | Expanded Type |
|------------|-------------|---------------|
| `int` | `LaxInt` | `int \| bool \| float \| str \| bytes \| Decimal` |
| `float` | `LaxFloat` | `int \| bool \| float \| str \| bytes \| Decimal` |
| `bool` | `LaxBool` | `bool \| int \| float \| str \| Decimal` |
| `Decimal` | `LaxDecimal` | `Decimal \| int \| float \| str` |
| `str` | `LaxStr` | `str \| bytes \| bytearray` |
| `bytes` | `LaxBytes` | `str \| bytes \| bytearray` |
| `date` | `LaxDate` | `date \| datetime \| int \| float \| str \| bytes \| Decimal` |
| `datetime` | `LaxDatetime` | `date \| datetime \| int \| float \| str \| bytes \| Decimal` |
| `time` | `LaxTime` | `time \| int \| float \| str \| bytes \| Decimal` |
| `timedelta` | `LaxTimedelta` | `timedelta \| int \| float \| str \| bytes \| Decimal` |
| `Path` | `LaxPath` | `Path \| str` |
| `UUID` | `LaxUuid` | `UUID \| str` |
| `None` | (no conversion) | `None` |

---

## Compositional Type Conversions

**Notation:**
- `T_converted` means the type `T` is recursively converted using lax mode rules (e.g., `int` → `LaxInt`)
- `T_flattened` means the type `T` is converted and expanded (e.g., `int` → `int | bool | float | str | bytes | Decimal`)

| Input Type/Container | Output Type/Container |
|----------------------|-----------------------|
| `type[T]` | `type[T_converted]` |
| `T1 \| T2 \| ...` | `T1_flattened \| T2_flattened \| ...` |
| `list[T]`, `set[T]`, `frozenset[T]`,<br/>`Sequence[T]`, `Iterable[T]`, `deque[T]`,<br/>`tuple[T, ...]` | `Iterable[T_converted]` |
| `tuple[T1, T2, ...]` | `Iterable[T1_flattened \| T2_flattened \| ...]` |
| `dict[K, V]` | `Mapping[K, V_converted]` |

**Examples:**

- **Type wrapper:** `type[int]` → `type[LaxInt]`
- **Union types:** Each member is converted and flattened. `int | bool` → `int | bool | float | str | bytes | Decimal`
- **Single-element containers and unbounded tuples:** Named unions are preserved. `list[int]` → `Iterable[LaxInt]`
- **Concrete tuples:** Element types are expanded and flattened. `tuple[int, str]` → `Iterable[int | bool | float | str | bytes | bytearray | Decimal]`
- **Dictionaries:** Only values are converted; keys remain unchanged. `dict[str, int]` → `Mapping[str, LaxInt]`



---

---
title: Experimental Pydantic Support
description: Pyrefly experimental support for Pydantic.
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

# Experimental Pydantic Support

Pyrefly includes **experimental support** for [Pydantic](https://pydantic.dev/), a popular Python library for data validation and parsing. This feature aims to provide improved static type checking and IDE integration for Pydantic models.

> **Note:** This support is experimental and actively evolving. The design may change based on feedback and development. Please note that we are supporting Pydantic v2 and above, which means that deprecated v1 features are not included.

### Feedback

We welcome your feedback and suggestions. Please share your thoughts and ideas [here](https://github.com/facebook/pyrefly/issues/1078).

---

## What is Pydantic?

Pydantic is a Python library designed for data validation and parsing using Python type annotations. While it shares similarities with dataclasses in creating structured data containers, Pydantic additionally provides extensive runtime data validation.

---

## How Pyrefly Supports Pydantic

- Understands Pydantic constructs like `BaseModel`, `Field`, `ConfigDict`, and model-level config options.
- Performs static analysis that mirrors Pydantic's runtime validation logic, minimizing false positives in your IDE.
- Provides immediate feedback (e.g. red squiggles or type errors) when the code would fail under Pydantic's actual behavior.
- Does **not** require a plugin or manual config — support is builtin and automatic.

---

## Validation Modes

Pydantic models can use two validation modes:

- **Lax (Default)**: Values are automatically coerced when possible. For example, a string like `"123"` can be coerced to an integer.
- **Strict**: Coercion is disabled, and only exactly matching types are accepted.

Pyrefly reads your model config to determine the validation mode, so it can strike a balance between providing useful typing and IDE support while maintaining Pydantic's flexibility.

### How Lax Mode Works in Pyrefly

In lax mode (the default), Pyrefly uses **named union types** to represent the acceptable input types for each field. These named unions keep type signatures concise and readable while closely reflecting Pydantic's runtime coercion behavior.

For example, when you define a field with type `int` in lax mode, Pyrefly represents it as `LaxInt`, which is equivalent to `int | bool | float | str | bytes | Decimal` (based on [Pydantic's conversion table](https://docs.pydantic.dev/latest/concepts/conversion_table/)):

```python
from pydantic import BaseModel
from typing import reveal_type
from decimal import Decimal

class Model(BaseModel):
    x: int = 0

reveal_type(Model.__init__)  # revealed type is (self: Model, *, x: LaxInt = ..., **Unknown) -> None

# int field accepts: int, bool, float, str, bytes, Decimal
Model(x=1)
Model(x=True)
Model(x=1.0)
Model(x='123')
Model(x=b'123')
Model(x=Decimal('123'))
```

> **Note:** Pyrefly applies named unions (like `LaxInt`) to atomic types and recursively to nested types. Container types are converted to more general types to handle variance: for example, `list[int]` becomes `Iterable[LaxInt]`. When you use union types (e.g., `int | bool`), each member is expanded individually and then flattened into a regular union.

For a complete reference of all type conversions in lax mode, see the [Lax Mode Type Conversions](../pydantic-lax-conversions) page.

---

## Comparison to Existing Tools

[Mypy’s Pydantic plugin](https://docs.pydantic.dev/1.10/mypy_plugin/) has five configuration options to control how strict the checking is — for example, whether coercion is allowed or extra fields are permitted.
**Pyrefly works differently**. It doesn't rely on external config. Instead, it inspects your code directly — things like `strict=True` or `extra='forbid'` and strikes a balance between Pydantic's flexibility and Pyrefly's type checking.

---

## How to Use

You don’t need to enable or configure anything to use Pyrefly’s Pydantic support.

Just:

1. Install `pydantic` (preferably v2).
1. Install `pyrefly` (version 0.33.0 or later).
1. Write your Pydantic models as usual.
1. Run Pyrefly on your code.

Pyrefly will recognize Pydantic constructs like `BaseModel`, `Field`, and `model_config`, and provide appropriate type checking automatically. You can follow [this link](https://github.com/migeed-z/pyrefly-pydantic-demo) to try it out on some small examples.

---
## Supported Features with Examples

The following examples showcase which Pydantic features are currently supported by Pyrefly. Pyrefly does not cover all Pydantic features, but these features should provide good coverage of the most common Pydantic use cases. You can request additional Pydantic features to be supported by opening a GitHub issue.


### Immutable fields with ConfigDict

```python
from pydantic import BaseModel, ConfigDict

# Marking a model as frozen (immutable)
class Model(BaseModel):
    model_config = ConfigDict(frozen=True)
    x: int = 42
m = Model()
m.x = 10  # Error: Cannot set field `x` because the model is frozen
```


### Strict vs Non-Strict Field Validation

```python
from pydantic import BaseModel, Field

# Lax mode (default): runtime coercion allowed
class User(BaseModel):
    name: str
    age: int

# This passes at runtime and in Pyrefly because age accepts strings in lax mode
y = User(name="Alice", age="30")

# Strict mode: enforce exact types, no coercion
class User2(BaseModel):
    name: str
    age: int = Field(strict=True)

# This triggers type errors in Pyrefly and red squiggles in the IDE,
# and will also fail at runtime due to type mismatch.
z = User2(name="Alice", age="30")  # Error: age expects int, not str
```

### Handling Extra Fields in Pydantic Models

By default, Pydantic models allow extra fields (fields not defined in the model) to be passed during initialization. This behavior is consistent with Pyrefly’s support, which follows the default `extra='allow'` behavior.


```python
from pydantic import BaseModel

# Extra fields allowed by default
class ModelAllow(BaseModel):
    x: int

# This works fine: extra field `y` is allowed and ignored
ModelAllow(x=1, y=2)

# Explicitly forbid extra fields by setting `extra='forbid'`
class ModelForbid(BaseModel, extra="forbid"):
    x: int

# This will raise a type error because of unexpected field `y`, which is consistent with runtime behavior.
ModelForbid(x=1, y=2)
```

### Handling field constraints

Pyrefly provides limited support for range constraints on fields.
```python
from pydantic import BaseModel, Field

class Model(BaseModel):
    x: int = Field(gt=0, lt=10)

Model(x=5)   # OK
Model(x=0)   # Error: Argument value `Literal[0]` violates Pydantic `gt` constraint for field `x`
Model(x=15)  # Error: Argument value `Literal[15]` violates Pydantic `lt` constraint for field `x`
```

### Root Models

```python
from pydantic import RootModel, StrictInt

class IntRootModel(RootModel[int]):
   pass

class StrictIntRootModel(RootModel[StrictInt]):
   pass

m1 = IntRootModel(123)  # OK
m2 = IntRootModel("123") # OK - lax mode allows string-to-int coercion
m3 = StrictIntRootModel("123")  # Error: StrictInt doesn't allow coercion
```

### Alias validation

```python
from pydantic import BaseModel, Field

class Model(BaseModel, validate_by_name=True, validate_by_alias=True):
    x: int = Field(alias='y')

# both `x` and `y` are valid aliases
Model(x=0)
Model(y=0)
```


---

---
id: pyrefly-faq

title: FAQ

slug: /pyrefly-faq

description:
    Frequently Asked Questions about Pyrefly, a PEP 484 compliant Type Checker for
    Python and IDE extension.
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

# Pyrefly Frequently Asked Questions

## How do I pronounce Pyrefly?

It's pronounced PIE-ur-fly, rhyming with "firefly."

## What is the relationship to Pyre?

Pyrefly is a ground-up rebuild that doesn’t share any core type checking code with Pyre. Not only is Pyrefly written in a new language (Rust instead of OCaml), but its design deviates in a major way from [Pyre](https://pyre-check.org/). Rust enables us to deliver substantial performance improvements and support multiple operating systems (including Windows). Beyond the core type checker itself, there are helper tooling and many lessons learned that we will take from Pyre and the community of Python type checking maintainers who have done tremendous work to get the state of type checking to where it is today.

## Is Pyrefly a type checker or a language server?

Yes 😉

Pyrefly is both of these things, and you can use one without the other if you choose.

* type checking: Pyrefly can be used as a standalone type checker - directly run in your terminal, added to your CI or integrated into your IDE via an extension (made possible by leveraging language server capabilities)
* language server: Pyrefly can be used as a standalone Python language server, integrated into your IDE with all the typical IDE features you would expect (hover, go-to-definition etc.). You can use it with or without type checking enabled.

## Yet another Type Checker! Why not improve the ones adopted by the community already?

We are standing on the shoulders of giants. The contributions to Python typing by Mypy, Pyright, Pytype, Pyre and others have been invaluable. We borrowed concepts and learned from them as we rolled our own. Open source conformance matters to us a lot. While we might make some opinionated decisions, we'll adhere to the PEP process. Pyre was the only type checker that could scale for Meta’s needs and was starting to show its age, so we started with a ground-up rewrite aimed at usability and performance.

We built a custom engine for incremental computation and designed our type-checking algorithm based on years of experience in gradual typing theory and Rust expertise. By open-sourcing this technology we hope it can serve projects of any size well.

## Why Rust?

We would have preferred to write Pyrefly in Python, but we didn't think we could hit our ambitious performance goals using Python today (hopefully future work around free-threaded Python and JIT changes that). After ruling out Python, we wanted something that was safe, cross-platform, compiled to WASM (for a Playground experience). Rust and Go are probably the best choices for those goals, and our team at Meta had more experience with Rust.


## Where do I report bugs?

Please open an [issue on our GitHub](https://github.com/facebook/pyrefly/issues) page. You can leave feature requests there as well :) Our current goal is to get through our first major milestone, and after that we can look at bugs and features beyond the current roadmap.

## Can I contribute to Pyrefly?

Please see the: [contributing guidelines](https://github.com/facebook/pyrefly/blob/main/CONTRIBUTING.md).

## How do I know this project won't go unmaintained after a year?

Great question. We have made a substantial investment in Pyrefly, use it internally and aligned open source maintainability as a key principle for starting this project in the first place. We’re in it for the long haul. Using it is the best way to encourage further investment from our leadership.

## This is cool, I want to learn more about the technical details.

See our [README.md](https://github.com/facebook/pyrefly/blob/main/README.md) for the high level design. We plan to add more detailed documentation along with announcements on [https://engineering.fb.com](https://engineering.fb.com/)

## I don't like Python's Type System. Stop wasting your time.

Tell us more - seriously! We want to hear your objections to typing. We hope that better tooling, improvements to the type system and well typed libraries will help provide make development easier. If all else fails our fast code navigation and inference algorithm might spark joy in your IDE, so give us a chance.

_Curious about something else or just want to chat about bolting types onto Python, join us on [Discord](https://discord.gg/Cf7mFQtW7W)._


---

---
title: Typing Features and PEPS
description: Typing features and associated PEPs available in each Python version.
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

*Typing Features and PEPS available in each Python Version.*

| Feature (click PEP for details) | What it adds / looks like | Introduced in |
| --- | --- | --- |
| [PEP 484](https://peps.python.org/pep-0484/) -- Core **type hints** & `typing` module | `def add(a: int, b: int) -> int:` | **3.5** |
| [PEP 526](https://peps.python.org/pep-0526/) -- **Variable annotations** | `count: int = 0` | **3.6** |
| [PEP 563](https://peps.python.org/pep-0563/) -- `from __future__ import annotations` (lazy eval) | Annotations stored as **strings** | **3.7** (future‑flag) |
| [PEP 544](https://peps.python.org/pep-0544/) -- **Protocols** (structural typing) | `class Jsonable(Protocol): ...` | **3.8** |
| [PEP 589](https://peps.python.org/pep-0589/) -- **TypedDict** | `class User(TypedDict): ...` | **3.8** |
| [PEP 586](https://peps.python.org/pep-0586/) -- **Literal** types | `def log(level: Literal["info","warn"]): ...` | **3.8** |
| [PEP 591](https://peps.python.org/pep-0591/) -- **Final** qualifier | `TOKEN: Final[str] = "..."` | **3.8** |
| [PEP 585](https://peps.python.org/pep-0585/) -- **Built‑in generics** | `list[int]`, `dict[str, Any]` | **3.9** |
| [PEP 593](https://peps.python.org/pep-0593/) -- **Annotated** | `x: Annotated[int, "units=px"]` | **3.9** |
| [PEP 604](https://peps.python.org/pep-0604/) -- **Union** syntax | `int \| None` | **3.10** |
| [PEP 612](https://peps.python.org/pep-0612/) -- **ParamSpec / Concatenate** | decorator‑safe generics | **3.10** |
| [PEP 613](https://peps.python.org/pep-0613/) -- `TypeAlias` qualifier | `Vector: TypeAlias = list[float]` | **3.10** |
| [PEP 647](https://peps.python.org/pep-0647/) -- **TypeGuard** for narrowing | `def is_str(x) -> TypeGuard[str]: ...` | **3.10** |
| [PEP 655](https://peps.python.org/pep-0655/) -- `Required` / `NotRequired` for **TypedDict** | optional vs. mandatory keys | **3.11** |
| [PEP 646](https://peps.python.org/pep-0646/) -- **Variadic generics** (`TypeVarTuple`, `Unpack`) | tensor shapes, 2‑D arrays, ... | **3.11** |
| [PEP 673](https://peps.python.org/pep-0673/) -- **Self** type | fluent APIs: `def set(...) -> Self:` | **3.11** |
| [PEP 681](https://peps.python.org/pep-0681/) -- **dataclass_transform** helper | libraries like Pydantic, attrs | **3.11** |
| [PEP 695](https://peps.python.org/pep-0695/) -- **Class‑level generics syntax** | `class Box[T]: ...` | **3.12** |
| [PEP 698](https://peps.python.org/pep-0698/) -- `@override` decorator | flag intentional overrides | **3.13** |
| [PEP 649](https://peps.python.org/pep-0649/) -- *New* deferred‑eval algorithm (replaces PEP 563) | becomes the default | **3.14** |


---

---
title: Python Typing 101
description: A gentle, example‑driven introduction to static type hints in Python.
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

import CodeSnippet from '@site/src/sandbox/CodeSnippet'

# Python Typing 101

*A beginner‑friendly guide to adding type hints in Python.*

**Note:** This tutorial assumes you understand some basic Python syntax, but are new to programming with type hints. To learn more about Python, see the [Python Tutorial](https://docs.python.org/3/tutorial/) and [Getting Started Guide](https://www.python.org/about/gettingstarted/)

## 1. What is a Type?

A type is a classification that defines what operations can be performed on a piece of data, what values it can hold, and how it behaves in memory. Types are fundamental to programming because they help ensure that operations on data make sense.

For example:
- An `int` (integer) type can be added, subtracted, or multiplied
- A `str` (string) type can be concatenated or split
- A `list` type can be indexed, sliced, or iterated over

**Note:** These are just examples of common operations for each data type. Python's built-in types support many more operations that are not listed here.

Understanding types helps you predict how your code will behave and avoid runtime errors from trying to perform operations that don't make sense, such as dividing a string by a number.

## 2. What is a Type Hint in Python?

A type hint in Python is a way to indicate the expected data type of a variable, function parameter, or return value. It's a hint to other developers (and to tools like type checkers and IDEs) about what type of data should be used with a particular piece of code.

Type hints are **not enforced at runtime by Python itself,** but they can be used by third-party tools (like Pyrefly) to catch type-related errors before your code runs. They also serve as documentation, making it easier for others to understand how to use your code.
Here's an example of a simple function with type hints:

```
def greet(name: str) -> None:
    print(f"Hello, {name}!")
```

In this example:
- `name: str` indicates that the `name` parameter should be a string.
- `-> None` specifies that the function doesn't return any value (similar to `void` in other languages).

## 3. Why Bother with Type Hints?

Python is a dynamically typed language, which means you can write code without declaring types. However, this can lead to bugs or ambiguity in your code.

_TL;DR_
* Catch bugs **before** running the code.
* Improve editor autocomplete & refactors.
* Turn your code into living documentation.


<CodeSnippet
  sampleFilename="why_hints.py"
  codeSample={`# Without hints – is "times" a str, int, or list?
def repeat(text, times):
    return text * times

# With hints – intent is crystal clear.
def repeat(text: str, times: int) -> str:
    return text * times
`}
/>

In this example:
- The first function lacks type hints, making it unclear what types `text` and `times` should be. The `*` operator works differently depending on types (string repetition, list repetition, or multiplication).
- The second function uses type hints to clearly indicate that `text` should be a string, `times` should be an integer, and the function returns a string.
- This clarity helps prevent bugs like accidentally passing a string for `times` or using the function incorrectly.


### Can you spot the bug?

```
class Rectangle:
    width: int
    height: int

    def __init__(self, width: int, height: int) -> None:
        self.width = width
        self.height = height

rect = Rectangle(width=100, height=50)

area = rect.width * rect.hieght

print(area)
```

In this example:
- The bug is a typo in `rect.hieght` (should be `rect.height`).
- Without type hints, Python would only report this error at runtime when it tries to access the non-existent attribute.
- With type hints and a tool like Pyrefly, this error would be caught before running the code because the `Rectangle` class has defined attributes `width` and `height`, but not `hieght`.

**Spelling is hard!** Let's add the `dataclass` decorator to our class definition. This will generate a constructor for us, and also add a few other useful methods.

<CodeSnippet
  sampleFilename="misspelled.py"
  codeSample={`#Pyrefly will catch this spelling error before you run the code
from dataclasses import dataclass

@dataclass
class Rectangle:
    width: int
    height: int

rect = Rectangle(width=100, height=50)

area = rect.width * rect.hieght
`}
/>

In this dataclass example:
- The `@dataclass` decorator automatically generates methods like `__init__`, `__repr__`, and `__eq__` based on the class attributes.
- Type hints are used to define the class attributes (`width: int`, `height: int`).
- The same spelling error exists (`rect.hieght`), but tools like Pyrefly can catch this before runtime because the dataclass clearly defines which attributes exist.
- This demonstrates how type hints combined with dataclasses provide both convenience and better error detection.


## 4. Primitive Types

Since Python 3.9 you can use all the [primitive types](https://docs.python.org/3/library/stdtypes.html) directly as annotations.

<CodeSnippet
  sampleFilename="primitives_types.py"
  codeSample={`age: int = 30
height: float = 1.85
name: str = "Tyler Typer"
is_admin: bool = False
`}
/>

In this primitive types example:
- Each variable is annotated with its expected type (`int`, `float`, `str`, `bool`).
- The values assigned match their declared types.
- These annotations help document the code and allow type checkers to verify that operations on these variables are valid for their types.
- For example, a type checker would flag an error if you tried `age + name` since adding an integer and string isn't a valid operation.

You can also specify a parameter as optional by using `Optional` type, or now with the `| None` syntax.

<CodeSnippet
  sampleFilename="primitive2_types.py"
  codeSample={`# Optional typing example

from typing import Optional

middle_name: Optional[str] = None        # classic
nickname: str | None = None              # 3.10+ shorthand
`}
/>

In this Optional type example:
- Both variables can either be a string or `None`.
- `Optional[str]` is the traditional syntax (pre-Python 3.10).
- `str | None` is the newer union syntax introduced in Python 3.10.
- These annotations tell type checkers that the variable might be `None`, so they can warn you if you try to perform string operations without checking for `None` first.

## 5. Collections

### Syntax	Examples
- List of numbers	`list[int]	scores: list[int] = [98, 87, 91]`
- Tuple of two floats	`tuple[float, float]	point: tuple[float, float] = (3.0, 4.0)`
- Dict of str -> int	`dict[str, int]	inventory: dict[str, int] = {"apples": 5}`
- Set of strings	`set[str]	authors: set[str] = {"Bob", "Eve"}`

Since Python 3.9 you can subscript built‑ins directly—no need for `from typing import List`.

## 6. Functions
<CodeSnippet
  sampleFilename="basic_function_types.py"
  codeSample={`# Simple function
def add(a: int, b: int) -> int:
    return a + b
  `}
/>

In this basic function example:
- Both parameters `a` and `b` are annotated as integers.
- The function is annotated to return an integer (`-> int`).
- This tells type checkers that the function should only be called with integers and that the return value should only be used in contexts where an integer is expected.

Default values keep their annotation:

<CodeSnippet
  sampleFilename="default_value_types.py"
  codeSample={`# Function with default value


def greet(name: str, polite: bool = True) -> str:
    return "Hello!" if polite else f"Yo {name}"
    `}
/>

In this function with default values:
- The `name` parameter must be a string.
- The `polite` parameter is a boolean with a default value of `True`.
- The function returns a string.
- Even though `polite` has a default value, it still has a type annotation to ensure that if it's explicitly provided, it must be a boolean.

Variable‑length arguments:

<CodeSnippet
  sampleFilename="variable_length_types.py"
  codeSample={`# Variable length functions
from collections.abc import Callable

Logger = Callable[[str], None]

def debug(*msgs: str, log: Logger | None) -> None:
    for m in msgs:
      if log is not None:
        log(m)
      else:
        print(m)
  `}
/>

In this variable-length arguments example:
- `Logger` is defined as a type alias for a callable that takes a string and returns nothing (`None`).
- `*msgs: str` indicates that the function accepts any number of string arguments.
- `log: Logger | None` means the `log` parameter can be either a Logger function or `None`.
- The function is annotated to return `None`.
- This demonstrates how to type complex function signatures with variable arguments and function parameters.

## 7. Get Type Hint Signals Directly in Your Editor

You can download the [Pyrefly extension for VSCode](https://marketplace.visualstudio.com/items?itemName=meta.pyrefly) to get type hint signals directly in your IDE.

Next, install [Pyrefly](../installation/) and check some code:
```
# Fast, zero‑config
pip install pyrefly

pyrefly check ./my_sample.py

# Check whole directories
pyrefly check app/ tests/
```

Create a `pyrefly.toml` file to configure your project. Instructions [here](../configuration).


---

---
title: Report

description: Measure type coverage in your Python codebase with the Pyrefly report command.
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

# Pyrefly Report

Understanding how much of your codebase is annotated with types can help you track progress toward full type coverage. The `pyrefly report` command produces a machine-readable JSON report with information about functions, classes, and error suppressions in your code.

:::warning Experimental
This feature is experimental. The output format and behavior may change in future releases without notice.
:::

## Usage

Run `pyrefly report` on a file or directory:

```
pyrefly report path/to/file.py
pyrefly report path/to/directory/
```

The command outputs a JSON object keyed by file path. For each file, the report includes:

- **Line count** — the total number of lines in the file.
- **Functions** — every function and method, including its fully-qualified name, parameter annotations, and return annotation.
- **Classes** — every class, along with a list of incompletely-annotated attributes (including those inherited from base classes).
- **Suppressions** — every `# pyrefly: ignore[...]` comment, with the suppressed error codes.

You can pipe the output to other tools (e.g. `jq`) or ingest it into dashboards to track annotation coverage over time.


---

---
title: Typing for Python Developers

description: Get to know Python's Type System with working examples
---

{/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */}

import CodeSnippet from '@site/src/sandbox/CodeSnippet'

# Typing for Python Developers

*A 5‑Minute Tour with Pyrefly.*

**Goal:** In five minutes you'll know how Python's static type system _infers_, _defines_, and _composes_ types—and you'll have copy‑paste snippets to start using right away.

If you are new to Python typing, check out our [Python Typing 101 guide](../python-typing-for-beginners/).

Python's type system allows you to annotate variables so you, your teammates and your type checker can find bugs before you run your code. Think of it as documentation that's automatically validated and will help your IDE help you.

_TL;DR_
* Catch bugs **before** running the code.
* Improve editor autocomplete & refactors.
* Turn your code into living documentation.

### Types with Inference

Static analyzers can often _infer_ types from your code—no annotations required. Pyrefly takes this a step further.

<CodeSnippet
  sampleFilename="basic_inference.py"
  codeSample={`# Basic Inference
from typing import reveal_type

answer = 42
reveal_type(answer) # hover to reveal type

fruits = ["apple", "banana", "cherry"]
scores = {"math": 95, "science": 90}

def greet(name):
    return f"Hello, {name}!"

message = greet("World")
`}
/>

### Where Inference Shines ✨
- Constant assignments (`answer = 42 -> int`)
- List/tuple/dict literals with uniform elements (`names = ["A", "B"] -> list[str]`)
- Return types if parameter types are annotated:

<CodeSnippet
  sampleFilename="return_inference.py"
  codeSample={`def add(a: int, b: int):   # ✅ param annotations
    return a + b    # 🔍 return inferred -> int
`}
/>

### When to Add Hints
- Public APIs (library or service boundaries)
- Mixed collections (`list[int | str]`)
- Callable signatures (decorators, callbacks)

## Define Types Inline

### The Basics

Python's built-in types can be used to write many type hints.
<CodeSnippet
  sampleFilename="built_in_types.py"
  codeSample={`# Example: Basic Types

from typing import reveal_type

age: int = 5
reveal_type(age) # revealed type: int

age = "oops"

name: str = "John"
reveal_type(name) # revealed type: str

numbers: list[int] = [1, 2, 3]
reveal_type(numbers) # revealed type: list[int]

names: list[str] = ["John", "Jane"]
reveal_type(names) # revealed type: list[str]

person: dict[str, str] = {"name": "John", "age": "30"}
reveal_type(person) # revealed type: dict[str, str]

is_admin = True
reveal_type(is_admin) # revealed type: Literal[True]
`}
/>

### Functions
Defining the parameter and return types for a function doesn't just help prevent bugs, but it makes it easier to navigate in other files. You don't always need to define a return type - we'll do our best to infer it for you! We can't always get it right and an explicit return type will help your IDE navigate faster and more accurately.
<CodeSnippet
  sampleFilename="functions_types.py"
  codeSample={`# Example: Functions

from typing import reveal_type

def greet(name: str) -> str:
    return f"Hello, {name}!"

greet("Pyrefly")

def whatDoesThisFunctionReturnAgain(a: int, b: int):
    return a + b

reveal_type(whatDoesThisFunctionReturnAgain(2, 3)) # revealed type: int
`}
/>

## Advanced Types

### Composing Types
The real power comes from composing smaller pieces into richer shapes.

### Unions & Optional
<CodeSnippet
  sampleFilename="unions_types.py"
  codeSample={`# Union and Optional Types

from typing import Optional

def to_int(data: str | bytes | None) -> Optional[int]:
    if data is None:
        return None
    if isinstance(data, bytes):
        data = data.decode()
    return int(data)
`}
/>

### Generics

Generics allow you to define reusable functions and classes that work with multiple types. This feature enables you to write more flexible and adaptable code.

**Declaring Generic Classes:**
<CodeSnippet
  sampleFilename="generics.py"
  codeSample={`# Example: Generic Classes

from typing import reveal_type

class C[T]:
    def __init__(self, x: T):
        self.x = x
    def box(self) -> list[T]:
        return [self.x]

c = C(0)
reveal_type(c.box())  # revealed type: list[int]
`}
/>

**Declaring Type Statements:**
<CodeSnippet
  sampleFilename="type_statements.py"
  codeSample={`# Example: Type Statements
type ListOrSet[T:int] = list[T] | set[T]
`}
/>


**ParamSpec and TypeVarTuple:**
<CodeSnippet
  sampleFilename="param_spec_typevar_tuple.py"
  codeSample={`# Example: ParamSpec and TypeVarTuple
class ChildClass[T, *Ts, **P]: ...
`}
/>


### Variance Inference in Generics

When working with generics, a key question is: if one type is a subtype of another, does the subtyping relationship carry over to generic types?
For example, if `int` is a subtype of `float`, is `A[int]` also a subtype of `A[float]`?

This behavior is governed by variance:

- Covariant types preserve the direction of subtyping (`A[int]` is a subtype of `A[float]`).
- Contravariant types reverse it.
- Invariant types require an exact match.


Before [PEP 695](https://peps.python.org/pep-0695/), variance had to be declared manually and was often confusing.
Pyrefly infers the variance automatically based on how each type parameter is used - in method arguments, return values, attributes, and base classes.



**Example 1:** Covariance from Immutable Attributes (`Final`)


<CodeSnippet
  sampleFilename="variance1.py"
  codeSample={`# Example 1: Variance Inference

from typing import Final

class ShouldBeCovariant[T]:
    x: Final[T]

    def __init__(self, value: T):
        self.x = value


x1: ShouldBeCovariant[float] = ShouldBeCovariant[int](1)   # OK
x2: ShouldBeCovariant[int] = ShouldBeCovariant[float](1.0)  # ERROR!
`}
/>

**How Variance is Inferred:**

- The attribute `x` is annotated as `Final[T]`, making it immutable after initialization.
- Because `T` appears only in this read-only position, it is safe to infer `T` as covariant.
- This means:
  - You can assign `ShouldBeCovariant[int]` to a variable expecting `ShouldBeCovariant[float]` (since `int` is a subtype of `float`).
  - But the reverse is not allowed (`ShouldBeCovariant[float]` to `ShouldBeCovariant[int]`), which triggers a type error.


**Example 2:** General Variance Inference from Method and Base Class Usage

<CodeSnippet
  sampleFilename="variance2.py"
  codeSample={`# Example 2: Variance Inference

class ClassA[T1, T2, T3](list[T1]):
    def method1(self, a: T2) -> None:
        ...

    def method2(self) -> T3:
        ...

def func_a(p1: ClassA[float, int, int], p2: ClassA[int, float, float]):
    v1: ClassA[int, int, int] = p1  # ERROR!
    v2: ClassA[float, float, int] = p1  # ERROR!
    v3: ClassA[float, int, float] = p1  # OK

    v4: ClassA[int, int, int] = p2  # ERROR!
    v5: ClassA[int, int, float] = p2  # OK
`}
/>

**How Variance is Inferred:**
- `T1` appears in the base class `list[T1]`. Since list is mutable, `T1` is invariant.
- `T2` is used as the type of a method parameter (`a: T2`) so `T2` contravariant.
- `T3` is the return type of a method (`def method2() -> T3`) so `T3` is covariant.
- This means:
  - `v1` fails due to mismatched `T1` (invariant).
  - `v2` fails because `T2` expects a supertype, but gets a subtype.
  - `v4` fails because `T3` expects a subtype, but gets a supertype.

## Structural Types and Protocols
Python also employs a structural type system, often referred to as "duck typing." This concept is based on the idea that if two objects have the same shape or attributes, they can be treated as being of the same type.

### Dataclasses

Dataclasses allow you to create type-safe data structures while minimizing boilerplate.

<CodeSnippet
  sampleFilename="data_classes.py"
  codeSample={`# Example: Dataclasses

from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float

Point(x=0.0, y=0.0)    # OK
Point(x=0.0, y="oops") # ERROR!
`}
/>


### TypedDict

Typed dictionaries enable you to define dictionaries with specific key-value types. This feature lets you bring type safety to ad-hoc dictionary structures without major refactoring.

<CodeSnippet
  sampleFilename="typed_dict.py"
  codeSample={`# Example: TypedDict

from typing import TypedDict

class Movie(TypedDict):
    name: str
    year: int

good_movie: Movie = {"name": "Toy Story", "year": 1995} # OK
bad_movie: Movie = {"name": "The Room", "year": "2003"}  # ERROR!
`}
/>

### Overloads

Overloads allow you to define multiple function signatures for a single function. Like generics, this feature helps you write more flexible and adaptable code.

<CodeSnippet
  sampleFilename="overloads.py"
  codeSample={`# Example: Overloads

from typing import overload, reveal_type

@overload
def f(x: int) -> int: ...

@overload
def f(x: str) -> str: ...

def f(x: int | str) -> int | str:
    return x

reveal_type(f(0))  # revealed type: int
reveal_type(f("")) # revealed type: str
`}
/>

### Protocols

Protocols allows you to define interfaces without explicit inheritance. This feature helps you write more modular and composable code.

<CodeSnippet
  sampleFilename="protocols.py"
  codeSample={`# Example: Structural Typing with Protocols

from typing import Iterable, Protocol

class Writer(Protocol):
    def write(self) -> None: ...

class GoodWorld:
    def write(self) -> None:
        print("Hello world!")

class BadWorld:
    pass

def f(writer: Writer):
    pass

f(GoodWorld()) # OK
f(BadWorld())  # ERROR!
`}
/>

## Typing Features and PEPS available in each Python Version
See the full list of features available in the Python type system [here](../python-features-and-peps).

### Key Highlights Summary:
- **Inference:** Python's static analyzers can infer types from your code, reducing the need for explicit annotations. This feature enhances code readability and helps catch bugs early.
- **Defining Types:** You can define types inline using Python's built-in types, which aids in documentation and improves IDE support.
- **Advanced Types:** The guide covers advanced concepts like composing types, using unions and optionals, generics, protocols, and structural types like dataclasses and TypedDict.
- **Practical Examples:** The guide includes examples of functions, generic classes, structural typing with protocols, and more, demonstrating how to apply these concepts in real-world scenarios.
