"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[4702],{4702:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"pydantic","title":"Experimental Pydantic Support","description":"Pyrefly experimental support for Pydantic.","source":"@site/docs/pydantic.mdx","sourceDirName":".","slug":"/pydantic","permalink":"/en/docs/pydantic","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/pyrefly/edit/main/website/docs/pydantic.mdx","tags":[],"version":"current","frontMatter":{"title":"Experimental Pydantic Support","description":"Pyrefly experimental support for Pydantic."},"sidebar":"docsSidebar","previous":{"title":"Import Resolution","permalink":"/en/docs/import-resolution"},"next":{"title":"Automating Type Annotations","permalink":"/en/docs/autotype"}}');var s=n(74848),l=n(28453);const a={title:"Experimental Pydantic Support",description:"Pyrefly experimental support for Pydantic."},r="Experimental Pydantic Support",d={},o=[{value:"Feedback",id:"feedback",level:3},{value:"What is Pydantic?",id:"what-is-pydantic",level:2},{value:"Validation Modes",id:"validation-modes",level:2},{value:"How Pyrefly Supports Pydantic",id:"how-pyrefly-supports-pydantic",level:2},{value:"Comparison to Existing Tools",id:"comparison-to-existing-tools",level:2},{value:"How to Use",id:"how-to-use",level:2},{value:"Examples",id:"examples",level:2},{value:"Immutable fields with ConfigDict",id:"immutable-fields-with-configdict",level:3},{value:"Strict vs Non-Strict Field Validation",id:"strict-vs-non-strict-field-validation",level:3},{value:"Handling Extra Fields in Pydantic Models",id:"handling-extra-fields-in-pydantic-models",level:3}];function c(e){const i={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"experimental-pydantic-support",children:"Experimental Pydantic Support"})}),"\n",(0,s.jsxs)(i.p,{children:["Pyrefly includes ",(0,s.jsx)(i.strong,{children:"experimental support"})," for ",(0,s.jsx)(i.a,{href:"https://pydantic.dev/",children:"Pydantic"}),", a popular Python library for data validation and parsing. This feature aims to provide improved static type checking and IDE integration for Pydantic models."]}),"\n",(0,s.jsxs)(i.blockquote,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Note:"})," This support is experimental and actively evolving. The design may change based on feedback and development. Please note that we are supporting Pydantic v2 and above, which means that deprecated v1 features are not included."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"feedback",children:"Feedback"}),"\n",(0,s.jsxs)(i.p,{children:["We welcome your feedback and suggestions. Please share your thoughts and ideas ",(0,s.jsx)(i.a,{href:"https://github.com/facebook/pyrefly/issues/1078",children:"here"}),"."]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"what-is-pydantic",children:"What is Pydantic?"}),"\n",(0,s.jsx)(i.p,{children:"Pydantic is a Python library designed for data validation and parsing using Python type annotations. While it shares similarities with dataclasses in creating structured data containers, Pydantic additionally provides extensive runtime data validation."}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"validation-modes",children:"Validation Modes"}),"\n",(0,s.jsx)(i.p,{children:"Pydantic supports two validation modes for Pydantic models:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Lax (Default)"}),": Values are automatically converted when possible. For example, the string ",(0,s.jsx)(i.code,{children:'"123"'})," will be interpreted as an integer."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Strict"}),": Coercion is disabled, and only exactly matching types are accepted."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Pyrefly reads your model config to determine the validation mode, so it can strike a balance between providing useful typing and IDE support while maintaining Pydantic's flexibility."}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"how-pyrefly-supports-pydantic",children:"How Pyrefly Supports Pydantic"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Understands Pydantic constructs like ",(0,s.jsx)(i.code,{children:"BaseModel"}),", ",(0,s.jsx)(i.code,{children:"Field"}),", ",(0,s.jsx)(i.code,{children:"ConfigDict"}),", and model-level config options."]}),"\n",(0,s.jsx)(i.li,{children:"Performs static analysis that mirrors Pydantic\u2019s runtime validation logic, minimizing false positives in your IDE."}),"\n",(0,s.jsx)(i.li,{children:"Provides immediate feedback (e.g. red squiggles or type errors) when the code would fail under Pydantic's actual behavior."}),"\n",(0,s.jsxs)(i.li,{children:["Does ",(0,s.jsx)(i.strong,{children:"not"})," require a plugin or manual config \u2014 support is builtin and automatic."]}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"comparison-to-existing-tools",children:"Comparison to Existing Tools"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.a,{href:"https://docs.pydantic.dev/1.10/mypy_plugin/",children:"Mypy\u2019s Pydantic plugin"})," has five configuration options to control how strict the checking is \u2014 for example, whether coercion is allowed or extra fields are permitted.\n",(0,s.jsx)(i.strong,{children:"Pyrefly works differently"}),". It doesn't rely on external config. Instead, it inspects your code directly \u2014 things like ",(0,s.jsx)(i.code,{children:"strict=True"})," or ",(0,s.jsx)(i.code,{children:"extra='forbid'"})," and strikes a balance between Pydantic's flexibility and Pyrefly's type checking."]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"how-to-use",children:"How to Use"}),"\n",(0,s.jsx)(i.p,{children:"You don\u2019t need to enable or configure anything to use Pyrefly\u2019s Pydantic support."}),"\n",(0,s.jsx)(i.p,{children:"Just:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["Install ",(0,s.jsx)(i.code,{children:"pydantic"})," (preferably v2)."]}),"\n",(0,s.jsxs)(i.li,{children:["Install ",(0,s.jsx)(i.code,{children:"pyrefly"})," (version 0.33.0 or later)."]}),"\n",(0,s.jsx)(i.li,{children:"Write your Pydantic models as usual."}),"\n",(0,s.jsx)(i.li,{children:"Run Pyrefly on your code."}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["Pyrefly will recognize Pydantic constructs like ",(0,s.jsx)(i.code,{children:"BaseModel"}),", ",(0,s.jsx)(i.code,{children:"Field"}),", and ",(0,s.jsx)(i.code,{children:"model_config"}),", and provide appropriate type checking automatically. You can follow ",(0,s.jsx)(i.a,{href:"https://github.com/migeed-z/pyrefly-pydantic-demo",children:"this link"})," to try it out on some small examples."]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(i.h3,{id:"immutable-fields-with-configdict",children:"Immutable fields with ConfigDict"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from pydantic import BaseModel, ConfigDict\n\n# Marking a model as frozen (immutable)\nclass Model(BaseModel):\n    model_config = ConfigDict(frozen=True)\n    x: int = 42\nm = Model()\nm.x = 10  # Error: Cannot set field `x` because the model is frozen\n"})}),"\n",(0,s.jsx)(i.h3,{id:"strict-vs-non-strict-field-validation",children:"Strict vs Non-Strict Field Validation"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from pydantic import BaseModel, Field\n\n# Non-strict mode: runtime coercion allowed\nclass User(BaseModel):\n    name: str\n    age: int\n\n# This passes at runtime and in Pyrefly.\ny = User(name="Alice", age="30")\n\n# Strict mode: enforce exact types, no coercion\nclass User2(BaseModel):\n    name: str\n    age: int = Field(strict=True)\n\n# This triggers type errors in Pyrefly and red squiggles in the IDE,\n# and will also fail at runtime due to type mismatch.\nz = User2(name="Alice", age="30")\n'})}),"\n",(0,s.jsx)(i.h3,{id:"handling-extra-fields-in-pydantic-models",children:"Handling Extra Fields in Pydantic Models"}),"\n",(0,s.jsxs)(i.p,{children:["By default, Pydantic models allow extra fields (fields not defined in the model) to be passed during initialization. This behavior is consistent with Pyrefly\u2019s support, which follows the default ",(0,s.jsx)(i.code,{children:"extra='allow'"})," behavior."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from pydantic import BaseModel\n\n# Extra fields allowed by default\nclass ModelAllow(BaseModel):\n    x: int\n\n# This works fine: extra field `y` is allowed and ignored\nModelAllow(x=1, y=2)\n\n# Explicitly forbid extra fields by setting `extra='forbid'`\nclass ModelForbid(BaseModel, extra=\"forbid\"):\n    x: int\n\n# This will raise a type error because of unexpected field `y`, which is consistent with runtime behavior.\nModelForbid(x=1, y=2)\n"})})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);