"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[4702],{4702(e,n,i){i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"pydantic","title":"Experimental Pydantic Support","description":"Pyrefly experimental support for Pydantic.","source":"@site/docs/pydantic.mdx","sourceDirName":".","slug":"/pydantic","permalink":"/en/docs/pydantic","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/pyrefly/edit/main/website/docs/pydantic.mdx","tags":[],"version":"current","frontMatter":{"title":"Experimental Pydantic Support","description":"Pyrefly experimental support for Pydantic."},"sidebar":"docsSidebar","previous":{"title":"IDE Supported Features","permalink":"/en/docs/IDE-features"},"next":{"title":"Lax Mode Type Conversions","permalink":"/en/docs/pydantic-lax-conversions"}}');var o=i(74848),s=i(28453);const l={title:"Experimental Pydantic Support",description:"Pyrefly experimental support for Pydantic."},a="Experimental Pydantic Support",r={},d=[{value:"Feedback",id:"feedback",level:3},{value:"What is Pydantic?",id:"what-is-pydantic",level:2},{value:"How Pyrefly Supports Pydantic",id:"how-pyrefly-supports-pydantic",level:2},{value:"Validation Modes",id:"validation-modes",level:2},{value:"How Lax Mode Works in Pyrefly",id:"how-lax-mode-works-in-pyrefly",level:3},{value:"Comparison to Existing Tools",id:"comparison-to-existing-tools",level:2},{value:"How to Use",id:"how-to-use",level:2},{value:"Supported Features with Examples",id:"supported-features-with-examples",level:2},{value:"Immutable fields with ConfigDict",id:"immutable-fields-with-configdict",level:3},{value:"Strict vs Non-Strict Field Validation",id:"strict-vs-non-strict-field-validation",level:3},{value:"Handling Extra Fields in Pydantic Models",id:"handling-extra-fields-in-pydantic-models",level:3},{value:"Handling field constraints",id:"handling-field-constraints",level:3},{value:"Root Models",id:"root-models",level:3},{value:"Alias validation",id:"alias-validation",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:["\n",(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"experimental-pydantic-support",children:"Experimental Pydantic Support"})}),"\n",(0,o.jsxs)(n.p,{children:["Pyrefly includes ",(0,o.jsx)(n.strong,{children:"experimental support"})," for ",(0,o.jsx)(n.a,{href:"https://pydantic.dev/",children:"Pydantic"}),", a popular Python library for data validation and parsing. This feature aims to provide improved static type checking and IDE integration for Pydantic models."]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Note:"})," This support is experimental and actively evolving. The design may change based on feedback and development. Please note that we are supporting Pydantic v2 and above, which means that deprecated v1 features are not included."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"feedback",children:"Feedback"}),"\n",(0,o.jsxs)(n.p,{children:["We welcome your feedback and suggestions. Please share your thoughts and ideas ",(0,o.jsx)(n.a,{href:"https://github.com/facebook/pyrefly/issues/1078",children:"here"}),"."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"what-is-pydantic",children:"What is Pydantic?"}),"\n",(0,o.jsx)(n.p,{children:"Pydantic is a Python library designed for data validation and parsing using Python type annotations. While it shares similarities with dataclasses in creating structured data containers, Pydantic additionally provides extensive runtime data validation."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"how-pyrefly-supports-pydantic",children:"How Pyrefly Supports Pydantic"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Understands Pydantic constructs like ",(0,o.jsx)(n.code,{children:"BaseModel"}),", ",(0,o.jsx)(n.code,{children:"Field"}),", ",(0,o.jsx)(n.code,{children:"ConfigDict"}),", and model-level config options."]}),"\n",(0,o.jsx)(n.li,{children:"Performs static analysis that mirrors Pydantic's runtime validation logic, minimizing false positives in your IDE."}),"\n",(0,o.jsx)(n.li,{children:"Provides immediate feedback (e.g. red squiggles or type errors) when the code would fail under Pydantic's actual behavior."}),"\n",(0,o.jsxs)(n.li,{children:["Does ",(0,o.jsx)(n.strong,{children:"not"})," require a plugin or manual config \u2014 support is builtin and automatic."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"validation-modes",children:"Validation Modes"}),"\n",(0,o.jsx)(n.p,{children:"Pydantic models can use two validation modes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Lax (Default)"}),": Values are automatically coerced when possible. For example, a string like ",(0,o.jsx)(n.code,{children:'"123"'})," can be coerced to an integer."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Strict"}),": Coercion is disabled, and only exactly matching types are accepted."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Pyrefly reads your model config to determine the validation mode, so it can strike a balance between providing useful typing and IDE support while maintaining Pydantic's flexibility."}),"\n",(0,o.jsx)(n.h3,{id:"how-lax-mode-works-in-pyrefly",children:"How Lax Mode Works in Pyrefly"}),"\n",(0,o.jsxs)(n.p,{children:["In lax mode (the default), Pyrefly uses ",(0,o.jsx)(n.strong,{children:"named union types"})," to represent the acceptable input types for each field. These named unions keep type signatures concise and readable while closely reflecting Pydantic's runtime coercion behavior."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, when you define a field with type ",(0,o.jsx)(n.code,{children:"int"})," in lax mode, Pyrefly represents it as ",(0,o.jsx)(n.code,{children:"LaxInt"}),", which is equivalent to ",(0,o.jsx)(n.code,{children:"int | bool | float | str | bytes | Decimal"})," (based on ",(0,o.jsx)(n.a,{href:"https://docs.pydantic.dev/latest/concepts/conversion_table/",children:"Pydantic's conversion table"}),"):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from pydantic import BaseModel\nfrom typing import reveal_type\nfrom decimal import Decimal\n\nclass Model(BaseModel):\n    x: int = 0\n\nreveal_type(Model.__init__)  # revealed type is (self: Model, *, x: LaxInt = ..., **Unknown) -> None\n\n# int field accepts: int, bool, float, str, bytes, Decimal\nModel(x=1)\nModel(x=True)\nModel(x=1.0)\nModel(x='123')\nModel(x=b'123')\nModel(x=Decimal('123'))\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Note:"})," Pyrefly applies named unions (like ",(0,o.jsx)(n.code,{children:"LaxInt"}),") to atomic types and recursively to nested types. Container types are converted to more general types to handle variance: for example, ",(0,o.jsx)(n.code,{children:"list[int]"})," becomes ",(0,o.jsx)(n.code,{children:"Iterable[LaxInt]"}),". When you use union types (e.g., ",(0,o.jsx)(n.code,{children:"int | bool"}),"), each member is expanded individually and then flattened into a regular union."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["For a complete reference of all type conversions in lax mode, see the ",(0,o.jsx)(n.a,{href:"../pydantic-lax-conversions",children:"Lax Mode Type Conversions"})," page."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"comparison-to-existing-tools",children:"Comparison to Existing Tools"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"https://docs.pydantic.dev/1.10/mypy_plugin/",children:"Mypy\u2019s Pydantic plugin"})," has five configuration options to control how strict the checking is \u2014 for example, whether coercion is allowed or extra fields are permitted.\n",(0,o.jsx)(n.strong,{children:"Pyrefly works differently"}),". It doesn't rely on external config. Instead, it inspects your code directly \u2014 things like ",(0,o.jsx)(n.code,{children:"strict=True"})," or ",(0,o.jsx)(n.code,{children:"extra='forbid'"})," and strikes a balance between Pydantic's flexibility and Pyrefly's type checking."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"how-to-use",children:"How to Use"}),"\n",(0,o.jsx)(n.p,{children:"You don\u2019t need to enable or configure anything to use Pyrefly\u2019s Pydantic support."}),"\n",(0,o.jsx)(n.p,{children:"Just:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Install ",(0,o.jsx)(n.code,{children:"pydantic"})," (preferably v2)."]}),"\n",(0,o.jsxs)(n.li,{children:["Install ",(0,o.jsx)(n.code,{children:"pyrefly"})," (version 0.33.0 or later)."]}),"\n",(0,o.jsx)(n.li,{children:"Write your Pydantic models as usual."}),"\n",(0,o.jsx)(n.li,{children:"Run Pyrefly on your code."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Pyrefly will recognize Pydantic constructs like ",(0,o.jsx)(n.code,{children:"BaseModel"}),", ",(0,o.jsx)(n.code,{children:"Field"}),", and ",(0,o.jsx)(n.code,{children:"model_config"}),", and provide appropriate type checking automatically. You can follow ",(0,o.jsx)(n.a,{href:"https://github.com/migeed-z/pyrefly-pydantic-demo",children:"this link"})," to try it out on some small examples."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"supported-features-with-examples",children:"Supported Features with Examples"}),"\n",(0,o.jsx)(n.p,{children:"The following examples showcase which Pydantic features are currently supported by Pyrefly. Pyrefly does not cover all Pydantic features, but these features should provide good coverage of the most common Pydantic use cases. You can request additional Pydantic features to be supported by opening a GitHub issue."}),"\n",(0,o.jsx)(n.h3,{id:"immutable-fields-with-configdict",children:"Immutable fields with ConfigDict"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from pydantic import BaseModel, ConfigDict\n\n# Marking a model as frozen (immutable)\nclass Model(BaseModel):\n    model_config = ConfigDict(frozen=True)\n    x: int = 42\nm = Model()\nm.x = 10  # Error: Cannot set field `x` because the model is frozen\n"})}),"\n",(0,o.jsx)(n.h3,{id:"strict-vs-non-strict-field-validation",children:"Strict vs Non-Strict Field Validation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'from pydantic import BaseModel, Field\n\n# Lax mode (default): runtime coercion allowed\nclass User(BaseModel):\n    name: str\n    age: int\n\n# This passes at runtime and in Pyrefly because age accepts strings in lax mode\ny = User(name="Alice", age="30")\n\n# Strict mode: enforce exact types, no coercion\nclass User2(BaseModel):\n    name: str\n    age: int = Field(strict=True)\n\n# This triggers type errors in Pyrefly and red squiggles in the IDE,\n# and will also fail at runtime due to type mismatch.\nz = User2(name="Alice", age="30")  # Error: age expects int, not str\n'})}),"\n",(0,o.jsx)(n.h3,{id:"handling-extra-fields-in-pydantic-models",children:"Handling Extra Fields in Pydantic Models"}),"\n",(0,o.jsxs)(n.p,{children:["By default, Pydantic models allow extra fields (fields not defined in the model) to be passed during initialization. This behavior is consistent with Pyrefly\u2019s support, which follows the default ",(0,o.jsx)(n.code,{children:"extra='allow'"})," behavior."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from pydantic import BaseModel\n\n# Extra fields allowed by default\nclass ModelAllow(BaseModel):\n    x: int\n\n# This works fine: extra field `y` is allowed and ignored\nModelAllow(x=1, y=2)\n\n# Explicitly forbid extra fields by setting `extra='forbid'`\nclass ModelForbid(BaseModel, extra=\"forbid\"):\n    x: int\n\n# This will raise a type error because of unexpected field `y`, which is consistent with runtime behavior.\nModelForbid(x=1, y=2)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"handling-field-constraints",children:"Handling field constraints"}),"\n",(0,o.jsx)(n.p,{children:"Pyrefly provides limited support for range constraints on fields."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from pydantic import BaseModel, Field\n\nclass Model(BaseModel):\n    x: int = Field(gt=0, lt=10)\n\nModel(x=5)   # OK\nModel(x=0)   # Error: Argument value `Literal[0]` violates Pydantic `gt` constraint for field `x`\nModel(x=15)  # Error: Argument value `Literal[15]` violates Pydantic `lt` constraint for field `x`\n"})}),"\n",(0,o.jsx)(n.h3,{id:"root-models",children:"Root Models"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'from pydantic import RootModel, StrictInt\n\nclass IntRootModel(RootModel[int]):\n   pass\n\nclass StrictIntRootModel(RootModel[StrictInt]):\n   pass\n\nm1 = IntRootModel(123)  # OK\nm2 = IntRootModel("123") # OK - lax mode allows string-to-int coercion\nm3 = StrictIntRootModel("123")  # Error: StrictInt doesn\'t allow coercion\n'})}),"\n",(0,o.jsx)(n.h3,{id:"alias-validation",children:"Alias validation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from pydantic import BaseModel, Field\n\nclass Model(BaseModel, validate_by_name=True, validate_by_alias=True):\n    x: int = Field(alias='y')\n\n# both `x` and `y` are valid aliases\nModel(x=0)\nModel(y=0)\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453(e,n,i){i.d(n,{R:()=>l,x:()=>a});var t=i(96540);const o={},s=t.createContext(o);function l(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);