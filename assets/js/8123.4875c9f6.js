(()=>{"use strict";var __webpack_modules__={97187:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{p:()=>loadPyodide});const out=eval('const module={exports:{}};\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. "__esModule" has not been set), then set\n  // "default" to the CommonJS "module.exports" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\nvar stdin_exports = {};\n__export(stdin_exports, {\n  loadPyodide: () => $e,\n  version: () => M\n});\nmodule.exports = __toCommonJS(stdin_exports);\nvar Q = Object.defineProperty;\nvar s = (e, t) => Q(e, "name", { value: t, configurable: true }), R = ((e) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, { get: (t, o) => (typeof require < "u" ? require : t)[o] }) : e)(function(e) {\n  if (typeof require < "u")\n    return require.apply(this, arguments);\n  throw new Error(\'Dynamic require of "\' + e + \'" is not supported\');\n});\nfunction Z(e) {\n  return !isNaN(parseFloat(e)) && isFinite(e);\n}\ns(Z, "_isNumber");\nfunction E(e) {\n  return e.charAt(0).toUpperCase() + e.substring(1);\n}\ns(E, "_capitalize");\nfunction x(e) {\n  return function() {\n    return this[e];\n  };\n}\ns(x, "_getter");\nvar w = ["isConstructor", "isEval", "isNative", "isToplevel"], N = ["columnNumber", "lineNumber"], _ = ["fileName", "functionName", "source"], ee = ["args"], te = ["evalOrigin"], P = w.concat(N, _, ee, te);\nfunction p(e) {\n  if (e)\n    for (var t = 0; t < P.length; t++)\n      e[P[t]] !== void 0 && this["set" + E(P[t])](e[P[t]]);\n}\ns(p, "StackFrame");\np.prototype = { getArgs: function() {\n  return this.args;\n}, setArgs: function(e) {\n  if (Object.prototype.toString.call(e) !== "[object Array]")\n    throw new TypeError("Args must be an Array");\n  this.args = e;\n}, getEvalOrigin: function() {\n  return this.evalOrigin;\n}, setEvalOrigin: function(e) {\n  if (e instanceof p)\n    this.evalOrigin = e;\n  else if (e instanceof Object)\n    this.evalOrigin = new p(e);\n  else\n    throw new TypeError("Eval Origin must be an Object or StackFrame");\n}, toString: function() {\n  var e = this.getFileName() || "", t = this.getLineNumber() || "", o = this.getColumnNumber() || "", r = this.getFunctionName() || "";\n  return this.getIsEval() ? e ? "[eval] (" + e + ":" + t + ":" + o + ")" : "[eval]:" + t + ":" + o : r ? r + " (" + e + ":" + t + ":" + o + ")" : e + ":" + t + ":" + o;\n} };\np.fromString = s(function(t) {\n  var o = t.indexOf("("), r = t.lastIndexOf(")"), a = t.substring(0, o), n = t.substring(o + 1, r).split(","), i = t.substring(r + 1);\n  if (i.indexOf("@") === 0)\n    var c = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(i, ""), l = c[1], d = c[2], u = c[3];\n  return new p({ functionName: a, args: n || void 0, fileName: l, lineNumber: d || void 0, columnNumber: u || void 0 });\n}, "StackFrame$$fromString");\nfor (b = 0; b < w.length; b++)\n  p.prototype["get" + E(w[b])] = x(w[b]), p.prototype["set" + E(w[b])] = /* @__PURE__ */ function(e) {\n    return function(t) {\n      this[e] = !!t;\n    };\n  }(w[b]);\nvar b;\nfor (v = 0; v < N.length; v++)\n  p.prototype["get" + E(N[v])] = x(N[v]), p.prototype["set" + E(N[v])] = /* @__PURE__ */ function(e) {\n    return function(t) {\n      if (!Z(t))\n        throw new TypeError(e + " must be a Number");\n      this[e] = Number(t);\n    };\n  }(N[v]);\nvar v;\nfor (h = 0; h < _.length; h++)\n  p.prototype["get" + E(_[h])] = x(_[h]), p.prototype["set" + E(_[h])] = /* @__PURE__ */ function(e) {\n    return function(t) {\n      this[e] = String(t);\n    };\n  }(_[h]);\nvar h, k = p;\nfunction ne() {\n  var e = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m, t = /^(eval@)?(\\[native code])?$/;\n  return { parse: s(function(r) {\n    if (r.stack && r.stack.match(e))\n      return this.parseV8OrIE(r);\n    if (r.stack)\n      return this.parseFFOrSafari(r);\n    throw new Error("Cannot parse given Error object");\n  }, "ErrorStackParser$$parse"), extractLocation: s(function(r) {\n    if (r.indexOf(":") === -1)\n      return [r];\n    var a = /(.+?)(?::(\\d+))?(?::(\\d+))?$/, n = a.exec(r.replace(/[()]/g, ""));\n    return [n[1], n[2] || void 0, n[3] || void 0];\n  }, "ErrorStackParser$$extractLocation"), parseV8OrIE: s(function(r) {\n    var a = r.stack.split(`\n`).filter(function(n) {\n      return !!n.match(e);\n    }, this);\n    return a.map(function(n) {\n      n.indexOf("(eval ") > -1 && (n = n.replace(/eval code/g, "eval").replace(/(\\(eval at [^()]*)|(,.*$)/g, ""));\n      var i = n.replace(/^\\s+/, "").replace(/\\(eval code/g, "(").replace(/^.*?\\s+/, ""), c = i.match(/ (\\(.+\\)$)/);\n      i = c ? i.replace(c[0], "") : i;\n      var l = this.extractLocation(c ? c[1] : i), d = c && i || void 0, u = ["eval", "<anonymous>"].indexOf(l[0]) > -1 ? void 0 : l[0];\n      return new k({ functionName: d, fileName: u, lineNumber: l[1], columnNumber: l[2], source: n });\n    }, this);\n  }, "ErrorStackParser$$parseV8OrIE"), parseFFOrSafari: s(function(r) {\n    var a = r.stack.split(`\n`).filter(function(n) {\n      return !n.match(t);\n    }, this);\n    return a.map(function(n) {\n      if (n.indexOf(" > eval") > -1 && (n = n.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ":$1")), n.indexOf("@") === -1 && n.indexOf(":") === -1)\n        return new k({ functionName: n });\n      var i = /((.*".+"[^@]*)?[^@]*)(?:@)/, c = n.match(i), l = c && c[1] ? c[1] : void 0, d = this.extractLocation(n.replace(i, ""));\n      return new k({ functionName: l, fileName: d[0], lineNumber: d[1], columnNumber: d[2], source: n });\n    }, this);\n  }, "ErrorStackParser$$parseFFOrSafari") };\n}\ns(ne, "ErrorStackParser");\nvar re = new ne();\nvar C = re;\nvar g = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && !process.browser, A = g && typeof module < "u" && typeof module.exports < "u" && typeof R < "u" && typeof __dirname < "u", W = g && !A, Ne = typeof globalThis.Bun < "u", ie = typeof Deno < "u", B = !g && !ie, $ = B && typeof window == "object" && typeof document == "object" && typeof document.createElement == "function" && "sessionStorage" in window && typeof importScripts != "function", j = B && typeof importScripts == "function" && typeof self == "object", _e = typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome") == -1 && navigator.userAgent.indexOf("Safari") > -1;\nvar z, D, V, H, L;\nasync function T() {\n  if (!g || (z = (await import("node:url")).default, H = await import("node:fs"), L = await import("node:fs/promises"), V = (await import("node:vm")).default, D = await import("node:path"), U = D.sep, typeof R < "u"))\n    return;\n  let e = H, t = await import("node:crypto"), o = await import("ws"), r = await import("node:child_process"), a = { fs: e, crypto: t, ws: o, child_process: r };\n  ({});\n}\ns(T, "initNodeModules");\nfunction oe(e, t) {\n  return D.resolve(t || ".", e);\n}\ns(oe, "node_resolvePath");\nfunction ae(e, t) {\n  return t === void 0 && (t = location), new URL(e, t).toString();\n}\ns(ae, "browser_resolvePath");\nvar O;\ng ? O = oe : O = ae;\nvar U;\ng || (U = "/");\nfunction se(e, t) {\n  return e.startsWith("file://") && (e = e.slice(7)), e.includes("://") ? { response: fetch(e) } : { binary: L.readFile(e).then((o) => new Uint8Array(o.buffer, o.byteOffset, o.byteLength)) };\n}\ns(se, "node_getBinaryResponse");\nfunction ce(e, t) {\n  let o = new URL(e, location);\n  return { response: fetch(o, t ? { integrity: t } : {}) };\n}\ns(ce, "browser_getBinaryResponse");\nvar F;\ng ? F = se : F = ce;\nasync function q(e, t) {\n  let { response: o, binary: r } = F(e, t);\n  if (r)\n    return r;\n  let a = await o;\n  if (!a.ok)\n    throw new Error(`Failed to load \'${e}\': request failed.`);\n  return new Uint8Array(await a.arrayBuffer());\n}\ns(q, "loadBinaryFile");\nvar I;\nif ($)\n  I = s(async (e) => await import(e), "loadScript");\nelse if (j)\n  I = s(async (e) => {\n    try {\n      globalThis.importScripts(e);\n    } catch (t) {\n      if (t instanceof TypeError)\n        await import(e);\n      else\n        throw t;\n    }\n  }, "loadScript");\nelse if (g)\n  I = le;\nelse\n  throw new Error("Cannot determine runtime environment");\nasync function le(e) {\n  e.startsWith("file://") && (e = e.slice(7)), e.includes("://") ? V.runInThisContext(await (await fetch(e)).text()) : await import(z.pathToFileURL(e).href);\n}\ns(le, "nodeLoadScript");\nasync function J(e) {\n  if (g) {\n    await T();\n    let t = await L.readFile(e, { encoding: "utf8" });\n    return JSON.parse(t);\n  } else\n    return await (await fetch(e)).json();\n}\ns(J, "loadLockFile");\nasync function K() {\n  if (A)\n    return __dirname;\n  let e;\n  try {\n    throw new Error();\n  } catch (r) {\n    e = r;\n  }\n  let t = C.parse(e)[0].fileName;\n  if (g && !t.startsWith("file://") && (t = `file://${t}`), W) {\n    let r = await import("node:path");\n    return (await import("node:url")).fileURLToPath(r.dirname(t));\n  }\n  let o = t.lastIndexOf(U);\n  if (o === -1)\n    throw new Error("Could not extract indexURL path from pyodide module location");\n  return t.slice(0, o);\n}\ns(K, "calculateDirname");\nfunction Y(e) {\n  let t = e.FS, o = e.FS.filesystems.MEMFS, r = e.PATH, a = { DIR_MODE: 16895, FILE_MODE: 33279, mount: function(n) {\n    if (!n.opts.fileSystemHandle)\n      throw new Error("opts.fileSystemHandle is required");\n    return o.mount.apply(null, arguments);\n  }, syncfs: async (n, i, c) => {\n    try {\n      let l = a.getLocalSet(n), d = await a.getRemoteSet(n), u = i ? d : l, m = i ? l : d;\n      await a.reconcile(n, u, m), c(null);\n    } catch (l) {\n      c(l);\n    }\n  }, getLocalSet: (n) => {\n    let i = /* @__PURE__ */ Object.create(null);\n    function c(u) {\n      return u !== "." && u !== "..";\n    }\n    s(c, "isRealDir");\n    function l(u) {\n      return (m) => r.join2(u, m);\n    }\n    s(l, "toAbsolute");\n    let d = t.readdir(n.mountpoint).filter(c).map(l(n.mountpoint));\n    for (; d.length; ) {\n      let u = d.pop(), m = t.stat(u);\n      t.isDir(m.mode) && d.push.apply(d, t.readdir(u).filter(c).map(l(u))), i[u] = { timestamp: m.mtime, mode: m.mode };\n    }\n    return { type: "local", entries: i };\n  }, getRemoteSet: async (n) => {\n    let i = /* @__PURE__ */ Object.create(null), c = await de(n.opts.fileSystemHandle);\n    for (let [l, d] of c)\n      l !== "." && (i[r.join2(n.mountpoint, l)] = { timestamp: d.kind === "file" ? new Date((await d.getFile()).lastModified) : /* @__PURE__ */ new Date(), mode: d.kind === "file" ? a.FILE_MODE : a.DIR_MODE });\n    return { type: "remote", entries: i, handles: c };\n  }, loadLocalEntry: (n) => {\n    let c = t.lookupPath(n).node, l = t.stat(n);\n    if (t.isDir(l.mode))\n      return { timestamp: l.mtime, mode: l.mode };\n    if (t.isFile(l.mode))\n      return c.contents = o.getFileDataAsTypedArray(c), { timestamp: l.mtime, mode: l.mode, contents: c.contents };\n    throw new Error("node type not supported");\n  }, storeLocalEntry: (n, i) => {\n    if (t.isDir(i.mode))\n      t.mkdirTree(n, i.mode);\n    else if (t.isFile(i.mode))\n      t.writeFile(n, i.contents, { canOwn: true });\n    else\n      throw new Error("node type not supported");\n    t.chmod(n, i.mode), t.utime(n, i.timestamp, i.timestamp);\n  }, removeLocalEntry: (n) => {\n    var i = t.stat(n);\n    t.isDir(i.mode) ? t.rmdir(n) : t.isFile(i.mode) && t.unlink(n);\n  }, loadRemoteEntry: async (n) => {\n    if (n.kind === "file") {\n      let i = await n.getFile();\n      return { contents: new Uint8Array(await i.arrayBuffer()), mode: a.FILE_MODE, timestamp: new Date(i.lastModified) };\n    } else {\n      if (n.kind === "directory")\n        return { mode: a.DIR_MODE, timestamp: /* @__PURE__ */ new Date() };\n      throw new Error("unknown kind: " + n.kind);\n    }\n  }, storeRemoteEntry: async (n, i, c) => {\n    let l = n.get(r.dirname(i)), d = t.isFile(c.mode) ? await l.getFileHandle(r.basename(i), { create: true }) : await l.getDirectoryHandle(r.basename(i), { create: true });\n    if (d.kind === "file") {\n      let u = await d.createWritable();\n      await u.write(c.contents), await u.close();\n    }\n    n.set(i, d);\n  }, removeRemoteEntry: async (n, i) => {\n    await n.get(r.dirname(i)).removeEntry(r.basename(i)), n.delete(i);\n  }, reconcile: async (n, i, c) => {\n    let l = 0, d = [];\n    Object.keys(i.entries).forEach(function(f) {\n      let y = i.entries[f], S = c.entries[f];\n      (!S || t.isFile(y.mode) && y.timestamp.getTime() > S.timestamp.getTime()) && (d.push(f), l++);\n    }), d.sort();\n    let u = [];\n    if (Object.keys(c.entries).forEach(function(f) {\n      i.entries[f] || (u.push(f), l++);\n    }), u.sort().reverse(), !l)\n      return;\n    let m = i.type === "remote" ? i.handles : c.handles;\n    for (let f of d) {\n      let y = r.normalize(f.replace(n.mountpoint, "/")).substring(1);\n      if (c.type === "local") {\n        let S = m.get(y), X = await a.loadRemoteEntry(S);\n        a.storeLocalEntry(f, X);\n      } else {\n        let S = a.loadLocalEntry(f);\n        await a.storeRemoteEntry(m, y, S);\n      }\n    }\n    for (let f of u)\n      if (c.type === "local")\n        a.removeLocalEntry(f);\n      else {\n        let y = r.normalize(f.replace(n.mountpoint, "/")).substring(1);\n        await a.removeRemoteEntry(m, y);\n      }\n  } };\n  e.FS.filesystems.NATIVEFS_ASYNC = a;\n}\ns(Y, "initializeNativeFS");\nvar de = s(async (e) => {\n  let t = [];\n  async function o(a) {\n    for await (let n of a.values())\n      t.push(n), n.kind === "directory" && await o(n);\n  }\n  s(o, "collect"), await o(e);\n  let r = /* @__PURE__ */ new Map();\n  r.set(".", e);\n  for (let a of t) {\n    let n = (await e.resolve(a)).join("/");\n    r.set(n, a);\n  }\n  return r;\n}, "getFsHandles");\nfunction G(e) {\n  let t = { noImageDecoding: true, noAudioDecoding: true, noWasmDecoding: false, preRun: ge(e), quit(o, r) {\n    throw t.exited = { status: o, toThrow: r }, r;\n  }, print: e.stdout, printErr: e.stderr, thisProgram: e._sysExecutable, arguments: e.args, API: { config: e }, locateFile: (o) => e.indexURL + o, instantiateWasm: ye(e.indexURL) };\n  return t;\n}\ns(G, "createSettings");\nfunction ue(e) {\n  return function(t) {\n    let o = "/";\n    try {\n      t.FS.mkdirTree(e);\n    } catch (r) {\n      console.error(`Error occurred while making a home directory \'${e}\':`), console.error(r), console.error(`Using \'${o}\' for a home directory instead`), e = o;\n    }\n    t.FS.chdir(e);\n  };\n}\ns(ue, "createHomeDirectory");\nfunction fe(e) {\n  return function(t) {\n    Object.assign(t.ENV, e);\n  };\n}\ns(fe, "setEnvironment");\nfunction me(e) {\n  return e ? [async (t) => {\n    t.addRunDependency("fsInitHook");\n    try {\n      await e(t.FS, { sitePackages: t.API.sitePackages });\n    } finally {\n      t.removeRunDependency("fsInitHook");\n    }\n  }] : [];\n}\ns(me, "callFsInitHook");\nfunction pe(e) {\n  let t = q(e);\n  return async (o) => {\n    let r = o._py_version_major(), a = o._py_version_minor();\n    o.FS.mkdirTree("/lib"), o.API.sitePackages = `/lib/python${r}.${a}/site-packages`, o.FS.mkdirTree(o.API.sitePackages), o.addRunDependency("install-stdlib");\n    try {\n      let n = await t;\n      o.FS.writeFile(`/lib/python${r}${a}.zip`, n);\n    } catch (n) {\n      console.error("Error occurred while installing the standard library:"), console.error(n);\n    } finally {\n      o.removeRunDependency("install-stdlib");\n    }\n  };\n}\ns(pe, "installStdlib");\nfunction ge(e) {\n  let t;\n  return e.stdLibURL != null ? t = e.stdLibURL : t = e.indexURL + "python_stdlib.zip", [...me(e.fsInit), pe(t), ue(e.env.HOME), fe(e.env), Y];\n}\ns(ge, "getFileSystemInitializationFuncs");\nfunction ye(e) {\n  if (typeof WasmOffsetConverter < "u")\n    return;\n  let { binary: t, response: o } = F(e + "pyodide.asm.wasm");\n  return function(r, a) {\n    return async function() {\n      try {\n        let n;\n        o ? n = await WebAssembly.instantiateStreaming(o, r) : n = await WebAssembly.instantiate(await t, r);\n        let { instance: i, module: c } = n;\n        a(i, c);\n      } catch (n) {\n        console.warn("wasm instantiation failed!"), console.warn(n);\n      }\n    }(), {};\n  };\n}\ns(ye, "getInstantiateWasmFunc");\nvar M = "0.27.5";\nasync function $e(e = {}) {\n  var u, m;\n  await T();\n  let t = e.indexURL || await K();\n  t = O(t), t.endsWith("/") || (t += "/"), e.indexURL = t;\n  let o = { fullStdLib: false, jsglobals: globalThis, stdin: globalThis.prompt ? globalThis.prompt : void 0, lockFileURL: t + "pyodide-lock.json", args: [], env: {}, packageCacheDir: t, packages: [], enableRunUntilComplete: false, checkAPIVersion: true, BUILD_ID: "bd0388b62e760f8ba04185eb443fec955f25434f49c7b951efe5b1f792dbe5d4" }, r = Object.assign(o, e);\n  (u = r.env).HOME ?? (u.HOME = "/home/pyodide"), (m = r.env).PYTHONINSPECT ?? (m.PYTHONINSPECT = "1");\n  let a = G(r), n = a.API;\n  if (n.lockFilePromise = J(r.lockFileURL), typeof _createPyodideModule != "function") {\n    let f = `${r.indexURL}pyodide.asm.js`;\n    await I(f);\n  }\n  let i;\n  if (e._loadSnapshot) {\n    let f = await e._loadSnapshot;\n    ArrayBuffer.isView(f) ? i = f : i = new Uint8Array(f), a.noInitialRun = true, a.INITIAL_MEMORY = i.length;\n  }\n  let c = await _createPyodideModule(a);\n  if (a.exited)\n    throw a.exited.toThrow;\n  if (e.pyproxyToStringRepr && n.setPyProxyToStringMethod(true), n.version !== M && r.checkAPIVersion)\n    throw new Error(`Pyodide version does not match: \'${M}\' <==> \'${n.version}\'. If you updated the Pyodide version, make sure you also updated the \'indexURL\' parameter passed to loadPyodide.`);\n  c.locateFile = (f) => {\n    throw new Error("Didn\'t expect to load any more file_packager files!");\n  };\n  let l;\n  i && (l = n.restoreSnapshot(i));\n  let d = n.finalizeBootstrap(l, e._snapshotDeserializer);\n  return n.sys.path.insert(0, n.config.env.HOME), d.version.includes("dev") || n.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${d.version}/full/`), n._pyodide.set_excepthook(), await n.packageIndexReady, n.initializeStreams(r.stdin, r.stdout, r.stderr), d;\n}\ns($e, "loadPyodide");\nmodule.exports;\n'),loadPyodide=out.loadPyodide,version=out.version}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.gca=function(e){return e={}[e]||e,__webpack_require__.p+__webpack_require__.u(e)};var __webpack_exports__={};let PyodideStatus=function(e){return e.NOT_INITIALIZED="not_initialized",e.INITIALIZING="initializing",e.RUNNING="running",e.FINISHED_RUNNING="finished_running",e}({});var pyodide=__webpack_require__(97187);let pyodideInstance=null;const initPyodide=async()=>{self.postMessage({type:"pyodideStatusUpdate",status:PyodideStatus.INITIALIZING});const e=await(0,pyodide.p)({indexURL:`${self.location.origin}/pyodide`});return self.postMessage({type:"pyodideStatusUpdate",status:PyodideStatus.RUNNING}),e.setStdout({batched:e=>{self.postMessage({type:"stdout",output:e})}}),e.setStderr({batched:e=>{self.postMessage({type:"stderr",output:e})}}),e};self.onmessage=async e=>{try{if(pyodideInstance||(pyodideInstance=await initPyodide()),"string"==typeof e.data){const n=e.data;pyodideInstance.runPython(n)}else{const{activeFile:n,allFiles:t}=e.data;for(const[e,o]of Object.entries(t))pyodideInstance.FS.writeFile(`/${e}`,(new TextEncoder).encode(o));pyodideInstance.runPython("\nimport sys\nimport importlib\n# Add root directory to Python path if not already there\nif '/' not in sys.path:\n    sys.path.insert(0, '/')\n# Invalidate import caches so Python can find the modules\nimportlib.invalidate_caches()\n            ");const r=t[n];if(!r)throw new Error(`Active file '${n}' not found in provided files`);pyodideInstance.runPython(r)}const n={type:"runPython",success:!0};self.postMessage(n)}catch(n){console.error("Python error:",n);const e={type:"runPython",success:!1,error:n instanceof Error?n.message:"Unknown error"};self.postMessage(e)}}})();