"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[181],{10181(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var s=n(89153),o=n(74848),r=n(28453);const a={title:"Bringing NumPy's type-completeness score to nearly 90%",description:"We tell the story of how we brought NumPy's type-completeness score from ~33% to nearly 90%",slug:"numpy-type-completeness",authors:["marcogorelli"],tags:["typechecking","news"],hide_table_of_contents:!1},i=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Wait, what&#39;s type completeness?",id:"wait-whats-type-completeness",level:2},{value:"How type-complete is NumPy?",id:"how-type-complete-is-numpy",level:2},{value:"The one-line change which doubled type-completeness",id:"the-one-line-change-which-doubled-type-completeness",level:2},{value:"Enter MaskedArray",id:"enter-maskedarray",level:2},{value:"Typing MaskedArray",id:"typing-maskedarray",level:2},{value:"What&#39;s missing from NumPy?",id:"whats-missing-from-numpy",level:2},{value:"Conclusion, acknowledgements",id:"conclusion-acknowledgements",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["Because ",(0,o.jsx)(t.a,{href:"https://numpy.org/",children:"NumPy"})," is one of the most downloaded packages in the Python ecosystem, any incremental improvement can have a large impact on the data science ecosystem. In particular, improvements related to static typing can improve developer experience and help downstream libraries write safer code. We'll tell the story about how we (Quansight Labs, with support from Meta's Pyrefly team) helped bring its type-completeness score to nearly 90% from an initial 33%."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"TL;DR"}),":"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"NumPy's type-completeness score was ~33%."}),"\n",(0,o.jsx)(t.li,{children:"A one-line fix doubled coverage to over 80%."}),"\n",(0,o.jsx)(t.li,{children:"Fully typing MaskedArray pushed the score to nearly 90%."}),"\n",(0,o.jsxs)(t.li,{children:["What's left? Top-level ",(0,o.jsx)(t.code,{children:"numpy.ma"})," functions, more precise overloads, and adding a type-checker to NumPy's CI."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"wait-whats-type-completeness",children:"Wait, what's type completeness?"}),"\n",(0,o.jsxs)(t.p,{children:["Modern IDEs use type annotations to help developers by showing them helpful suggestions and highlighting syntax. ",(0,o.jsx)(t.a,{href:"https://github.com/microsoft/pyright",children:"Pyright"})," is a popular type-checker which, as well as checking for correctness and consistency, can also measure what percentage of a library's public API has type annotations. We call the percentage of fully-typed symbols exported by a library the ",(0,o.jsx)(t.em,{children:"type-completeness score"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["For example, a module which exports functions ",(0,o.jsx)(t.code,{children:"foo"})," and ",(0,o.jsx)(t.code,{children:"bar"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"def foo(a: int):\n    return None\n\ndef bar() -> int:\n    return 1\n"})}),"\n",(0,o.jsx)(t.p,{children:"would have a 50% type-completeness score, because:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"foo"})," is partially unknown, as it's missing a return annotation."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"bar"})," is type-complete."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["By changing the ",(0,o.jsx)(t.code,{children:"foo"})," signature to be ",(0,o.jsx)(t.code,{children:"def foo(a: int) -> None:"}),", the type-completeness score would jump to 100%. The more type-complete a library is, the more helpful the suggestions an IDE can show to the user."]}),"\n",(0,o.jsxs)(t.p,{children:["Note that type-completeness only measures how much of the public API (at least, the part known to Pyright) is covered by types. If you want to verify that those types are correct and self-consistent, you'll also need to run a type checker. The most used type checkers currently are ",(0,o.jsx)(t.a,{href:"https://github.com/python/mypy",children:"mypy"})," and Pyright, but ",(0,o.jsx)(t.a,{href:"https://github.com/facebook/pyrefly",children:"Pyrefly"})," and ",(0,o.jsx)(t.a,{href:"https://github.com/astral-sh/ty",children:"ty"})," are also attracting a lot of attention due to their impressive performance characteristics (note however that neither yet describes itself as production-ready, so temper your expectations accordingly if you try them out!)."]}),"\n",(0,o.jsx)(t.h2,{id:"how-type-complete-is-numpy",children:"How type-complete is NumPy?"}),"\n",(0,o.jsx)(t.p,{children:"When we started this effort (in March 2025), we first tried measuring NumPy's type-completeness by running:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-console",children:"pyright --verifytypes numpy\n"})}),"\n",(0,o.jsx)(t.p,{children:"The output showed a completeness score of...18%. Wait, only 18%? This seemed very low, because by then typing efforts in NumPy had been ongoing for some time. Was something up with the metric? Upon closer inspection of the output, we noticed a few things:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Some objects, such as ",(0,o.jsx)(t.code,{children:"DTypeLike"}),', were reported to be "partially unknown", even though they had type annotations.']}),"\n",(0,o.jsxs)(t.li,{children:["The type-completeness report included test modules such as ",(0,o.jsx)(t.code,{children:"numpy.tests.test_matlib"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["The first issue was caused by an import from the standard library ",(0,o.jsx)(t.code,{children:"decimal"})," module, which itself is partially untyped. Given that this is outside of NumPy's direct control, we decided to exclude it from the coverage report by using ",(0,o.jsx)(t.code,{children:"--ignoreexternal"}),", ",(0,o.jsx)(t.a,{href:"https://github.com/microsoft/pyright/discussions/9911",children:"as suggested by Eric Traut"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["For the second issue, Pyright gives us an option to export the coverage report to json (",(0,o.jsx)(t.code,{children:"--outputjson"}),"). We could then parse the json and exclude ",(0,o.jsx)(t.code,{children:"numpy.tests"}),". Given that NumPy users wouldn't ordinarily interact with NumPy's internal test suite but that Pyright considers it public, we decided that it made sense for us to exclude tests in order to focus our efforts on what would make the biggest user-facing impact."]}),"\n",(0,o.jsx)(t.p,{children:"Once we'd addressed the two steps above, the baseline type-completeness score became 33%. This was our starting point. We could then focus our efforts on the remaining 67%!"}),"\n",(0,o.jsx)(t.h2,{id:"the-one-line-change-which-doubled-type-completeness",children:"The one-line change which doubled type-completeness"}),"\n",(0,o.jsxs)(t.p,{children:["Pyright's report includes classes, methods, functions, type aliases, and more. A lot of scientific Python code centres around some central classes such as ",(0,o.jsx)(t.code,{children:"numpy.ndarray"}),". ",(0,o.jsx)(t.code,{children:"ndarray"}),' was reported as "partially unknown", but eye-balling the exported symbols related to that class revealed something interesting:']}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:">>> np.mean([x['isTypeKnown'] for x in exported if x['name'].startswith('numpy.ndarray.')])\nnp.float64(0.9811320754716981)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["So, ",(0,o.jsx)(t.code,{children:"ndarray"}),' was reported as "partially unknown", but 98% of its methods had known types. It shouldn\'t be much effort to bring that number to 100%! In fact, all it took was a ',(0,o.jsx)(t.a,{href:"https://github.com/numpy/numpy/pull/28908",children:"one-line change to fix a typo in a type annotation"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-diff",children:"- def setfield(self, /, val: ArrayLike, dtype: DTypeLike, offset: CanIndex = 0) -> None: ...\n+ def setfield(self, /, val: ArrayLike, dtype: DTypeLike, offset: SupportsIndex = 0) -> None: ...\n"})}),"\n",(0,o.jsxs)(t.p,{children:["That's it! ",(0,o.jsx)(t.code,{children:"CanIndex"})," was an unknown symbol and was probably mistyped, and replacing it with the correct ",(0,o.jsx)(t.code,{children:"SupportsIndex"})," one brought NumPy's overall type-completeness to over 80%! We then started examining other NumPy classes to see if there was anywhere else where we could make an impact, and hopefully a much larger one."]}),"\n",(0,o.jsx)(t.h2,{id:"enter-maskedarray",children:"Enter MaskedArray"}),"\n",(0,o.jsx)(t.p,{children:"When we looked at the percentage of typed symbols from the MaskedArray class, we noticed something interesting:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:">>> np.mean([x['isTypeKnown'] for x in exported if x['name'].startswith('numpy.ma.core.MaskedArray.')])\nnp.float64(0.2)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Only 20% of them were typed! That's quite a contrast with ",(0,o.jsx)(t.code,{children:"ndarray"}),", which was already at 98% when we started. It's also a fairly widely used class, appearing in the codebases of pandas, scikit-learn, and xarray. Given how poorly typed it was, we decided it would be a good candidate to spend time on!"]}),"\n",(0,o.jsx)(t.h2,{id:"typing-maskedarray",children:"Typing MaskedArray"}),"\n",(0,o.jsxs)(t.p,{children:["The main difficulty in typing NumPy code isn't inferring the possible argument values (which is quite easy to do with automated tools), but rather dealing with the large number of overloads. This is because many of NumPy methods' return types depend on the exact combinations of the input types. For example, suppose we have a ",(0,o.jsx)(t.code,{children:"MaskedArray"})," ",(0,o.jsx)(t.code,{children:"ma"})," and want to count the number of non-null values:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"ma.count()"})," returns an integer."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"ma.count(axis=0)"})," returns an array."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"ma.count(keepdims=True)"})," also returns an array, of the same shape as the input array."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"We can type this by having a different overload of each of these different cases. This is a relatively simple example, but there are others where the number of necessary overloads was as high as 9! This isn't something which is easy to automate, and requires careful reading of the documentation and of the source code. It's a non-trivial amount of work."}),"\n",(0,o.jsxs)(t.p,{children:["But...we pulled through it, and thanks to some very timely and constructive reviews from the amazing ",(0,o.jsx)(t.a,{href:"https://github.com/jorenham",children:"Joren Hammudoglu"}),", MaskedArray is now reported as 100% type-complete! As for the overall type-completeness, that's now at 88%. So...what's left?"]}),"\n",(0,o.jsx)(t.h2,{id:"whats-missing-from-numpy",children:"What's missing from NumPy?"}),"\n",(0,o.jsxs)(t.p,{children:["In the MaskedArray module, there's still some untyped top-level functions, such as ",(0,o.jsx)(t.code,{children:"numpy.ma.count"}),". Overloads could be made more precise and shape-preserving (e.g. if the input is 2D, then make sure to preserve this fact in the output where possible). There's some missing defaults in the stubs. There's no shortage of work here."]}),"\n",(0,o.jsxs)(t.p,{children:["The biggest missing bit, however, is the elephant in the room: NumPy doesn't run a type-checker over its codebase in CI. It has some typing tests, sure, but that's different from running a type-checker. If any motivated reader is interested in making a significant open source contribution, then getting NumPy's typing into a state such that a type checker (and possibly even ",(0,o.jsx)(t.a,{href:"https://mypy.readthedocs.io/en/stable/stubtest.html",children:"stubtest"}),") can be run over it could be a great use of your time."]}),"\n",(0,o.jsx)(t.h2,{id:"conclusion-acknowledgements",children:"Conclusion, acknowledgements"}),"\n",(0,o.jsxs)(t.p,{children:["We've looked at how we contributed towards increasing NumPy's type-completeness. Given how widespread NumPy's adoption is, we expect this effort to have been an impactful one. We look forward to seeing what else we can achieve in this space - thank you to ",(0,o.jsx)(t.a,{href:"https://discuss.python.org/t/call-for-suggestions-nominate-python-packages-for-typing-improvements/80186/1",children:"Meta and Quansight Labs"})," for having funded and facilitated this effort!"]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453(e,t,n){n.d(t,{R:()=>a,x:()=>i});var s=n(96540);const o={},r=s.createContext(o);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:t},e.children)}},89153(e){e.exports=JSON.parse('{"permalink":"/blog/numpy-type-completeness","source":"@site/blog/2025-09-29-typing-numpy.md","title":"Bringing NumPy\'s type-completeness score to nearly 90%","description":"We tell the story of how we brought NumPy\'s type-completeness score from ~33% to nearly 90%","date":"2025-09-29T00:00:00.000Z","tags":[{"inline":true,"label":"typechecking","permalink":"/blog/tags/typechecking"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":6.205,"hasTruncateMarker":true,"authors":[{"name":"Marco Gorelli, Quansight Labs","url":"https://github.com/MarcoGorelli","key":"marcogorelli","page":null}],"frontMatter":{"title":"Bringing NumPy\'s type-completeness score to nearly 90%","description":"We tell the story of how we brought NumPy\'s type-completeness score from ~33% to nearly 90%","slug":"numpy-type-completeness","authors":["marcogorelli"],"tags":["typechecking","news"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Pyrefly Beta is here!","permalink":"/blog/pyrefly-beta"},"nextItem":{"title":"Give your Python IDE a Glow-Up with Pyrefly","permalink":"/blog/2025/09/15/ide-extension"}}')}}]);