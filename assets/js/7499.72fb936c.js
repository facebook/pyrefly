"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[7499],{57499(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var a=t(38766),r=t(74848),s=t(28453);const i={title:"4 Pyrefly Type Narrowing Patterns that make Type Checking more Intuitive",description:"Learn about 4 ways Pyrefly narrows types, reducing the need to explicitly cast in your code.",slug:"type-narrowing",authors:["yangdanny","rebeccachen","abbym"],tags:["typechecking"],image:"https://pyrefly.org/assets/images/type-narrowing-blog-688b8aae77abd588a29ddb9d5bab231f.png",hide_table_of_contents:!1},o=void 0,l={authorsImageUrls:[void 0,void 0,void 0]},c=[{value:"<code>hasattr</code> and <code>getattr</code>",id:"hasattr-and-getattr",level:2},{value:"Tagged Unions",id:"tagged-unions",level:2},{value:"Tuple length narrowing",id:"tuple-length-narrowing",level:2},{value:"Conditions saved in variables",id:"conditions-saved-in-variables",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(64442).A+"",width:"5334",height:"3000"})}),"\n",(0,r.jsxs)(n.p,{children:["If we view a type of an expression or variable as the set of possible values it can resolve to,  narrowing is the process of applying constraints on those values. For example, if you have a variable ",(0,r.jsx)(n.code,{children:"x"})," whose contents you don\u2019t know, an ",(0,r.jsx)(n.code,{children:"if isinstance(x, int)"})," check will narrow the type of ",(0,r.jsx)(n.code,{children:"x"})," to ",(0,r.jsx)(n.code,{children:"int"})," inside the body of the if-statement."]}),"\n",(0,r.jsxs)(n.p,{children:["Since Python is a ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Duck_typing",children:"duck-typed"})," language, programs often narrow types by checking a structural property of something rather than just its class name. For a type checker, understanding a wide variety of narrowing patterns is essential for making it as easy as possible for users to type check their code and reduce the amount of changes made purely to \u201csatisfy the type checker\u201d."]}),"\n",(0,r.jsx)(n.p,{children:"In this blog post, we\u2019ll go over some cool forms of narrowing that Pyrefly supports, which allows it to understand common code patterns in Python."}),"\n",(0,r.jsxs)(n.h2,{id:"hasattr-and-getattr",children:[(0,r.jsx)(n.code,{children:"hasattr"})," and ",(0,r.jsx)(n.code,{children:"getattr"})]}),"\n",(0,r.jsx)(n.p,{children:"In a dynamic codebase where not every field is initialized in the constructor, you may encounter code that dynamically adds attributes to classes without declaring them in the class body."}),"\n",(0,r.jsxs)(n.p,{children:["Even if a field is not declared on the class, Pyrefly can understand a ",(0,r.jsx)(n.code,{children:"hasattr"})," check indicates that the field exists."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def func(x: object) -> None:\n\n   if hasattr(x, "value"):\n       val = x.value # Pyrefly knows that `x` has the `value` attribute and won\u2019t error here\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Some fields are declared on the class but not always initialized, so accesses have to be done with ",(0,r.jsx)(n.code,{children:"getattr"}),". To support this pattern, any checks on ",(0,r.jsx)(n.code,{children:"getattr(x, \u201cfield\u201d)"})," will generally narrow the type the same way as the same check on ",(0,r.jsx)(n.code,{children:"x.field"}),". This means that using ",(0,r.jsx)(n.code,{children:"getattr()"})," in a guard will narrow the field to be truthy."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from typing import Literal, assert_type\n\nclass C:\n    flag: bool  # the flag is not always set`\n\ndef func(x: C) -> None:\n\n   if getattr(x, "flag"):\n       # here Pyrefly knows that the flag is set to True\n       assert_type(x.flag, Literal[True])\n'})}),"\n",(0,r.jsx)(n.h2,{id:"tagged-unions",children:"Tagged Unions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Tagged_union",children:"Tagged unions"})," are a common feature in functional programming languages, but they are not a first-class language construct in Python.  Although Python\u2019s union types are untagged, Pyrefly can emulate a tagged union by creating a union where each member explicitly defines the same field to use as a tag. Pyrefly can then check the value of the field to narrow the union to the corresponding member."]}),"\n",(0,r.jsx)(n.p,{children:"This works for regular classes, as well as typed dicts."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from typing import TypedDict, Literal\n\nclass Ok(TypedDict):\n   result: Literal["ok"]\n   payload: bytes\n\nclass Err(TypedDict):\n   result: Literal["error"]\n   message: str\n\ntype Response = Ok | Err\n\ndef read(res: Response) -> bytes:\n   if res["result"] == "ok":\n        return res["payload"]\n   else:\n       raise Exception(res["message"])\n'})}),"\n",(0,r.jsx)(n.h2,{id:"tuple-length-narrowing",children:"Tuple length narrowing"}),"\n",(0,r.jsx)(n.p,{children:"When you check the length of something against a literal integer, Pyrefly will narrow away any tuple types that definitely do not match that length:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from typing import assert_type\n\ntype XY = tuple[float, float]   # 2D point\ntype RGB = tuple[int, int, int]  # color\n\ntype Vec = XY | RGB\n\ndef describe(v: Vec) -> None:\n   if len(v) == 2:\n       x, y = v # Pyrefly knows v only has 2 elements, so it cannot be RGB\n   else:\n       r, g, b = v # Pyrefly knows v has 3 elements, so it cannot be XY\n"})}),"\n",(0,r.jsx)(n.h2,{id:"conditions-saved-in-variables",children:"Conditions saved in variables"}),"\n",(0,r.jsx)(n.p,{children:"If you want to check some condition multiple times, you may want to save it to a local variable to avoid repeating yourself. Pyrefly understands this pattern, while also being smart enough to figure out when it should invalidate a saved condition:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def f(x: int | str, y: int, z: int | str):\n\n    x_is_int = isinstance(x, int)\n\n    if x_is_int:\n        y += x # here Pyrefly knows x is an int and won't throw an error\n\n    if x_is_int:\n        y += x # x has not changed, so pyrefly still knows that x is an int\n\n    x = z\n\n    if x_is_int:\n        y += x # this is now unsafe, the x_is_int condition is invalidated so pyrefly will throw an error here\n"})}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"These are just a few of the ways Pyrefly automatically narrows types, reducing the need for explicit casts in your programs. Not all of these features are unique to Pyrefly, but no other type checker as of writing supports the full set of narrowing patterns listed here. Given the lack of standardization of this feature, there\u2019s a lot of room for innovation in the space. We\u2019re currently working on expanding the narrowing patterns we support - so stay tuned for more updates!"}),"\n",(0,r.jsxs)(n.p,{children:["Do you have a pattern for narrowing types that you wish type checkers could understand, or that you want us to support in Pyrefly? Please file an issue on our ",(0,r.jsx)(n.a,{href:"https://github.com/facebook/pyrefly",children:"Github"}),"!"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},64442(e,n,t){t.d(n,{A:()=>a});const a=t.p+"assets/images/type-narrowing-blog-688b8aae77abd588a29ddb9d5bab231f.png"},28453(e,n,t){t.d(n,{R:()=>i,x:()=>o});var a=t(96540);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}},38766(e){e.exports=JSON.parse('{"permalink":"/blog/type-narrowing","source":"@site/blog/2026-01-26-narrowing.md","title":"4 Pyrefly Type Narrowing Patterns that make Type Checking more Intuitive","description":"Learn about 4 ways Pyrefly narrows types, reducing the need to explicitly cast in your code.","date":"2026-01-26T00:00:00.000Z","tags":[{"inline":true,"label":"typechecking","permalink":"/blog/tags/typechecking"}],"readingTime":3.955,"hasTruncateMarker":true,"authors":[{"name":"Danny Yang","url":"https://github.com/yangdanny97","key":"yangdanny","page":null},{"name":"Rebecca Chen","url":"https://github.com/rchen152","key":"rebeccachen","page":null},{"name":"Abby Mitchell","url":"https://github.com/javabster","key":"abbym","page":null}],"frontMatter":{"title":"4 Pyrefly Type Narrowing Patterns that make Type Checking more Intuitive","description":"Learn about 4 ways Pyrefly narrows types, reducing the need to explicitly cast in your code.","slug":"type-narrowing","authors":["yangdanny","rebeccachen","abbym"],"tags":["typechecking"],"image":"https://pyrefly.org/assets/images/type-narrowing-blog-688b8aae77abd588a29ddb9d5bab231f.png","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Making Pyrefly Diagnostics 18x Faster","permalink":"/blog/2026/02/06/performance-improvements"},"nextItem":{"title":"Fly through data validation with Pyrefly\u2019s new Pydantic integration","permalink":"/blog/pyrefly-pydantic"}}')}}]);