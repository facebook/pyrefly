"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5940],{75940:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"error-kinds","title":"Pyrefly Error Kinds","description":"Pyrefly error categories and suppression codes","source":"@site/docs/error-kinds.mdx","sourceDirName":".","slug":"/error-kinds","permalink":"/en/docs/error-kinds","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/pyrefly/edit/main/website/docs/error-kinds.mdx","tags":[],"version":"current","frontMatter":{"title":"Pyrefly Error Kinds","description":"Pyrefly error categories and suppression codes"},"sidebar":"docsSidebar","previous":{"title":"Error Suppressions","permalink":"/en/docs/error-suppressions"},"next":{"title":"Import Resolution","permalink":"/en/docs/import-resolution"}}');var a=i(74848),t=i(28453);const r={title:"Pyrefly Error Kinds",description:"Pyrefly error categories and suppression codes"},o="Pyrefly Error Kinds",l={},d=[{value:"annotation-mismatch",id:"annotation-mismatch",level:2},{value:"assert-type",id:"assert-type",level:2},{value:"bad-argument-count",id:"bad-argument-count",level:2},{value:"bad-argument-type",id:"bad-argument-type",level:2},{value:"bad-assignment",id:"bad-assignment",level:2},{value:"bad-class-definition",id:"bad-class-definition",level:2},{value:"bad-context-manager",id:"bad-context-manager",level:2},{value:"bad-function-definition",id:"bad-function-definition",level:2},{value:"bad-index",id:"bad-index",level:2},{value:"bad-instantiation",id:"bad-instantiation",level:2},{value:"bad-keyword-argument",id:"bad-keyword-argument",level:2},{value:"bad-match",id:"bad-match",level:2},{value:"bad-override",id:"bad-override",level:2},{value:"bad-param-name-override",id:"bad-param-name-override",level:2},{value:"bad-return",id:"bad-return",level:2},{value:"bad-specialization",id:"bad-specialization",level:2},{value:"bad-typed-dict",id:"bad-typed-dict",level:2},{value:"bad-typed-dict-key",id:"bad-typed-dict-key",level:2},{value:"bad-unpacking",id:"bad-unpacking",level:2},{value:"deprecated",id:"deprecated",level:2},{value:"implicit-any",id:"implicit-any",level:2},{value:"implicit-import",id:"implicit-import",level:2},{value:"implicitly-defined-attribute",id:"implicitly-defined-attribute",level:2},{value:"inconsistent-inheritance",id:"inconsistent-inheritance",level:2},{value:"inconsistent-overload",id:"inconsistent-overload",level:2},{value:"internal-error",id:"internal-error",level:2},{value:"invalid-annotation",id:"invalid-annotation",level:2},{value:"invalid-argument",id:"invalid-argument",level:2},{value:"invalid-decorator",id:"invalid-decorator",level:2},{value:"invalid-inheritance",id:"invalid-inheritance",level:2},{value:"invalid-literal",id:"invalid-literal",level:2},{value:"invalid-overload",id:"invalid-overload",level:2},{value:"invalid-param-spec",id:"invalid-param-spec",level:2},{value:"invalid-self-type",id:"invalid-self-type",level:2},{value:"invalid-super-call",id:"invalid-super-call",level:2},{value:"invalid-syntax",id:"invalid-syntax",level:2},{value:"invalid-type-alias",id:"invalid-type-alias",level:2},{value:"invalid-type-var",id:"invalid-type-var",level:2},{value:"invalid-type-var-tuple",id:"invalid-type-var-tuple",level:2},{value:"invalid-yield",id:"invalid-yield",level:2},{value:"missing-argument",id:"missing-argument",level:2},{value:"missing-attribute",id:"missing-attribute",level:2},{value:"missing-import",id:"missing-import",level:2},{value:"missing-module-attribute",id:"missing-module-attribute",level:2},{value:"missing-source",id:"missing-source",level:2},{value:"no-access",id:"no-access",level:2},{value:"no-matching-overload",id:"no-matching-overload",level:2},{value:"not-a-type",id:"not-a-type",level:2},{value:"not-async",id:"not-async",level:2},{value:"not-callable",id:"not-callable",level:2},{value:"not-iterable",id:"not-iterable",level:2},{value:"parse-error",id:"parse-error",level:2},{value:"protocol-implicitly-defined-attribute",id:"protocol-implicitly-defined-attribute",level:2},{value:"read-only",id:"read-only",level:2},{value:"redundant-cast",id:"redundant-cast",level:2},{value:"redundant-condition",id:"redundant-condition",level:2},{value:"reveal-type",id:"reveal-type",level:2},{value:"unbound-name",id:"unbound-name",level:2},{value:"unexpected-keyword",id:"unexpected-keyword",level:2},{value:"unexpected-positional-argument",id:"unexpected-positional-argument",level:2},{value:"unknown-name",id:"unknown-name",level:2},{value:"unsupported",id:"unsupported",level:2},{value:"unsupported-delete",id:"unsupported-delete",level:2},{value:"unsupported-operation",id:"unsupported-operation",level:2},{value:"unused-coroutine",id:"unused-coroutine",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"pyrefly-error-kinds",children:"Pyrefly Error Kinds"})}),"\n",(0,a.jsxs)(n.p,{children:["An ",(0,a.jsx)(n.em,{children:"error kind"})," categorizes an error by the part of the typing specification\nthat an error is related to. Every error has exactly one kind."]}),"\n",(0,a.jsx)(n.p,{children:'The main use of error kinds is as short names ("slugs") that can be used in\nerror suppression comments.'}),"\n",(0,a.jsx)(n.h2,{id:"annotation-mismatch",children:"annotation-mismatch"}),"\n",(0,a.jsx)(n.p,{children:"This error indicates a mismatch between multiple annotations for a single\nvariable. This is relatively uncommon, but it can happen in if-statements:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'if some_cond:\n    x: int = 1\nelse:\n    x: str = "two" # Inconsistent type annotations for x: str, int [annotation-mismatch]\n'})}),"\n",(0,a.jsx)(n.p,{children:"It can be helpful to annotate the variable before branch, especially if there is\na useful default value for it. For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'x: str = "default"\nif some_cond:\n  x = "actual value"\n'})}),"\n",(0,a.jsx)(n.h2,{id:"assert-type",children:"assert-type"}),"\n",(0,a.jsxs)(n.p,{children:["An ",(0,a.jsx)(n.code,{children:"assert-type"})," error is raised when a ",(0,a.jsx)(n.code,{children:"typing.assert_type()"})," call fails."]}),"\n",(0,a.jsxs)(n.p,{children:["This error kind should never be suppressed, since that rather defeats the point\nof of ",(0,a.jsx)(n.code,{children:"typing.assert_type()"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"bad-argument-count",children:"bad-argument-count"}),"\n",(0,a.jsx)(n.p,{children:"This error arises when a function is called with the wrong number of arguments."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def takes_three(one: int, two: int, three: int) -> complex:\n  ...\n\ntake_three(3, 2)  # Expected 1 more positional argument [bad-argument-count]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note that ",(0,a.jsx)(n.code,{children:"missing-argument"})," will be raised if pyrefly can identify that\nspecific arguments are missing. As such, this error is more likely to appear\nwhen too many args are supplied, rather than too few."]}),"\n",(0,a.jsx)(n.p,{children:"This example shows both kinds of errors:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import Callable\ndef apply(f: Callable[[int, int], int]) -> int:\n    return f(1)  # Expected 1 more positional argument [bad-argument-count]\napply() # Missing argument `f` in function `apply` [missing-argument]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bad-argument-type",children:"bad-argument-type"}),"\n",(0,a.jsx)(n.p,{children:"This error indicates that the function was called with an argument of the wrong\ntype."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def example(x: int) -> None:\n  ...\nexample(\"one\")  # Argument `Literal['two']` is not assignable to parameter `x` with type `int` in function `example` [bad-argument-type]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This can also happen with ",(0,a.jsx)(n.code,{children:"*args"})," and ",(0,a.jsx)(n.code,{children:"**kwargs"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def bad_args(*args: int) -> None:\n  ...\n\nbad_args(1, \"two\")  # Argument `Literal['two']` is not assignable to parameter with type `int` in function `bad_args` [bad-argument-type]\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def bad_kwargs(**kwargs: int) -> None:\n  ...\n\nbad_args(x=1, y=\"two\")  # Keyword argument `y` with type `Literal['two']` is not assignable to kwargs type `int` in function `bad_kwargs` [bad-argument-type]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bad-assignment",children:"bad-assignment"}),"\n",(0,a.jsx)(n.p,{children:"The most common cause of this error is attempting to assign a value that conflicts with the variable's type annotation."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"x: str = 1 # `Literal[1]` is not assignable to `str` [bad-assignment]\n"})}),"\n",(0,a.jsx)(n.p,{children:"However, it can occur in several other situations."}),"\n",(0,a.jsxs)(n.p,{children:["Here, ",(0,a.jsx)(n.code,{children:"x"})," is marked as ",(0,a.jsx)(n.code,{children:"Final"}),", so assigning a new value to it is an error."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import Final\nx: Final = 1\nx = 2 # `x` is marked final [bad-assignment]\n"})}),"\n",(0,a.jsx)(n.p,{children:"In another case, attempting to annotate an assignment to an instance attribute raises this error."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class A:\n    x: int\na = A()\na.x: int = 2  # Type cannot be declared in assignment to non-self attribute `a.x` [bad-assignment]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bad-class-definition",children:"bad-class-definition"}),"\n",(0,a.jsxs)(n.p,{children:["This error indicates that there is something wrong with the class definition.\nIt tends to be a bit rarer, since most issues would be tagged with other error kinds, such as\n",(0,a.jsx)(n.code,{children:"annotation-mismatch"})," or one of the function errors.\ninheritance has its own complexities, so it has its own error kind called ",(0,a.jsx)(n.code,{children:"invalid-inheritance"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"One place you may see it is dynamic class generation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from enum import Enum\nEx = Enum("Ex", [("Red", 1), ("Blue", 2), ("Red", 3)])  # Duplicate field `Red` [bad-class-definition]\n'})}),"\n",(0,a.jsx)(n.p,{children:"However, it is best practice to use the class syntax if possible, which doesn't treat duplicate names as an error."}),"\n",(0,a.jsx)(n.h2,{id:"bad-context-manager",children:"bad-context-manager"}),"\n",(0,a.jsxs)(n.p,{children:["This error occurs when a type that cannot be used as a context manager appears in a ",(0,a.jsx)(n.code,{children:"with"})," statement."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class A:\n    def __enter__(self): ...\nwith A(): ...  # `A` is missing an `__exit__` method!\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bad-function-definition",children:"bad-function-definition"}),"\n",(0,a.jsxs)(n.p,{children:["Like ",(0,a.jsx)(n.code,{children:"bad-class-definition"}),", this error kind is uncommon because other error kinds are used for more specific issues.\nFor example, argument order is enforced by the parser, so ",(0,a.jsx)(n.code,{children:"def f(x: int = 1, y: str)"})," is a ",(0,a.jsx)(n.code,{children:"parse-error"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"bad-index",children:"bad-index"}),"\n",(0,a.jsx)(n.p,{children:"Attempting to access a container with an incorrect index.\nThis only occurs when Pyrefly can statically verify that the index is incorrect, such as with a fixed-length tuple."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def add_three(x: tuple[int, int]) -> int:\n  return x[0] + x[1] + x[2]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Pyrefly also knows the keys of ",(0,a.jsx)(n.code,{children:"TypedDict"}),"s, but those have their own error kind."]}),"\n",(0,a.jsx)(n.h2,{id:"bad-instantiation",children:"bad-instantiation"}),"\n",(0,a.jsx)(n.p,{children:"This error occurs when attempting to instantiate a class that cannot be instantiated, such as a protocol:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import Protocol\nclass C(Protocol): ...\nC()  # bad-instantiation\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bad-keyword-argument",children:"bad-keyword-argument"}),"\n",(0,a.jsx)(n.p,{children:"bad-keyword-argument pops up when a keyword argument is given multiple values:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def f(x: int) -> None:\n  pass\nf(x=1, x=2)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["However, this is often accompanied by a ",(0,a.jsx)(n.code,{children:"parse-error"})," for the same issue."]}),"\n",(0,a.jsx)(n.h2,{id:"bad-match",children:"bad-match"}),"\n",(0,a.jsx)(n.p,{children:"This error is used in two cases."}),"\n",(0,a.jsxs)(n.p,{children:["The first is when there is an issue with a ",(0,a.jsx)(n.code,{children:"match"})," statement. For example, ",(0,a.jsx)(n.code,{children:"Ex"})," only has 2 fields but the ",(0,a.jsx)(n.code,{children:"case"})," lists 3:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class Ex:\n  __match_args__ = ('a', 'b')\n  def __init__(self, a: int, b: str) -> None:\n    self.a = a\n    self.b = b\n\ndef do(x: Ex) -> None:\n  match x:\n    case Ex(a, b, c):\n      print(\"This is an error\")\n"})}),"\n",(0,a.jsxs)(n.p,{children:["It is also used when ",(0,a.jsx)(n.code,{children:"__match_args__"})," is defined incorrectly. It must be a tuple of the names of the class's attributes as literal strings.\nFor class ",(0,a.jsx)(n.code,{children:"Ex"})," in the previous example, ",(0,a.jsx)(n.code,{children:"__match_args__ = ('a', 'c')"})," would be an error because ",(0,a.jsx)(n.code,{children:"Ex.c"})," does not exist."]}),"\n",(0,a.jsx)(n.h2,{id:"bad-override",children:"bad-override"}),"\n",(0,a.jsx)(n.p,{children:"When a subclass overrides a field or method of its base class, care must be taken that the override won't cause problems."}),"\n",(0,a.jsx)(n.p,{children:"Some of these are obvious:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class Base:\n  def f(self, a: int) -> None:\n    pass\n\nclass NoArg(Base):\n  def f(self) -> None:\n    pass\n\nclass WrongType(Base):\n  def f(self, a: str) -> None:\n    pass\n\ndef uses_f(b: Base) -> None:\n  b.f(1)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["These errors are rather obvious: ",(0,a.jsx)(n.code,{children:"uses_f"})," will fail if given a ",(0,a.jsx)(n.code,{children:"NoArg"})," or ",(0,a.jsx)(n.code,{children:"WrongType"})," instance, because those methods don't expect an ",(0,a.jsx)(n.code,{children:"int"})," argument!"]}),"\n",(0,a.jsxs)(n.p,{children:["The guiding idea here is the ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Liskov_substitution_principle",children:"Liskov Substitution Principle"}),", the idea that a subclass can stand in for a base class at any point without breaking the program."]}),"\n",(0,a.jsx)(n.p,{children:"This can be a little subtle at first blush. Consider:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class Base:\n  def f(self, a: int) -> None:\n    pass\n\nclass Sub(Base):\n  def f(self, a: float) -> None:\n    pass\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Is this OK? Yes! ",(0,a.jsx)(n.code,{children:"int"})," is treated as a subclass of ",(0,a.jsx)(n.code,{children:"float"}),", or to put it another way, a function that accepts ",(0,a.jsx)(n.code,{children:"float"})," can accept every ",(0,a.jsx)(n.code,{children:"int"}),".\nThat means everywhere that we call ",(0,a.jsx)(n.code,{children:"Base.f"})," can safely call ",(0,a.jsx)(n.code,{children:"Sub.f"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The opposite case, where ",(0,a.jsx)(n.code,{children:"Base.f"})," takes ",(0,a.jsx)(n.code,{children:"float"})," and ",(0,a.jsx)(n.code,{children:"Sub.f"})," takes ",(0,a.jsx)(n.code,{children:"int"}),", is an error because ",(0,a.jsx)(n.code,{children:"Sub.f"})," cannot accept every ",(0,a.jsx)(n.code,{children:"float"})," value."]}),"\n",(0,a.jsxs)(n.p,{children:["Note that bad overrides caused by inconsistent parameter names are separately reported as ",(0,a.jsx)(n.a,{href:"#bad-param-name-override",children:"bad-param-name-override"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"bad-param-name-override",children:"bad-param-name-override"}),"\n",(0,a.jsxs)(n.p,{children:["Arises when a subclass overrides a method of its base class while changing the name of a positional parameter.\nThis is a type of ",(0,a.jsx)(n.a,{href:"#bad-override",children:"bad override"})," but has a separate error kind so that it can be selectively disabled if desired.\nChanging the name of a parameter breaks callers that pass in an argument by name:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class Base:\n  def f(self, a: int) -> None:\n    pass\n\nclass Sub(Base):\n  def f(self, b: int) -> None:\n    pass\n\ndef f(base: Base):\n  base.f(a=0)\n\nf(Sub())  # oops!\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bad-return",children:"bad-return"}),"\n",(0,a.jsx)(n.p,{children:"Arises when a function does not return a value that is compatible with the function's return type annotation."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def bad_return() -> None:\n  return 1\n"})}),"\n",(0,a.jsx)(n.p,{children:"Real-world examples are often less obvious, of course, due to complex control flow and type relationships."}),"\n",(0,a.jsx)(n.p,{children:"This error is also raised for generator functions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import Generator\n# Generator has 3 types: the yield, send, and return types.\ndef bad_gen() -> Generator[int, None, str]:\n  yield 1\n  return 2  # should be a str!\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bad-specialization",children:"bad-specialization"}),"\n",(0,a.jsxs)(n.p,{children:['"Specialization" refers to instantiating a generic type with a concrete type.\nFor example, ',(0,a.jsx)(n.code,{children:"list"})," is a generic type, and ",(0,a.jsx)(n.code,{children:"list[int]"})," is that type specialized with ",(0,a.jsx)(n.code,{children:"int"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Each generic type has an expected number of type vars, and each type var can be bound or constrained.\nAttempting to use specialize a generic type in a way that violates these specifications will result in a ",(0,a.jsx)(n.code,{children:"bad-specialization"})," error:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"x: list[int, str]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bad-typed-dict",children:"bad-typed-dict"}),"\n",(0,a.jsxs)(n.p,{children:["This error is reported when a ",(0,a.jsx)(n.code,{children:"TypedDict"})," definition includes an unsupported keyword argument.\nAccording to the typing specification, the only keyword argument allowed in a ",(0,a.jsx)(n.code,{children:"TypedDict"}),"'s\nbase class list is ",(0,a.jsx)(n.code,{children:"total"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import TypedDict\n\n# This is an error because `foo` is not a valid keyword.\nclass InvalidTD(TypedDict, foo=1):\n    x: int\n\n# This is valid.\nclass ValidTD(TypedDict, total=False):\n    x: int\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bad-typed-dict-key",children:"bad-typed-dict-key"}),"\n",(0,a.jsxs)(n.p,{children:["This error arises when ",(0,a.jsx)(n.code,{children:"TypedDict"}),"s are used with incorrect keys, such as a key that does not exist in the ",(0,a.jsx)(n.code,{children:"TypedDict"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typing import TypedDict\n\nclass Ex(TypedDict):\n    a: int\n    b: str\n\ndef test(x: Ex) -> None:\n    # These two keys don\'t exist\n    x.nope\n    x["wrong"]\n    # TypedDict keys must be strings!\n    x[1]\n'})}),"\n",(0,a.jsx)(n.h2,{id:"bad-unpacking",children:"bad-unpacking"}),"\n",(0,a.jsx)(n.p,{children:"An error caused by unpacking, such as attempting to unpack a list, tuple, or iterable into the wrong number of variables."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def two_elems() -> tuple[int, str]:\n  return (1, "two")\n\na, b, c = two_elems()\n'})}),"\n",(0,a.jsx)(n.p,{children:"Note that pyrefly can only report this error if it knows how many elements the thing being unpacked has."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# A bare `tuple` could have any number of elements\ndef two_elems() -> tuple:\n  return (1, "two")\n\na, b, c = two_elems()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"deprecated",children:"deprecated"}),"\n",(0,a.jsx)(n.p,{children:"This error occurs on usage of a deprecated class or function:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from warnings import deprecated\n@deprecated("deprecated")\ndef f(): ...\nf()  # deprecated!\n'})}),"\n",(0,a.jsx)(n.h2,{id:"implicit-any",children:"implicit-any"}),"\n",(0,a.jsxs)(n.p,{children:["This error is emitted when a Pyrefly infers an implicit ",(0,a.jsx)(n.code,{children:"Any"})," type in your code. This is common in gradually-typed code, but reduces type safety so we provide this error for users that want to enforce fully-typed codebases."]}),"\n",(0,a.jsx)(n.p,{children:"This error is off by default. Typically, it can be fixed by providing an explicit type annotation."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# this only errors when return type inference is disabled\ndef missing_return_annotation():\n    return 1\n\ndef missing_param_annotation(x: int, y) -> int:\n    return x\n\n# this only errors when first-use inference is disabled\nx = []\n"})}),"\n",(0,a.jsx)(n.h2,{id:"implicit-import",children:"implicit-import"}),"\n",(0,a.jsx)(n.p,{children:"A module exists, but was not imported. At runtime, if something has made this import\nbefore your code, it will work. But relies on whatever did the import to continue doing it."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import importlib\nimportlib.util.find_spec("os")  # error, `importlib.util` was not imported\n'})}),"\n",(0,a.jsx)(n.h2,{id:"implicitly-defined-attribute",children:"implicitly-defined-attribute"}),"\n",(0,a.jsxs)(n.p,{children:["An attribute was implicitly defined by assignment to ",(0,a.jsx)(n.code,{children:"self"})," in a method that we\ndo not recognize as always executing. We recognize constructors and some test\nsetup methods; we will emit an error for any attributes defined by assignment\nin other methods."]}),"\n",(0,a.jsx)(n.p,{children:"This error is off by default, and must be manually enabled in the configuration."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class C:\n    def __init__(self):\n        self.x = 0  # no error, `__init__` always executes\n    def f(self):\n        self.y = 0  # error, `y` may be undefined if `f` does not execute\n"})}),"\n",(0,a.jsx)(n.h2,{id:"inconsistent-inheritance",children:"inconsistent-inheritance"}),"\n",(0,a.jsx)(n.p,{children:"When a class inherits from multiple base classes, the inherited fields must be consistent."}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class A:\n    f: str\nclass B:\n    f: int\nclass C(A, B): ...  # error, the field `f` is inconsistent\n"})}),"\n",(0,a.jsx)(n.h2,{id:"inconsistent-overload",children:"inconsistent-overload"}),"\n",(0,a.jsxs)(n.p,{children:["The signature of a function overload is inconsistent with the implementation.\nSee the ",(0,a.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/overload.html#implementation-consistency",children:"typing specification"}),"\nfor details on the consistency checks Pyrefly performs."]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import overload\n@overload\ndef f(x: int) -> int: ...\n@overload\ndef f(x: str) -> str: ...  # error, overload accepts `str` but implementation only accepts `int`\ndef f(x: int) -> int | str:\n    return x\n"})}),"\n",(0,a.jsx)(n.h2,{id:"internal-error",children:"internal-error"}),"\n",(0,a.jsxs)(n.p,{children:["Ideally you'll never see this one. If you do, please consider ",(0,a.jsx)(n.a,{href:"https://github.com/facebook/pyrefly/issues",children:"filing a bug"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"invalid-annotation",children:"invalid-annotation"}),"\n",(0,a.jsxs)(n.p,{children:["There are several reasons why an annotation may be invalid. The most common case is misusing a typing special form, such as ",(0,a.jsx)(n.code,{children:"typing.Final"}),", ",(0,a.jsx)(n.code,{children:"typing.ClassVar"}),", ",(0,a.jsx)(n.code,{children:"typing.ParamSpec"}),", and so on."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import *\n\n# Final must have a value\na: Final\n# ClassVar can only be used in a class body\nb: ClassVar[int] = 1\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The error messages will explain how the special form is being misused. Consult the ",(0,a.jsx)(n.a,{href:"https://docs.python.org/3/library/typing.html",children:"typing docs"})," and ",(0,a.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/",children:"typing spec"})," for more information."]}),"\n",(0,a.jsx)(n.h2,{id:"invalid-argument",children:"invalid-argument"}),"\n",(0,a.jsx)(n.p,{children:"This error is used to indicate an issue with an argument to special typing-related functions."}),"\n",(0,a.jsxs)(n.p,{children:["For example, ",(0,a.jsx)(n.code,{children:"typing.NewType"})," is a handy special form for creating types that are distinct from a base type."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typing import *\n\n# The first arg must match the name!\nMismatch = NewType("Wrong Name", int)\n\n# NewTypes cannot be used in isinstance.\nUserId = NewType("UserId", int)\nif isinstance(1, UserId):\n  ...\n'})}),"\n",(0,a.jsx)(n.h2,{id:"invalid-decorator",children:"invalid-decorator"}),"\n",(0,a.jsxs)(n.p,{children:["This error indicates that a decorator was used incorrectly. For example, using ",(0,a.jsx)(n.code,{children:"@typing.final"})," on a non-method function."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import final\n@final\ndef f() -> None:\n  pass\n"})}),"\n",(0,a.jsx)(n.h2,{id:"invalid-inheritance",children:"invalid-inheritance"}),"\n",(0,a.jsx)(n.p,{children:"An error caused by incorrect inheritance in a class or type definition.\nThis can pop up in quite a few cases:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Trying to subclass something that isn't a class."}),"\n",(0,a.jsxs)(n.li,{children:["Subclassing a type that does not support it, such as a ",(0,a.jsx)(n.code,{children:"NewType"})," or a ",(0,a.jsx)(n.code,{children:"Final"})," class."]}),"\n",(0,a.jsxs)(n.li,{children:["Attempting to mix ",(0,a.jsx)(n.code,{children:"Protocol"}),"s with non-",(0,a.jsx)(n.code,{children:"Protocol"})," base classes."]}),"\n",(0,a.jsx)(n.li,{children:"Trying to make a generic enum."}),"\n",(0,a.jsxs)(n.li,{children:["Trying to give a ",(0,a.jsx)(n.code,{children:"TypedDict"})," a metaclass."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"And so on!"}),"\n",(0,a.jsx)(n.h2,{id:"invalid-literal",children:"invalid-literal"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"typing.Literal"})," only allows a ",(0,a.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/literal.html#legal-parameters-for-literal-at-type-check-time",children:"limited set"})," of types as parameters.\nAttempting to use ",(0,a.jsx)(n.code,{children:"Literal"})," with anything else is an error."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import Literal\n\n# These are legal\nLiteral[1.0]\nLiteral['a', 'b', 'c']\n# This is not\nclass A:\n  ...\nLiteral[A()]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"invalid-overload",children:"invalid-overload"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"@overload"})," decorator requires that the decorated function has at least two overloaded signatures and a base implementation."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import *\n\n@overload\ndef no_base(x: int) -> None:\n  pass\n\n@overload\ndef no_base(x: str) -> int:\n  pass\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"@overload\ndef just_one(x: int) -> None:\n  pass\n\ndef just_one(x: str) -> None:\n  ...\n"})}),"\n",(0,a.jsx)(n.h2,{id:"invalid-param-spec",children:"invalid-param-spec"}),"\n",(0,a.jsxs)(n.p,{children:["This error is reported when ",(0,a.jsx)(n.code,{children:"typing.ParamSpec"})," is defined incorrectly or misused. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typing import *\n\nP = ParamSpec("Name Must Match!")\n\nP1 = ParamSpec("P1")\nP2 = ParamSpec("P2")\n\ndef f(x, *args: P1.args, **kwargs: P2.kwargs) -> None:\n  pass\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Here, ",(0,a.jsx)(n.code,{children:"P1.args"})," and ",(0,a.jsx)(n.code,{children:"P2.kwargs"})," can't be used together; ",(0,a.jsx)(n.code,{children:"*args"})," and ",(0,a.jsx)(n.code,{children:"**kwargs"})," must come from the same ",(0,a.jsx)(n.code,{children:"ParamSpec"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"invalid-self-type",children:"invalid-self-type"}),"\n",(0,a.jsxs)(n.p,{children:["This error occurs when ",(0,a.jsx)(n.code,{children:"Self"})," is used in a context Pyrefly does not currently support."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, Pyrefly does not currently allow ",(0,a.jsx)(n.code,{children:"Self"})," for ",(0,a.jsx)(n.code,{children:"TypedDict"}),", so the\nfollowing code would error:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import *\n\nclass TD(TypedDict):\n    x: Option[Self]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"invalid-super-call",children:"invalid-super-call"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"super()"})," has ",(0,a.jsx)(n.a,{href:"https://docs.python.org/3/library/functions.html#super",children:"a few restrictions"})," on how it is called."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"super()"})," can be called without arguments, but only when used inside a method of a class:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class Legal(Base1, Base2):\n  def f(self) -> None:\n    super().f()\n\ndef illegal(arg: SomeType) -> None:\n  super().f()\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When the function is called with two arguments, like ",(0,a.jsx)(n.code,{children:"super(T, x)"}),", then ",(0,a.jsx)(n.code,{children:"T"})," must be a type, and the second argument is either an object where ",(0,a.jsx)(n.code,{children:"isinstance(x, T)"})," is true\nor a type where ",(0,a.jsx)(n.code,{children:"issubclass(x, T)"})," is true."]}),"\n",(0,a.jsx)(n.h2,{id:"invalid-syntax",children:"invalid-syntax"}),"\n",(0,a.jsx)(n.p,{children:"This error covers syntactical edge cases that are not flagged by the parser."}),"\n",(0,a.jsx)(n.p,{children:"For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"x: list[int] = [0, 2, 3]\nx[0]: int = 1\n"})}),"\n",(0,a.jsxs)(n.p,{children:["It's not a parse error for an assignment to have an annotation, but it is forbidden by the type checker to annotate assignment to a subscript like ",(0,a.jsx)(n.code,{children:"x[0]"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"invalid-type-alias",children:"invalid-type-alias"}),"\n",(0,a.jsxs)(n.p,{children:["An error related to the definition or usage of a ",(0,a.jsx)(n.code,{children:"typing.TypeAlias"}),". Many of these cases are covered by ",(0,a.jsx)(n.a,{href:"#invalid-annotation",children:(0,a.jsx)(n.code,{children:"invalid-annotation"})}),", so this error\nspecifically handles illegal type alias values:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import TypeAlias\nx = 2\nBad: TypeAlias = x\n"})}),"\n",(0,a.jsx)(n.h2,{id:"invalid-type-var",children:"invalid-type-var"}),"\n",(0,a.jsx)(n.p,{children:"An error caused by incorrect usage or definition of a TypeVar. A few examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typing import TypeVar\n# Old-style TypeVars must be assigned to a matching variable.\nWrong = TypeVar("Name")\n\n# PEP 695-style TypeVars can be constrained, but there must be at least two:\ndef only_one_constraint[T: (int,)](x: T) -> T:\n  ...\n\n# It\'s also illegal to mix the two styles together.\nT = TypeVar("T")\ndef mixed[S](a: S, b: T) -> None:\n  ...\n'})}),"\n",(0,a.jsx)(n.h2,{id:"invalid-type-var-tuple",children:"invalid-type-var-tuple"}),"\n",(0,a.jsx)(n.p,{children:"An error caused by incorrect usage or definition of a TypeVarTuple."}),"\n",(0,a.jsxs)(n.p,{children:["TypeVarTuple has similar error cases to ",(0,a.jsx)(n.a,{href:"#invalid-type-var",children:"TypeVar"}),", but also a few of its own. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typing import TypeVarTuple\n\nTs = TypeVarTuple("Ts")\n\n# TypeVarTuples must always be unpacked:\nbad: tuple[Ts] = (...)\ngood: tuple[*Ts] = (...)\n\n# Only one TypeVarTuple is allowed in a list of type arguments:\ndef two_tups[*Xs, *Ys](xs: tuple[*Xs], ys: tuple[*Ys]) -> None:\n  ...\n'})}),"\n",(0,a.jsx)(n.h2,{id:"invalid-yield",children:"invalid-yield"}),"\n",(0,a.jsxs)(n.p,{children:["This error arises when ",(0,a.jsx)(n.code,{children:"yield"})," is used in a way that is not allowed. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typing import Generator\n\nfor _ in range(1, 10):\n  yield "can\'t yield outside of a function!"\n\ndef bad_yield_from() -> Generator[int, None, None]:\n  # `yield from` can only be used with iterables.\n  yield from 1\n'})}),"\n",(0,a.jsx)(n.h2,{id:"missing-argument",children:"missing-argument"}),"\n",(0,a.jsx)(n.p,{children:"An error caused by calling a function without all the required arguments."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def takes_two(x: int, y: int) -> int:\n  return x + y\n\ntakes_two(1)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"missing-attribute",children:"missing-attribute"}),"\n",(0,a.jsx)(n.p,{children:"This error is raised when attempting to access an attribute that does not exist on the given object or module."}),"\n",(0,a.jsxs)(n.p,{children:["In the case of modules, attempting to import an nonexistent name will raise ",(0,a.jsx)(n.a,{href:"#missing-module-attribute",children:"`missing-module-attribute"})," instead."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import os\nfrom os import bacarat  # missing-module-attribute\nos.jongleur()  # missing-attribute\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note that objects with type ",(0,a.jsx)(n.code,{children:"Any"})," will never raise this error."]}),"\n",(0,a.jsx)(n.h2,{id:"missing-import",children:"missing-import"}),"\n",(0,a.jsx)(n.p,{children:"A module could not be found."}),"\n",(0,a.jsxs)(n.p,{children:["The error message will include which paths were searched, such as the site package paths.\nYou may be missing a dependency, or you may need to inform Pyrefly where the module lives. See ",(0,a.jsx)(n.a,{href:"/en/docs/configuration",children:"Configuration"})," for further information."]}),"\n",(0,a.jsx)(n.h2,{id:"missing-module-attribute",children:"missing-module-attribute"}),"\n",(0,a.jsx)(n.p,{children:"Arises when attempting to import a name that does not exist from a module."}),"\n",(0,a.jsxs)(n.p,{children:["This is distinct from ",(0,a.jsx)(n.a,{href:"#missing-import",children:(0,a.jsx)(n.code,{children:"missing-import"})}),", which is used when the module being imported does not exist, and ",(0,a.jsx)(n.a,{href:"#missing-attribute",children:(0,a.jsx)(n.code,{children:"missing-attribute"})}),", when access attributes of the module."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import this_does_not_exist  # missing-import\nimport os.bacarat  # missing-import\nfrom os import joker  # missing-module-attribute\nos.perkeo  # missing-attribute\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, ",(0,a.jsx)(n.code,{children:"os.bacarat"})," is treated as a module name, so failing to find it results in an ",(0,a.jsx)(n.code,{children:"missing-import"}),".\n",(0,a.jsx)(n.code,{children:"from os import joker"})," does not tell us if ",(0,a.jsx)(n.code,{children:"joker"})," is a module, class, function, etc., so it is treated as the more general ",(0,a.jsx)(n.code,{children:"missing-module-attribute"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"missing-source",children:"missing-source"}),"\n",(0,a.jsxs)(n.p,{children:["Pyrefly was able to find a stubs package but no corresponding source package. For example, this can\nhappen if you install the ",(0,a.jsx)(n.code,{children:"types-requests"})," package but forget to install ",(0,a.jsx)(n.code,{children:"requests"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"no-access",children:"no-access"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"no-access"})," error indicates that an attribute exists, but it cannot be used in this way."]}),"\n",(0,a.jsx)(n.p,{children:"For example, classes do not have access to their instances' attributes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class Ex:\n  def __init__(self) -> None:\n    self.meaning: int = 42\n\ndel Ex.meaning  # no-access\n"})}),"\n",(0,a.jsx)(n.h2,{id:"no-matching-overload",children:"no-matching-overload"}),"\n",(0,a.jsxs)(n.p,{children:["This error is similar to the other bad function call errors, but specifically for cases where a function decorated with ",(0,a.jsx)(n.code,{children:"@overload"})," is called with arguments that do not match any of the overloaded variations."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, neither of the signatures of ",(0,a.jsx)(n.code,{children:"f"})," can take an argument of type ",(0,a.jsx)(n.code,{children:"float"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import overload\n\n@overload\ndef f(x: int) -> int:\n    ...\n\n@overload\ndef f(x: str) -> str:\n    ...\n\ndef f(x: int | str) -> int | str:\n    return x\n\nf(1.0)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"not-a-type",children:"not-a-type"}),"\n",(0,a.jsx)(n.p,{children:"This indicates an attempt to use something that isn't a type where a type is expected.\nIn most cases, a more specific error kind is used."}),"\n",(0,a.jsx)(n.p,{children:"You may see this error around incorrect type aliases:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class A:\n  ...\n# Not an alias, just a string!\nX = "A"\nx: X = ...  # X is not a type alias, so this is illegal\n'})}),"\n",(0,a.jsx)(n.h2,{id:"not-async",children:"not-async"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"not-async"})," is reported when attempting to ",(0,a.jsx)(n.code,{children:"await"})," on something that is not\nawaitable. This may indicate that a function should have been marked ",(0,a.jsx)(n.code,{children:"async"})," but\nwasn't."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def some_func() -> None:\n  ...\n\nawait some_func() # Expression is not awaitable [not-async]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This will also arise if the context manager used in an ",(0,a.jsx)(n.code,{children:"async with"})," statement\nhas ",(0,a.jsx)(n.code,{children:"__aenter__"})," and ",(0,a.jsx)(n.code,{children:"__aexit__"})," methods that are not marked ",(0,a.jsx)(n.code,{children:"async"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The fix is to use an ",(0,a.jsx)(n.code,{children:"async"})," function in the ",(0,a.jsx)(n.code,{children:"await"}),". This may mean making the\nfunction ",(0,a.jsx)(n.code,{children:"async"})," or finding an existing ",(0,a.jsx)(n.code,{children:"async"})," function to use instead."]}),"\n",(0,a.jsx)(n.h2,{id:"not-callable",children:"not-callable"}),"\n",(0,a.jsx)(n.p,{children:"A straightforward error: something that is not a function was used as if it were a function."}),"\n",(0,a.jsx)(n.p,{children:"One interesting place this error may occur is with decorators:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"x = 1\n\n@x  # not-callable\ndef foo() -> None:\n  ...\n"})}),"\n",(0,a.jsx)(n.h2,{id:"not-iterable",children:"not-iterable"}),"\n",(0,a.jsxs)(n.p,{children:["This is most likely to be seen in a ",(0,a.jsx)(n.code,{children:"for"})," loop:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"x = 1  # Or some other value\nfor val in x:  # not-iterable\n  ...\n"})}),"\n",(0,a.jsx)(n.h2,{id:"parse-error",children:"parse-error"}),"\n",(0,a.jsx)(n.p,{children:"An error related to parsing or syntax. This covers a variety of cases, such as function calls with duplicate keyword args, some poorly defined functions, and so on."}),"\n",(0,a.jsx)(n.h2,{id:"protocol-implicitly-defined-attribute",children:"protocol-implicitly-defined-attribute"}),"\n",(0,a.jsxs)(n.p,{children:["Protocols must declare the attributes they require directly in the class body. Assigning to a new ",(0,a.jsx)(n.code,{children:"self"})," attribute inside a protocol method introduces a member that implementations of the protocol would never be required to provide."]}),"\n",(0,a.jsx)(n.p,{children:"Add an annotated attribute (or property) to the protocol, or remove the assignment."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from typing import Protocol\n\nclass Template(Protocol):\n    name: str\n\n    def method(self) -> None:\n        self.temp: list[int] = []  # protocol-implicitly-defined-attribute\n"})}),"\n",(0,a.jsx)(n.h2,{id:"read-only",children:"read-only"}),"\n",(0,a.jsx)(n.p,{children:"This error indicates that the attribute being accessed does exist but cannot be modified."}),"\n",(0,a.jsxs)(n.p,{children:["For example, a ",(0,a.jsx)(n.code,{children:"@property"})," with no setter cannot be assigned to:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class Ex:\n    @property\n    def meaning(self) -> int:\n        return 42\n\nx = Ex()\nx.meaning = 0\n"})}),"\n",(0,a.jsx)(n.h2,{id:"redundant-cast",children:"redundant-cast"}),"\n",(0,a.jsxs)(n.p,{children:["This warning is raised when ",(0,a.jsx)(n.code,{children:"typing.cast()"})," is used to cast a value to a type it is already compatible with. Such casts are unnecessary and can be removed to improve code clarity."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import typing\n\nx: int = 42\n# This cast is redundant since x is already an int\ny = typing.cast(int, x)  # redundant-cast\n\n# This is a valid cast since we\'re casting from a more general type\nobj: object = "hello"\ns = typing.cast(str, obj)  # No warning - this is a valid cast\n'})}),"\n",(0,a.jsx)(n.p,{children:"The redundant cast warning helps identify unnecessary type casts that don't provide any additional type safety benefits."}),"\n",(0,a.jsx)(n.h2,{id:"redundant-condition",children:"redundant-condition"}),"\n",(0,a.jsx)(n.p,{children:"This error is used to indicate a type that's equivalent to True or False is used as a boolean condition (e.g. an uncalled function)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def f() -> bool:\n  ...\n\n# This will throw error, as it's likely that the function needs to be invoked.\nif f:\n  ...\n# This will throw error, as it's equivalent to `if True`.\nif \"abc\":\n  ...\n"})}),"\n",(0,a.jsx)(n.h2,{id:"reveal-type",children:"reveal-type"}),"\n",(0,a.jsxs)(n.p,{children:["Pyrefly uses this error to communicate the output of the ",(0,a.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/directives.html#reveal-type",children:(0,a.jsx)(n.code,{children:"reveal_type"})})," function."]}),"\n",(0,a.jsx)(n.h2,{id:"unbound-name",children:"unbound-name"}),"\n",(0,a.jsxs)(n.p,{children:["This error corresponds to the runtime ",(0,a.jsx)(n.code,{children:"NameError"}),", indicating that a variable is referenced but does not exist."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def do_things(stuff: list[int]) -> str:\n  ...\n\ndo_thing([1, 2])  # typo! Or, unbound-name\n"})}),"\n",(0,a.jsx)(n.h2,{id:"unexpected-keyword",children:"unexpected-keyword"}),"\n",(0,a.jsx)(n.p,{children:"A function was called with an extra keyword argument."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def two_args(a: int, b: int) -> int:\n  ...\n\ntwo_args(a=1, b=2, c=3)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"unexpected-positional-argument",children:"unexpected-positional-argument"}),"\n",(0,a.jsx)(n.p,{children:"A positional argument was passed for a keyword-only parameter."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def takes_kwonly(*, x: int) -> int:\n  ...\n\ntakes_kwonly(1)  # should be `takes_kwonly(x=1)`!\n"})}),"\n",(0,a.jsx)(n.h2,{id:"unknown-name",children:"unknown-name"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"unknown-name"})," occurs when attempting to load a name from another scope, but the name cannot be found."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def where() -> None:\n  # There is no spoon: unknown-name\n  global spoon\n"})}),"\n",(0,a.jsx)(n.h2,{id:"unsupported",children:"unsupported"}),"\n",(0,a.jsx)(n.p,{children:"This error indicates that pyrefly does not currently support a typing feature."}),"\n",(0,a.jsx)(n.h2,{id:"unsupported-delete",children:"unsupported-delete"}),"\n",(0,a.jsxs)(n.p,{children:["This error occurs when attempting to ",(0,a.jsx)(n.code,{children:"del"})," something that cannot be deleted."]}),"\n",(0,a.jsxs)(n.p,{children:["Besides obvious things like built-in values (you can't ",(0,a.jsx)(n.code,{children:"del True"}),"!), some object attributes are protected from deletion.\nFor example, read-only and required ",(0,a.jsx)(n.code,{children:"TypedDict"})," fields cannot be deleted."]}),"\n",(0,a.jsx)(n.h2,{id:"unsupported-operation",children:"unsupported-operation"}),"\n",(0,a.jsx)(n.p,{children:"This error arises when attempting to perform an operation between values of two incompatible types."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'if "hello" in 1:  # int doesn\'t support `in`!\n  ...\n'})}),"\n",(0,a.jsx)(n.h2,{id:"unused-coroutine",children:"unused-coroutine"}),"\n",(0,a.jsx)(n.p,{children:"If the result of an async function call is not awaited or used, we will raise an error."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"async def foo():\n    return 1\n\nasync def bar():\n    foo()  # error\n    await foo()  # ok\n    x = foo()  # ok\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);