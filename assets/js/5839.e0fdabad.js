"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5839],{65839:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"import-resolution","title":"Import Resolution","description":"How imports in a given file are found by Pyrefly and their bindings are resolved, including files that are being type checked","source":"@site/docs/import-resolution.mdx","sourceDirName":".","slug":"/import-resolution","permalink":"/en/docs/import-resolution","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/pyrefly/edit/main/website/docs/import-resolution.mdx","tags":[],"version":"current","frontMatter":{"title":"Import Resolution","slug":"/import-resolution","description":"How imports in a given file are found by Pyrefly and their bindings are resolved, including files that are being type checked"},"sidebar":"docsSidebar","previous":{"title":"Error Kinds","permalink":"/en/docs/error-kinds"},"next":{"title":"Pydantic Support","permalink":"/en/docs/pydantic"}}');var n=t(74848),o=t(28453);const r={title:"Import Resolution",slug:"/import-resolution",description:"How imports in a given file are found by Pyrefly and their bindings are resolved, including files that are being type checked"},c="Import Resolution",l={},a=[{value:"Relative Imports",id:"relative-imports",level:2},{value:"Absolute Imports",id:"absolute-imports",level:2},{value:"Search Path",id:"search-path",level:3},{value:"Fallback Search Path",id:"fallback-search-path",level:3},{value:"Site Package Path",id:"site-package-path",level:3},{value:"Stub Files vs Source Files",id:"stub-files-vs-source-files",level:2},{value:"Editable Installs",id:"editable-installs",level:2},{value:"uv with setuptools",id:"uv-with-setuptools",level:3},{value:"pip with setuptools",id:"pip-with-setuptools",level:3},{value:"Hatch / Hatchling",id:"hatch--hatchling",level:3},{value:"PDM",id:"pdm",level:3},{value:"Poetry / Poetry-core",id:"poetry--poetry-core",level:3},{value:"Debugging Import Issues",id:"debugging-import-issues",level:2}];function h(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"import-resolution",children:"Import Resolution"})}),"\n",(0,n.jsx)(i.p,{children:"This doc describes how imports in a given file are found within Pyrefly while performing\na type check or resolving IDE language support operations."}),"\n",(0,n.jsxs)(i.p,{children:["NOTE: see the ",(0,n.jsx)(i.a,{href:"/en/docs/configuration",children:"Configuration documentation"})," for more info on\nthe config options referenced below."]}),"\n",(0,n.jsx)(i.h2,{id:"relative-imports",children:"Relative Imports"}),"\n",(0,n.jsxs)(i.p,{children:["If the import is relative (starting with one or more dots), the import is\nresolved relative to the path of the file importing it. A single dot at the\nbeginning of the import (e.g. ",(0,n.jsx)(i.code,{children:".file.to.import"}),") represents the current\ndirectory, and more dots (e.g. ",(0,n.jsx)(i.code,{children:"..other.file"}),") will continue to walk upward."]}),"\n",(0,n.jsx)(i.h2,{id:"absolute-imports",children:"Absolute Imports"}),"\n",(0,n.jsx)(i.p,{children:"For absolute imports, Pyrefly searches for a match in each of the following groups. The\nmatching process is explained in the next paragraph."}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:["Try to import from the search path. See the ",(0,n.jsx)(i.a,{href:"#search-path",children:"search path section"})," for more information."]}),"\n",(0,n.jsxs)(i.li,{children:["Try to import from ",(0,n.jsx)(i.code,{children:"typeshed"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:["Try to import from the fallback search path. See the ",(0,n.jsx)(i.a,{href:"#fallback-search-path",children:"fallback search path section"})," for\nmore information on the contents of the search path."]}),"\n",(0,n.jsxs)(i.li,{children:["Try to import from the site package path. See the\n",(0,n.jsx)(i.a,{href:"#site-package-path",children:"site package path section"})," for more information on the contents\nof the site package path."]}),"\n",(0,n.jsx)(i.li,{children:"Return an import error."}),"\n"]}),"\n",(0,n.jsxs)(i.p,{children:["When searching for a match in one of the above groups, Pyrefly performs the following process\nover two passes, one looking for stub ",(0,n.jsx)(i.em,{children:"packages"}),", and the other looking for source ",(0,n.jsx)(i.em,{children:"packages"}),". See\n",(0,n.jsx)(i.a,{href:"#stub-files-vs-source-files",children:"Stub Files vs Source Files"})," for more information."]}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"Attempt to match each part of the name to directories in the group, selecting the first\nmatch that is found."}),"\n",(0,n.jsxs)(i.li,{children:["If the result is a ",(0,n.jsx)(i.code,{children:".pyi"})," file or regular package (directory with an\n",(0,n.jsx)(i.code,{children:"__init__.py"}),"/",(0,n.jsx)(i.code,{children:"__init__.pyi"})," file), return the result. Otherwise, keep searching and\nattempt to find a ",(0,n.jsx)(i.code,{children:".pyi"})," file or regular package."]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"search-path",children:"Search Path"}),"\n",(0,n.jsxs)(i.p,{children:["The search path (",(0,n.jsxs)(i.a,{href:"/en/docs/configuration#search-path",children:["see ",(0,n.jsx)(i.code,{children:"search-path"})," in configuration docs"]}),")\nconsists of several entries representing project files."]}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"Search path from CLI args."}),"\n",(0,n.jsx)(i.li,{children:"Search path from config files."}),"\n",(0,n.jsxs)(i.li,{children:["If ",(0,n.jsx)(i.a,{href:"/en/docs/configuration#disable-search-path-heuristics",children:(0,n.jsx)(i.code,{children:"disable-search-path-heuristics"})}),"\nis not set, Pyrefly appends an import root directory to the search path."]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"The import root is:"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"src/"})," if there's a ",(0,n.jsx)(i.code,{children:"src/"})," directory in the same directory as the config file."]}),"\n",(0,n.jsxs)(i.li,{children:["The parent directory (",(0,n.jsx)(i.code,{children:".."}),") if there's an ",(0,n.jsx)(i.code,{children:"__init__.py"})," or ",(0,n.jsx)(i.code,{children:"__init__.pyi"})," in the same\ndirectory as the config file."]}),"\n",(0,n.jsx)(i.li,{children:"Otherwise, the directory containing the config file."}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"fallback-search-path",children:"Fallback Search Path"}),"\n",(0,n.jsxs)(i.p,{children:["The fallback search path is a heuristic automatically constructed by Pyrefly to attempt to\nfind project files when there's no config file marking the project root, and Pyrefly\nis unable to determine from other heuristics where an import root might be.\nIt is only constructed when\n",(0,n.jsx)(i.a,{href:"/en/docs/configuration#disable-search-path-heuristics",children:(0,n.jsx)(i.code,{children:"disable-search-path-heuristics"})}),"\nis not set."]}),"\n",(0,n.jsx)(i.p,{children:"The fallback search path consists of each directory from the directory containing\na given file to the root of your filesystem. For example, if you have the following setup:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"/\n|- projects/\n   |- project_a/\n   |  |- b/\n   |  |  |- c.py\n   |  |- d.py\n   |- project_e/\n      |- f.py\n"})}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"c.py"}),"'s fallback search path would be ",(0,n.jsx)(i.code,{children:"['/projects/project_a/b', '/projects/project_a', '/projects', '/']"})]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"d.py"})," could be importable with the paths ",(0,n.jsx)(i.code,{children:"d"}),", ",(0,n.jsx)(i.code,{children:"project_a.d"}),", or ",(0,n.jsx)(i.code,{children:"projects.project_a.d"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"f.py"})," could be importable with the paths ",(0,n.jsx)(i.code,{children:"project_e.f"})," or ",(0,n.jsx)(i.code,{children:"projects.project_e.f"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"e.py"}),"'s fallback search path would be ",(0,n.jsx)(i.code,{children:"['/projects/project_a', '/projects', '/']"})]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"c.py"})," could be importable with the paths ",(0,n.jsx)(i.code,{children:"b.c"}),", ",(0,n.jsx)(i.code,{children:"project_a.b.c"}),", or ",(0,n.jsx)(i.code,{children:"projects.project_a.b.c"})]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"f.py"})," could be importable with the paths ",(0,n.jsx)(i.code,{children:"project_e.f"})," or ",(0,n.jsx)(i.code,{children:"projects.project_e.f"})]}),"\n"]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"f.py"}),"'s fallback search path would be ",(0,n.jsx)(i.code,{children:"['/projects/project_e', '/projects', '/']"})]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"c.py"})," could be importable with the paths ",(0,n.jsx)(i.code,{children:"project_a.b.c"})," or ",(0,n.jsx)(i.code,{children:"projects.project_a.b.c"})]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"d.py"})," could be importable with the paths ",(0,n.jsx)(i.code,{children:"project_a.d"})," or ",(0,n.jsx)(i.code,{children:"projects.project_a.d"})]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"site-package-path",children:"Site Package Path"}),"\n",(0,n.jsxs)(i.p,{children:["The site package path\n(",(0,n.jsxs)(i.a,{href:"/en/docs/configuration#site-package-path",children:["see ",(0,n.jsx)(i.code,{children:"site-package-path"})," in configuration docs"]}),")\nconsists of several entries representing third-party packages."]}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"Site package path from a config file (if no CLI override is present) or CLI args."}),"\n",(0,n.jsxs)(i.li,{children:["A site package path queried from a Python interpreter, if one could be found.\nSee ",(0,n.jsx)(i.a,{href:"/en/docs/configuration#environment-autoconfiguration",children:"Environment Autoconfiguration"}),"\nfor more information on finding interpreters."]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"stub-files-vs-source-files",children:"Stub Files vs Source Files"}),"\n",(0,n.jsxs)(i.p,{children:["A\n",(0,n.jsx)(i.a,{href:"https://typing.python.org/en/latest/spec/distributing.html#stub-files",children:"stub file"}),"\nis any file that ends with a ",(0,n.jsx)(i.code,{children:".pyi"})," file suffix. They have many uses, including\nadding typing to non-Python extension code, distributing typing information\nseparate from implementation, or overriding an implementation with more accurate\ntyping information."]}),"\n",(0,n.jsxs)(i.p,{children:["A stub package is a second package corresponding to a regular package, with ",(0,n.jsx)(i.code,{children:"-stubs"}),"\nappended to its name. A ",(0,n.jsx)(i.code,{children:"-stubs"})," package should only include stub files (",(0,n.jsx)(i.code,{children:".pyi"}),"),\nwhich override any ",(0,n.jsx)(i.code,{children:".py"})," or ",(0,n.jsx)(i.code,{children:".pyi"})," files in the non-stubs package. These are preferred\nwhen available, since they contain the interfaces a library exposes to developers. An\nexample of this includes the popular library ",(0,n.jsx)(i.a,{href:"https://github.com/pandas-dev/pandas",children:(0,n.jsx)(i.code,{children:"pandas"})}),",\nand its stub package, ",(0,n.jsx)(i.a,{href:"https://github.com/pandas-dev/pandas-stubs",children:(0,n.jsx)(i.code,{children:"pandas-stubs"})}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["When importing from a non-stubs package, Pyrefly loads typing information from\nimports by first searching for a relevant ",(0,n.jsx)(i.code,{children:"-stubs"})," package, then by looking at\nthe non-stubs package's ",(0,n.jsx)(i.code,{children:".pyi"})," files, then falls back to a ",(0,n.jsx)(i.code,{children:".py"})," file. See\n",(0,n.jsx)(i.a,{href:"#absolute-imports",children:"Absolute Imports"})," for details on when non-stubs packages\nare allowed to be used for types, and how you can override that behavior."]}),"\n",(0,n.jsx)(i.h2,{id:"editable-installs",children:"Editable Installs"}),"\n",(0,n.jsxs)(i.p,{children:["When using static analysis tools with an editable install, the editable install should be configured to use ",(0,n.jsx)(i.code,{children:".pth"}),"\nfiles that contain file paths (",(0,n.jsx)(i.code,{children:"/project/src/module"}),") rather than executable lines (started with ",(0,n.jsx)(i.code,{children:"import"}),") that\ninstall import hooks. See ",(0,n.jsx)(i.a,{href:"https://setuptools.pypa.io/en/latest/userguide/development_mode.html",children:"setuptools doc"}),"\nand ",(0,n.jsx)(i.a,{href:"https://peps.python.org/pep-0660/",children:"PEP 660"})," for more information."]}),"\n",(0,n.jsxs)(i.p,{children:["Import hooks can provide an editable installation that offers a more accurate representation of the actual installation\nenvironment. However, since resolving module locations through an import hook\n",(0,n.jsx)(i.strong,{children:"requires executing Python code at runtime"}),", they are incompatible with Pyrefly and other static analysis tools that\noperate without code execution. Consequently, when an editable install is configured to use import hooks, Pyrefly\nwill be unable to automatically locate and analyze the corresponding source files, resulting in incomplete type checking and\ncode analysis."]}),"\n",(0,n.jsxs)(i.p,{children:["Setuptools build system uses import hooks by default for editable installations. To ensure compatibility between\nsetuptools-based editable installs and Pyrefly, setuptools must be configured to use path-based ",(0,n.jsx)(i.code,{children:".pth"})," files instead.\nThis configuration should be performed through the build frontend (such as ",(0,n.jsx)(i.code,{children:"pip"}),") by specifying the appropriate\noptions during installation or in the project's configuration files."]}),"\n",(0,n.jsx)(i.h3,{id:"uv-with-setuptools",children:"uv with setuptools"}),"\n",(0,n.jsxs)(i.p,{children:["When using ",(0,n.jsx)(i.a,{href:"https://docs.astral.sh/uv/",children:"uv"})," with setuptools, uv can be\n",(0,n.jsx)(i.a,{href:"https://docs.astral.sh/uv/reference/settings/#config-settings",children:"configured"})," to avoid import hooks."]}),"\n",(0,n.jsxs)(i.p,{children:["NOTE: The ",(0,n.jsx)(i.code,{children:"uv_build"})," backend always uses path-based ",(0,n.jsx)(i.code,{children:".pth"})," files."]}),"\n",(0,n.jsx)(i.h3,{id:"pip-with-setuptools",children:"pip with setuptools"}),"\n",(0,n.jsxs)(i.p,{children:["When using ",(0,n.jsx)(i.code,{children:"pip"})," with setuptools-based projects, there are two ways to avoid import hooks:\n",(0,n.jsx)(i.a,{href:"https://setuptools.pypa.io/en/latest/userguide/development_mode.html#legacy-behavior",children:"compat mode"}),"\nand ",(0,n.jsx)(i.a,{href:"https://setuptools.pypa.io/en/latest/userguide/development_mode.html#strict-editable-installs",children:"strict mode"}),"."]}),"\n",(0,n.jsx)(i.h3,{id:"hatch--hatchling",children:"Hatch / Hatchling"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"https://hatch.pypa.io/1.9/config/build/",children:"Hatchling"})," uses path-based ",(0,n.jsx)(i.code,{children:".pth"})," files by default.\nIt will only use import hooks if you set ",(0,n.jsxs)(i.a,{href:"https://hatch.pypa.io/latest/config/build/#dev-mode",children:[(0,n.jsx)(i.code,{children:"dev-mode-exact"})," to true"]}),"."]}),"\n",(0,n.jsx)(i.h3,{id:"pdm",children:"PDM"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"https://backend.pdm-project.org/",children:"PDM"})," uses path-based ",(0,n.jsx)(i.code,{children:".pth"})," files by default.\nIt will only use import hooks if you set\n",(0,n.jsxs)(i.a,{href:"https://backend.pdm-project.org/build_config/#choose-the-editable-build-format",children:[(0,n.jsx)(i.code,{children:"editable-backend"}),' to "editables"']}),"."]}),"\n",(0,n.jsx)(i.h3,{id:"poetry--poetry-core",children:"Poetry / Poetry-core"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"https://github.com/python-poetry/poetry-core",children:"Poetry-core"})," backend always uses path-based ",(0,n.jsx)(i.code,{children:".pth"})," files."]}),"\n",(0,n.jsx)(i.h2,{id:"debugging-import-issues",children:"Debugging Import Issues"}),"\n",(0,n.jsxs)(i.p,{children:["Pyrefly has a ",(0,n.jsx)(i.code,{children:"dump-config"})," command that dumps the import-related config options it is using for\neach file it is checking. To use it, simply replace ",(0,n.jsx)(i.code,{children:"check"})," with ",(0,n.jsx)(i.code,{children:"dump-config"})," in your\ncommand-line invocation."]})]})}function d(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}}}]);